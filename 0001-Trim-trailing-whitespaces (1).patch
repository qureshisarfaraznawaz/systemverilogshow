From b22bf4e4c421c0bede3cb96a9b14844544b08ce5 Mon Sep 17 00:00:00 2001
From: X <X@systemverilogshow.com>
Date: Sun, 14 Jul 2013 01:34:32 -0700
Subject: [PATCH] Trim trailing whitespaces

---
 lesson0001_interface_basic/class_stimulus.sv       |   4 +-
 lesson0001_interface_basic/dut.sv                  |   6 +-
 lesson0001_interface_basic/dut_w_if.sv             |  10 +-
 lesson0001_interface_basic/score_if.sv             |   2 +-
 lesson0001_interface_basic/score_items_if.sv       |   2 +-
 lesson0001_interface_basic/stimulus.sv             |   4 +-
 lesson0001_interface_basic/stimulus_w_if.sv        |   6 +-
 lesson0001_interface_basic/top.sv                  |  14 +-
 lesson0001_interface_basic/top_final.sv            |   6 +-
 lesson0001_interface_basic/top_w__dut_w_if.sv      |   6 +-
 lesson0001_interface_basic/top_w_vif.sv            |   6 +-
 .../FINAL/class_stimulus.svh                       |  10 +-
 lesson0002_virtual_interface_basic/FINAL/dut.sv    |   6 +-
 lesson0002_virtual_interface_basic/FINAL/my_if.sv  |   2 +-
 lesson0002_virtual_interface_basic/FINAL/tb_top.sv |   2 +-
 lesson0002_virtual_interface_basic/FINAL/test.sv   |   6 +-
 .../class_stimulus.svh                             |   4 +-
 lesson0002_virtual_interface_basic/dut.sv          |   6 +-
 lesson0002_virtual_interface_basic/my_if.sv        |   2 +-
 lesson0002_virtual_interface_basic/tb_top.sv       |   2 +-
 lesson0002_virtual_interface_basic/test.sv         |   4 +-
 .../FINAL/class_stimulus.svh                       |  10 +-
 lesson0003_virtual_interface_basic/FINAL/dut.sv    |   6 +-
 lesson0003_virtual_interface_basic/FINAL/my_if.sv  |   2 +-
 lesson0003_virtual_interface_basic/FINAL/tb_top.sv |   2 +-
 lesson0003_virtual_interface_basic/FINAL/test.sv   |   6 +-
 .../class_stimulus.svh                             |  10 +-
 lesson0003_virtual_interface_basic/dut.sv          |   6 +-
 lesson0003_virtual_interface_basic/my_if.sv        |   2 +-
 lesson0003_virtual_interface_basic/tb_top.sv       |   2 +-
 lesson0003_virtual_interface_basic/test.sv         |  10 +-
 lesson0004_queue/my_queue.sv                       |  10 +-
 lesson0004_queue/use_queue.sv                      |  14 +-
 lesson0004_typedef_and_enum/class_drink.svh        |   8 +-
 .../class_drink.svh                                |   8 +-
 lesson0005_queue+1/queue1.sv                       |  18 +-
 lesson0006_queue+2/queue2.sv                       |  22 +-
 lesson0007_associate_array/use_associate_array.sv  |  10 +-
 lesson0007_queue+3/queue3.sv                       |  10 +-
 lesson0008_assoc_array/aa.sv                       |  14 +-
 lesson0008_assoc_array/bb.sv                       |   4 +-
 lesson0009_assoc_array+1/aa.sv                     |  18 +-
 lesson0009_assoc_array+1/bb.sv                     |  16 +-
 .../uvm_examples/ex_mtm_layering/demo.ecom         |   2 +-
 .../uvm_examples/ex_mtm_layering/demo.sh           |   4 +-
 .../ex_mtm_layering/e/ex_mtm_layering_base.e       |  22 +-
 .../ex_mtm_layering/e/ex_mtm_layering_ll_pkt_env.e |  98 ++++-----
 .../e/ex_mtm_layering_ll_pkt_seq_lib.e             |  48 ++---
 .../e/ex_mtm_layering_ml_pkt_seq_lib.e             |  44 ++--
 .../ex_mtm_layering_ml_pkt_seq_lib_using_pre_do.e  |  44 ++--
 .../ex_mtm_layering/e/ex_mtm_layering_system_env.e |  30 +--
 .../e/ex_mtm_layering_system_seq_lib.e             |  44 ++--
 .../ex_mtm_layering/e/ex_mtm_layering_top.e        |  14 +-
 .../e/ex_mtm_layering_ul_header_env.e              |  58 +++---
 .../ex_mtm_layering/e/ex_mtm_layering_ul_pkt_env.e |  62 +++---
 .../e/ex_mtm_layering_ul_pkt_seq_lib.e             |  36 ++--
 .../uvm_examples/ex_mto_layering/demo.ecom         |   2 +-
 .../uvm_examples/ex_mto_layering/demo.sh           |   4 +-
 .../ex_mto_layering/e/ex_mto_layering_base.e       |  22 +-
 .../ex_mto_layering/e/ex_mto_layering_ll_pkt_env.e |  86 ++++----
 .../e/ex_mto_layering_ll_pkt_seq_lib.e             |  34 ++--
 .../e/ex_mto_layering_ll_pkt_seq_lib_using_do.e    |  30 +--
 .../ex_mto_layering/e/ex_mto_layering_system_env.e |  32 +--
 .../e/ex_mto_layering_system_seq_lib.e             |  18 +-
 .../ex_mto_layering/e/ex_mto_layering_top.e        |  16 +-
 .../ex_mto_layering/e/ex_mto_layering_ul_pkt_env.e |  58 +++---
 .../e/ex_mto_layering_ul_pkt_seq_lib.e             |  44 ++--
 .../examples/ex_mto_layering_test.e                |  26 +--
 .../uvm_examples/ex_otm_layering/demo.ecom         |   2 +-
 .../uvm_examples/ex_otm_layering/demo.sh           |   4 +-
 .../ex_otm_layering/e/ex_otm_layering_atm_env.e    |  76 +++----
 .../e/ex_otm_layering_atm_seq_lib.e                |  36 ++--
 .../ex_otm_layering/e/ex_otm_layering_base.e       |  14 +-
 .../ex_otm_layering/e/ex_otm_layering_packet_env.e |  52 ++---
 .../e/ex_otm_layering_packet_seq_lib.e             |  24 +--
 .../ex_otm_layering/e/ex_otm_layering_system_env.e |  30 +--
 .../e/ex_otm_layering_system_seq_lib.e             |  16 +-
 .../ex_otm_layering/e/ex_otm_layering_top.e        |  12 +-
 .../examples/ex_otm_layering_test.e                |  28 +--
 .../examples/ex_otm_layering_test_item_relevant.e  |  30 +--
 .../examples/ex_otm_layering_test_multi_layered.e  |  52 ++---
 .../examples/ex_otm_layering_test_simple.e         |  22 +-
 .../uvm_examples/ex_oto_layering/demo.ecom         |   2 +-
 .../uvm_examples/ex_oto_layering/demo.sh           |   4 +-
 .../ex_oto_layering/e/ex_oto_layering_base.e       |  24 +--
 .../ex_oto_layering/e/ex_oto_layering_frame_env.e  |  72 +++----
 .../e/ex_oto_layering_frame_seq_lib.e              |  46 ++---
 .../e/ex_oto_layering_frame_seq_lib_using_pre_do.e |  42 ++--
 .../ex_oto_layering/e/ex_oto_layering_packet_env.e |  66 +++---
 .../e/ex_oto_layering_packet_seq_lib.e             |  26 +--
 .../ex_oto_layering/e/ex_oto_layering_system_env.e |  28 +--
 .../e/ex_oto_layering_system_seq_lib.e             |  14 +-
 .../ex_oto_layering/e/ex_oto_layering_top.e        |  12 +-
 .../examples/ex_oto_layering_test.e                |  32 +--
 .../examples/ex_oto_layering_test_multi_layered.e  |  48 ++---
 .../examples/ex_oto_layering_test_simple.e         |  22 +-
 .../playpen/sc_producer_sv_consumer_test/Makefile  |  38 ++--
 .../sc_producer_sv_consumer_test/Makefile.depends  |   2 +-
 .../sc_producer_sv_consumer_test/consumer.sv       |   6 +-
 .../playpen/sc_producer_sv_consumer_test/packet.sv |   4 +-
 .../playpen/sc_producer_sv_consumer_test/run.f     |   8 +-
 .../playpen/sc_producer_sv_consumer_test/test.cpp  |   8 +-
 .../playpen/sc_producer_sv_consumer_test/test.sv   |   4 +-
 .../sc_producer_sv_consumer_test/Makefile          |  38 ++--
 .../sc_producer_sv_consumer_test/Makefile.depends  |   2 +-
 .../sc_producer_sv_consumer_test/consumer.sv       |   6 +-
 .../sc_producer_sv_consumer_test/packet.sv         |   4 +-
 .../sc_producer_sv_consumer_test/run.f             |   8 +-
 .../sc_producer_sv_consumer_test/test.cpp          |   8 +-
 .../sc_producer_sv_consumer_test/test.sv           |   4 +-
 .../uvm_examples/sv_test_sc_tlm10_dut/Makefile     |  40 ++--
 .../sv_test_sc_tlm10_dut/Makefile.depends          |   2 +-
 .../uvm_examples/sv_test_sc_tlm10_dut/packet.h     |   6 +-
 .../uvm_examples/sv_test_sc_tlm10_dut/run.f        |   6 +-
 .../uvm_examples/sv_test_sc_tlm10_dut/test.sv      |   8 +-
 lesson000X_mluvm_svsc/uvm_examples/xbus_e/demo.sh  |  26 +--
 .../xbus_e/dut/xbus_bus_monitor_bfm.sv             |   4 +-
 .../xbus_e/dut/xbus_master_driver_bfm.sv           |  28 +--
 .../xbus_e/dut/xbus_master_monitor_bfm.sv          |   4 +-
 .../xbus_e/dut/xbus_slave_driver_bfm.sv            |  12 +-
 .../xbus_e/dut/xbus_slave_monitor_bfm.sv           |   6 +-
 .../uvm_examples/xbus_e/e/simple_ram_env.e         |  26 +--
 .../uvm_examples/xbus_e/e/xbus_accel.e             | 196 +++++++++---------
 .../uvm_examples/xbus_e/e/xbus_agent_h.e           |  34 ++--
 .../uvm_examples/xbus_e/e/xbus_agent_monitor.e     |  38 ++--
 .../uvm_examples/xbus_e/e/xbus_agent_monitor_h.e   |  22 +-
 .../uvm_examples/xbus_e/e/xbus_arbiter_agent.e     |  14 +-
 .../uvm_examples/xbus_e/e/xbus_arbiter_bfm.e       |  66 +++---
 .../xbus_e/e/xbus_arbiter_sequence_h.e             |  40 ++--
 .../uvm_examples/xbus_e/e/xbus_basic_seq_lib.e     |  42 ++--
 .../uvm_examples/xbus_e/e/xbus_bfm.e               |  12 +-
 .../uvm_examples/xbus_e/e/xbus_bus_collector.e     |  78 +++----
 .../uvm_examples/xbus_e/e/xbus_bus_collector_h.e   |  42 ++--
 .../uvm_examples/xbus_e/e/xbus_bus_monitor.e       |  56 +++---
 .../uvm_examples/xbus_e/e/xbus_bus_monitor_h.e     |  28 +--
 .../uvm_examples/xbus_e/e/xbus_coverage.e          |  12 +-
 .../uvm_examples/xbus_e/e/xbus_end_test.e          |  14 +-
 .../uvm_examples/xbus_e/e/xbus_env.e               |  74 +++----
 .../uvm_examples/xbus_e/e/xbus_env_h.e             |  20 +-
 .../uvm_examples/xbus_e/e/xbus_master_agent.e      |  24 +--
 .../uvm_examples/xbus_e/e/xbus_master_bfm.e        |  76 +++----
 .../uvm_examples/xbus_e/e/xbus_master_sequence_h.e |  56 +++---
 .../uvm_examples/xbus_e/e/xbus_port_config.e       |  14 +-
 .../uvm_examples/xbus_e/e/xbus_protocol_checker.e  |  56 +++---
 .../uvm_examples/xbus_e/e/xbus_signal_map_h.e      |  58 +++---
 .../uvm_examples/xbus_e/e/xbus_slave_agent.e       |  26 +--
 .../uvm_examples/xbus_e/e/xbus_slave_bfm.e         |  74 +++----
 .../uvm_examples/xbus_e/e/xbus_slave_sequence_h.e  |  56 +++---
 .../uvm_examples/xbus_e/e/xbus_top.e               |  12 +-
 .../uvm_examples/xbus_e/e/xbus_trans_h.e           |  40 ++--
 .../uvm_examples/xbus_e/e/xbus_types_h.e           |  20 +-
 .../uvm_examples/xbus_e/examples/msg_patch.e       |  16 +-
 .../uvm_examples/xbus_e/examples/test_1.e          |  20 +-
 .../xbus_e/examples/test_multi_reset.e             |  14 +-
 .../uvm_examples/xbus_e/examples/test_read_write.e |  28 +--
 .../xbus_e/examples/test_reconfiguration.e         |  40 ++--
 .../uvm_examples/xbus_e/examples/test_signal.e     |  20 +-
 .../uvm_examples/xbus_e/examples/test_tba.e        |  18 +-
 .../uvm_examples/xbus_e/examples/xbus.sv           |   2 +-
 .../examples/xbus_arbiter_dut_signal_config.e      |  32 +--
 .../xbus_e/examples/xbus_arbiter_dut_tba_config.e  |  28 +--
 .../uvm_examples/xbus_e/examples/xbus_config.e     |  24 +--
 .../uvm_examples/xbus_e/examples/xbus_dut_top.sv   |   4 +-
 .../uvm_examples/xbus_e/scripts/demo_on_sim.sh     |   2 +-
 .../uvm_examples/xbus_e/scripts/setup.csh          |   8 +-
 .../uvm_examples/xbus_e/v/tb_xbus.v                |  14 +-
 lesson000X_mluvm_svsc/uvm_examples/xcore/demo.sh   |  16 +-
 .../uvm_examples/xcore/e/xcore_checker.e           |  30 +--
 .../uvm_examples/xcore/e/xcore_combined_seq_lib.e  |  32 +--
 .../xcore/e/xcore_combined_sequence_h.e            |  32 +--
 .../uvm_examples/xcore/e/xcore_compile_base.e      |  10 +-
 .../uvm_examples/xcore/e/xcore_config.e            |  22 +-
 .../uvm_examples/xcore/e/xcore_cover.e             | 156 +++++++-------
 .../uvm_examples/xcore/e/xcore_env.e               | 100 ++++-----
 .../uvm_examples/xcore/e/xcore_monitor.e           |  70 +++----
 .../uvm_examples/xcore/e/xcore_port_config.e       |  44 ++--
 .../uvm_examples/xcore/e/xcore_ref_model.e         | 142 ++++++-------
 .../uvm_examples/xcore/e/xcore_registers.e         |  22 +-
 .../xcore/e/xcore_registers_basic_seq_lib.e        |  68 +++----
 .../uvm_examples/xcore/e/xcore_top.e               |   8 +-
 .../uvm_examples/xcore/e/xcore_xbus_config.e       |  40 ++--
 .../xcore/e/xcore_xbus_master_basic_seq_lib.e      |  68 +++----
 .../xcore/e/xcore_xserial_basic_seq_lib.e          |  12 +-
 .../uvm_examples/xcore/e/xcore_xserial_config.e    |  20 +-
 .../uvm_examples/xcore/main_sve/main_sve_config.e  |  76 +++----
 .../uvm_examples/xcore/main_sve/main_sve_patches.e |   2 +-
 .../uvm_examples/xcore/main_sve/tests/setup_test.e |  24 +--
 .../main_sve/tests/xcore_error_rx_frames_test.e    |  22 +-
 .../xcore/main_sve/tests/xcore_fill_rx_fifo_test.e |   6 +-
 .../xcore/main_sve/tests/xcore_halt_test.e         |  56 +++---
 .../xcore/main_sve/tests/xcore_lpbk_test.e         |  10 +-
 .../xcore/main_sve/tests/xcore_phases_test.e       |  10 +-
 .../xcore/main_sve/tests/xcore_reconfiguration.e   |  60 +++---
 .../xcore/main_sve/tests/xcore_rerun_test.e        |  18 +-
 .../main_sve/tests/xcore_send_idle_frames_test.e   |  22 +-
 .../main_sve/tests/xcore_tx_frames_basic_test.e    |  10 +-
 .../tests/xcore_virtual_seq_doing_items_test.e     |  22 +-
 .../xcore/main_sve/tests/xcore_virtual_seq_test.e  |  20 +-
 .../xcore/main_sve/tests/xcore_xbus_seq_test.e     |  20 +-
 .../uvm_examples/xcore/v/tb_xcore.v                |  36 ++--
 .../uvm_examples/xcore/v/xcore_in_chan.v           | 120 +++++------
 .../uvm_examples/xcore/v/xcore_no_ovl.v            | 224 ++++++++++-----------
 .../uvm_examples/xcore/v/xcore_out_chan.v          |  62 +++---
 lesson000X_mluvm_svsc/uvm_examples/xserial/demo.sh |  14 +-
 .../uvm_examples/xserial/e/xserial_agent.e         |  38 ++--
 .../uvm_examples/xserial/e/xserial_agent_h.e       |  82 ++++----
 .../uvm_examples/xserial/e/xserial_bfm.e           |  42 ++--
 .../uvm_examples/xserial/e/xserial_bfm_h.e         |  16 +-
 .../uvm_examples/xserial/e/xserial_collector.e     |  34 ++--
 .../uvm_examples/xserial/e/xserial_collector_h.e   |  32 +--
 .../uvm_examples/xserial/e/xserial_coverage.e      |  32 +--
 .../uvm_examples/xserial/e/xserial_end_test.e      |  14 +-
 .../uvm_examples/xserial/e/xserial_env.e           |  26 +--
 .../uvm_examples/xserial/e/xserial_env_h.e         |  32 +--
 .../uvm_examples/xserial/e/xserial_frame_h.e       |  96 ++++-----
 .../xserial/e/xserial_frame_payload_data_h.e       |  24 +--
 .../xserial/e/xserial_frame_payload_h.e            |  98 ++++-----
 .../xserial/e/xserial_frame_payload_message_h.e    |  34 ++--
 .../uvm_examples/xserial/e/xserial_monitor.e       |  68 +++----
 .../uvm_examples/xserial/e/xserial_monitor_h.e     |  54 ++---
 .../uvm_examples/xserial/e/xserial_port_config.e   |  22 +-
 .../xserial/e/xserial_protocol_checker.e           |  34 ++--
 .../uvm_examples/xserial/e/xserial_sequence_h.e    |  26 +--
 .../uvm_examples/xserial/e/xserial_top.e           |   6 +-
 .../uvm_examples/xserial/e/xserial_types_h.e       |  12 +-
 .../uvm_examples/xserial/examples/test_1.e         |  12 +-
 .../xserial/examples/test_error_injection.e        |  12 +-
 .../xserial/examples/test_item_constraint.e        |  24 +--
 .../xserial/examples/test_multi_reset.e            |  26 +--
 .../xserial/examples/test_reconfiguration.e        |  38 ++--
 .../uvm_examples/xserial/examples/xserial_config.e |  16 +-
 lesson000X_mluvm_svsc/uvm_examples/xserial/v/dut.v |  42 ++--
 .../uvm_examples/xserial/v/dut_if_wrapper.sv       |  14 +-
 .../uvm_examples/xserial/v/in_chan.v               |  78 +++----
 .../uvm_examples/xserial/v/out_chan.v              | 106 +++++-----
 .../uvm_examples/xserial/v/tb_xserial.v            |  24 +--
 .../uvm_examples/xserial/v/vr_xserial_dut_if.sv    |  22 +-
 lesson0010_constraint_1/constraint_1.sv            |  14 +-
 lesson0010_constraint_1/dice_roll.sv               |  20 +-
 lesson0010_constraint_1/sean.sv                    |  12 +-
 lesson0011_constraint_2/a.sv                       |  18 +-
 lesson0011_constraint_2/constraint_1.sv            |  14 +-
 lesson0011_constraint_2/dice_roll.sv               |  32 +--
 lesson0012_constraint_3/a.sv                       |  34 ++--
 lesson0012_constraint_3/b.sv                       |  24 +--
 lesson0012_constraint_3/dice_roll.sv               |  36 ++--
 lesson0013_randc_and_constraint/a.sv               |  34 ++--
 lesson0013_randc_and_constraint/dice_roll.sv       |  14 +-
 lesson0014_rand_and_dist/a.sv                      |  34 ++--
 lesson0014_rand_and_dist/aa.sv                     |  16 +-
 lesson0014_rand_and_dist/dice_roll.sv              |  26 +--
 lesson0015_extern/abc.sv                           |  56 +++---
 lesson0015_extern/dice_roll.sv                     |  26 +--
 lesson0016_full_simple_tb/bind.sv                  |   4 +-
 lesson0016_full_simple_tb/dut.sv                   |   4 +-
 lesson0016_full_simple_tb/env.svh                  |   4 +-
 lesson0016_full_simple_tb/in_if.sv                 |   4 +-
 lesson0016_full_simple_tb/internal_if.sv           |   2 +-
 lesson0018_uvm_config_db/Help/solution/new.sv      |   4 +-
 lesson0018_uvm_config_db/Help/solution/test.sv     |  12 +-
 lesson0018_uvm_config_db/svs_dut.sv                |   6 +-
 lesson0018_uvm_config_db/svs_env.svh               |   4 +-
 lesson0018_uvm_config_db/svs_if.sv                 |   2 +-
 lesson0018_uvm_config_db/svs_test.sv               |   4 +-
 lesson0018_uvm_config_db/svs_top.sv                |   4 +-
 lesson0019_uvm_config_db/svs_dut.sv                |   6 +-
 lesson0019_uvm_config_db/svs_env.svh               |   4 +-
 lesson0019_uvm_config_db/svs_if.sv                 |   2 +-
 lesson0019_uvm_config_db/svs_test.sv               |  10 +-
 lesson0019_uvm_config_db/svs_top.sv                |   4 +-
 lesson0020_package_import_include/classA.sv        |   2 +-
 lesson0020_package_import_include/my_package1.sv   |   2 +-
 lesson0021_X_and_unary_operators/top.sv            |  14 +-
 lesson0022_package_chaining_export/branch_pkg.sv   |   4 +-
 lesson0022_package_chaining_export/leaf_pkg.sv     |   4 +-
 lesson0022_package_chaining_export/top.sv          |   2 +-
 lesson0022_package_chaining_export/trunk.svh       |   2 +-
 lesson0022_package_chaining_export/twig_pkg.sv     |   4 +-
 278 files changed, 3698 insertions(+), 3698 deletions(-)

diff --git a/lesson0001_interface_basic/class_stimulus.sv b/lesson0001_interface_basic/class_stimulus.sv
index d919993..74491b5 100644
--- a/lesson0001_interface_basic/class_stimulus.sv
+++ b/lesson0001_interface_basic/class_stimulus.sv
@@ -1,6 +1,6 @@
 class class_stimulus;
 
-   virtual 
+   virtual
+
 
-   
 endclass : class_stimulus
diff --git a/lesson0001_interface_basic/dut.sv b/lesson0001_interface_basic/dut.sv
index 4b19fe6..0a6f397 100644
--- a/lesson0001_interface_basic/dut.sv
+++ b/lesson0001_interface_basic/dut.sv
@@ -2,9 +2,9 @@ module dut(score_if this_if,
 	   output integer out_score
 	   );
     always@(*) begin
-        out_score= (this_if.if_age * 
-		    this_if.if_iq  * 
+        out_score= (this_if.if_age *
+		    this_if.if_iq  *
 		    this_if.if_shoesize)
-	  %101;  
+	  %101;
     end
 endmodule
diff --git a/lesson0001_interface_basic/dut_w_if.sv b/lesson0001_interface_basic/dut_w_if.sv
index 30d81f9..645e600 100644
--- a/lesson0001_interface_basic/dut_w_if.sv
+++ b/lesson0001_interface_basic/dut_w_if.sv
@@ -1,11 +1,11 @@
 module dut_w_if( score_items_if this_if,
 		 output integer out_score
 		 );
-   
+
     always@(*) begin
-        out_score = (this_if.if_age * 
-		     this_if.if_iq * 
-		     this_if.if_shoesize)%101;  
+        out_score = (this_if.if_age *
+		     this_if.if_iq *
+		     this_if.if_shoesize)%101;
     end // always@ (*)
-   
+
 endmodule // dut_w_if
diff --git a/lesson0001_interface_basic/score_if.sv b/lesson0001_interface_basic/score_if.sv
index 73b2f0b..c0814f8 100644
--- a/lesson0001_interface_basic/score_if.sv
+++ b/lesson0001_interface_basic/score_if.sv
@@ -3,5 +3,5 @@ interface score_if;
    integer if_age;
    integer if_iq;
    integer if_shoesize;
-    
+
 endinterface // score_if
diff --git a/lesson0001_interface_basic/score_items_if.sv b/lesson0001_interface_basic/score_items_if.sv
index 1744021..c1ed56f 100644
--- a/lesson0001_interface_basic/score_items_if.sv
+++ b/lesson0001_interface_basic/score_items_if.sv
@@ -2,7 +2,7 @@ interface score_items_if;
 
    integer if_age;
    integer if_iq;
-   integer if_shoesize;   
+   integer if_shoesize;
 
 endinterface // score_items_if
 
diff --git a/lesson0001_interface_basic/stimulus.sv b/lesson0001_interface_basic/stimulus.sv
index 3c1fb52..e291f9a 100644
--- a/lesson0001_interface_basic/stimulus.sv
+++ b/lesson0001_interface_basic/stimulus.sv
@@ -1,10 +1,10 @@
 module stimulus(score_if the_if);
    initial begin
-      repeat (3) begin	 
+      repeat (3) begin
 	 the_if.if_age      = $urandom;
 	 the_if.if_iq       = $urandom;
 	 the_if.if_shoesize = $urandom;
-	 #10;	 
+	 #10;
       end
    end
 endmodule
diff --git a/lesson0001_interface_basic/stimulus_w_if.sv b/lesson0001_interface_basic/stimulus_w_if.sv
index b4317f9..7900b06 100644
--- a/lesson0001_interface_basic/stimulus_w_if.sv
+++ b/lesson0001_interface_basic/stimulus_w_if.sv
@@ -1,5 +1,5 @@
-module stimulus_w_if( score_items_if s_if );   
-   
+module stimulus_w_if( score_items_if s_if );
+
    initial begin
       repeat (3) begin
 	 #40;
@@ -8,5 +8,5 @@ module stimulus_w_if( score_items_if s_if );
 	 s_if.if_shoesize = $urandom;
       end
    end
-   
+
 endmodule
diff --git a/lesson0001_interface_basic/top.sv b/lesson0001_interface_basic/top.sv
index 7d00d96..d460b7b 100644
--- a/lesson0001_interface_basic/top.sv
+++ b/lesson0001_interface_basic/top.sv
@@ -1,14 +1,14 @@
 module top;
-   integer dut_score;   
-   score_if that_if();   
-   stimulus stimulus( .the_if(that_if)   
-		      );   
+   integer dut_score;
+   score_if that_if();
+   stimulus stimulus( .the_if(that_if)
+		      );
    dut dut( .this_if(that_if),
             .out_score(dut_score)
-	    );       
+	    );
    initial begin
       $monitor($time, " new score is: %0d", dut_score);
-   end       
+   end
 endmodule
 
 
@@ -23,4 +23,4 @@ endmodule
 //q a file doesnt save (still has asterix) if it does not compile/pass-parse?
 //q how can i start a new text file (verilog file for example, w/o having to use the mouse and go to the pull-down menus?)
 //q: if I make a dut and then want to instantiate it, is there an easy way to just have it appear in code along with explicit port list, with empty connections for me to connect
-//q: how can i turn on/off line-wrap, so code does/n't go off right of page?
\ No newline at end of file
+//q: how can i turn on/off line-wrap, so code does/n't go off right of page?
diff --git a/lesson0001_interface_basic/top_final.sv b/lesson0001_interface_basic/top_final.sv
index f1b6c22..277f7df 100644
--- a/lesson0001_interface_basic/top_final.sv
+++ b/lesson0001_interface_basic/top_final.sv
@@ -2,17 +2,17 @@ module top_final;
 
    integer dut_score;
 
-   score_items_if that_if();   
+   score_items_if that_if();
 
 
    stimulus_w_if stimulus(.s_if(that_if));
 
    dut_w_if      dut(.this_if(that_if), .out_score(dut_score));
 
-   
+
     initial begin
         $monitor($time, " new score is: %0d", dut_score);
-    end    
+    end
 
 
 endmodule // top_w__dut_w_if
diff --git a/lesson0001_interface_basic/top_w__dut_w_if.sv b/lesson0001_interface_basic/top_w__dut_w_if.sv
index 5d2cdbf..2f5565f 100644
--- a/lesson0001_interface_basic/top_w__dut_w_if.sv
+++ b/lesson0001_interface_basic/top_w__dut_w_if.sv
@@ -2,7 +2,7 @@ module top_w__dut_w_if;
 
    integer dut_score;
 
-   score_items_if that_if();   
+   score_items_if that_if();
 
 
    stimulus stimulus(
@@ -13,10 +13,10 @@ module top_w__dut_w_if;
 
    dut_w_if dut(.this_if(that_if), .out_score(dut_score));
 
-   
+
     initial begin
         $monitor($time, " new score is: %0d", dut_score);
-    end    
+    end
 
 
 endmodule // top_w__dut_w_if
diff --git a/lesson0001_interface_basic/top_w_vif.sv b/lesson0001_interface_basic/top_w_vif.sv
index 5efa540..bf2f17c 100644
--- a/lesson0001_interface_basic/top_w_vif.sv
+++ b/lesson0001_interface_basic/top_w_vif.sv
@@ -1,6 +1,6 @@
 class top;
 
-   virtual 
-   
+   virtual
+
 endclass : top
-     
\ No newline at end of file
+
diff --git a/lesson0002_virtual_interface_basic/FINAL/class_stimulus.svh b/lesson0002_virtual_interface_basic/FINAL/class_stimulus.svh
index 617ab4a..93a7eb8 100644
--- a/lesson0002_virtual_interface_basic/FINAL/class_stimulus.svh
+++ b/lesson0002_virtual_interface_basic/FINAL/class_stimulus.svh
@@ -10,20 +10,20 @@ class class_stimulus;
    function new(input int aaa,bbb); //virtual my_if ports);
 //      this.port_vif  = ports;
       my_aaa  = aaa;
-      my_bbb  = bbb;      
+      my_bbb  = bbb;
    endfunction
 
    task run_t(virtual my_if ports);
       this.port_vif  = ports;
       repeat (1) begin
 	 port_vif.some_data  = my_aaa;
-	 #2;	 
+	 #2;
 	 port_vif.some_data  = my_bbb;
-	 #2;	 
+	 #2;
       end
       this.port_vif  = null;
    endtask
 
-   
 
-endclass 
+
+endclass
diff --git a/lesson0002_virtual_interface_basic/FINAL/dut.sv b/lesson0002_virtual_interface_basic/FINAL/dut.sv
index fb75722..777c2c6 100644
--- a/lesson0002_virtual_interface_basic/FINAL/dut.sv
+++ b/lesson0002_virtual_interface_basic/FINAL/dut.sv
@@ -1,6 +1,6 @@
 module dut(my_if mif);
    initial begin
-      $monitor($time, " mif.some_data=%2x ", 
-	       mif.some_data);      
-   end  
+      $monitor($time, " mif.some_data=%2x ",
+	       mif.some_data);
+   end
 endmodule
diff --git a/lesson0002_virtual_interface_basic/FINAL/my_if.sv b/lesson0002_virtual_interface_basic/FINAL/my_if.sv
index 01a9015..df1f5c0 100644
--- a/lesson0002_virtual_interface_basic/FINAL/my_if.sv
+++ b/lesson0002_virtual_interface_basic/FINAL/my_if.sv
@@ -3,4 +3,4 @@ interface my_if();
 endinterface
 
 
-     
\ No newline at end of file
+
diff --git a/lesson0002_virtual_interface_basic/FINAL/tb_top.sv b/lesson0002_virtual_interface_basic/FINAL/tb_top.sv
index d18e4a0..7fe6b9e 100644
--- a/lesson0002_virtual_interface_basic/FINAL/tb_top.sv
+++ b/lesson0002_virtual_interface_basic/FINAL/tb_top.sv
@@ -1,5 +1,5 @@
 module mem_tb();
    my_if my_connection();
    dut my_dut(.mif(my_connection));
-   test my_test(.this_if(my_connection));   
+   test my_test(.this_if(my_connection));
 endmodule
diff --git a/lesson0002_virtual_interface_basic/FINAL/test.sv b/lesson0002_virtual_interface_basic/FINAL/test.sv
index b5cfbf3..fda1018 100644
--- a/lesson0002_virtual_interface_basic/FINAL/test.sv
+++ b/lesson0002_virtual_interface_basic/FINAL/test.sv
@@ -4,10 +4,10 @@ program test(my_if this_if);
       class_stimulus class_stimulus_u2 = new(.aaa(7), .bbb(9)); //this_if);
 
       class_stimulus_u.run_t(this_if);
-      #100;      
+      #100;
       class_stimulus_u2.run_t(this_if);
 
       #122;
-      $finish;   
+      $finish;
    end
-endprogram 
+endprogram
diff --git a/lesson0002_virtual_interface_basic/class_stimulus.svh b/lesson0002_virtual_interface_basic/class_stimulus.svh
index cbea697..68e7f6a 100644
--- a/lesson0002_virtual_interface_basic/class_stimulus.svh
+++ b/lesson0002_virtual_interface_basic/class_stimulus.svh
@@ -11,7 +11,7 @@ class class_stimulus;
    task run_t();
       repeat (3) begin
 	 port_vif.some_data  = $urandom;
-	 #2;	 
+	 #2;
       end
    endtask
-endclass 
+endclass
diff --git a/lesson0002_virtual_interface_basic/dut.sv b/lesson0002_virtual_interface_basic/dut.sv
index fb75722..777c2c6 100644
--- a/lesson0002_virtual_interface_basic/dut.sv
+++ b/lesson0002_virtual_interface_basic/dut.sv
@@ -1,6 +1,6 @@
 module dut(my_if mif);
    initial begin
-      $monitor($time, " mif.some_data=%2x ", 
-	       mif.some_data);      
-   end  
+      $monitor($time, " mif.some_data=%2x ",
+	       mif.some_data);
+   end
 endmodule
diff --git a/lesson0002_virtual_interface_basic/my_if.sv b/lesson0002_virtual_interface_basic/my_if.sv
index 01a9015..df1f5c0 100644
--- a/lesson0002_virtual_interface_basic/my_if.sv
+++ b/lesson0002_virtual_interface_basic/my_if.sv
@@ -3,4 +3,4 @@ interface my_if();
 endinterface
 
 
-     
\ No newline at end of file
+
diff --git a/lesson0002_virtual_interface_basic/tb_top.sv b/lesson0002_virtual_interface_basic/tb_top.sv
index d18e4a0..7fe6b9e 100644
--- a/lesson0002_virtual_interface_basic/tb_top.sv
+++ b/lesson0002_virtual_interface_basic/tb_top.sv
@@ -1,5 +1,5 @@
 module mem_tb();
    my_if my_connection();
    dut my_dut(.mif(my_connection));
-   test my_test(.this_if(my_connection));   
+   test my_test(.this_if(my_connection));
 endmodule
diff --git a/lesson0002_virtual_interface_basic/test.sv b/lesson0002_virtual_interface_basic/test.sv
index 4a276ed..9a61b5f 100644
--- a/lesson0002_virtual_interface_basic/test.sv
+++ b/lesson0002_virtual_interface_basic/test.sv
@@ -5,6 +5,6 @@ program test(my_if this_if);
 	 class_stimulus_u.run_t();
       join_none
       #122;
-      $finish;   
+      $finish;
    end
-endprogram 
+endprogram
diff --git a/lesson0003_virtual_interface_basic/FINAL/class_stimulus.svh b/lesson0003_virtual_interface_basic/FINAL/class_stimulus.svh
index 617ab4a..93a7eb8 100644
--- a/lesson0003_virtual_interface_basic/FINAL/class_stimulus.svh
+++ b/lesson0003_virtual_interface_basic/FINAL/class_stimulus.svh
@@ -10,20 +10,20 @@ class class_stimulus;
    function new(input int aaa,bbb); //virtual my_if ports);
 //      this.port_vif  = ports;
       my_aaa  = aaa;
-      my_bbb  = bbb;      
+      my_bbb  = bbb;
    endfunction
 
    task run_t(virtual my_if ports);
       this.port_vif  = ports;
       repeat (1) begin
 	 port_vif.some_data  = my_aaa;
-	 #2;	 
+	 #2;
 	 port_vif.some_data  = my_bbb;
-	 #2;	 
+	 #2;
       end
       this.port_vif  = null;
    endtask
 
-   
 
-endclass 
+
+endclass
diff --git a/lesson0003_virtual_interface_basic/FINAL/dut.sv b/lesson0003_virtual_interface_basic/FINAL/dut.sv
index fb75722..777c2c6 100644
--- a/lesson0003_virtual_interface_basic/FINAL/dut.sv
+++ b/lesson0003_virtual_interface_basic/FINAL/dut.sv
@@ -1,6 +1,6 @@
 module dut(my_if mif);
    initial begin
-      $monitor($time, " mif.some_data=%2x ", 
-	       mif.some_data);      
-   end  
+      $monitor($time, " mif.some_data=%2x ",
+	       mif.some_data);
+   end
 endmodule
diff --git a/lesson0003_virtual_interface_basic/FINAL/my_if.sv b/lesson0003_virtual_interface_basic/FINAL/my_if.sv
index 01a9015..df1f5c0 100644
--- a/lesson0003_virtual_interface_basic/FINAL/my_if.sv
+++ b/lesson0003_virtual_interface_basic/FINAL/my_if.sv
@@ -3,4 +3,4 @@ interface my_if();
 endinterface
 
 
-     
\ No newline at end of file
+
diff --git a/lesson0003_virtual_interface_basic/FINAL/tb_top.sv b/lesson0003_virtual_interface_basic/FINAL/tb_top.sv
index d18e4a0..7fe6b9e 100644
--- a/lesson0003_virtual_interface_basic/FINAL/tb_top.sv
+++ b/lesson0003_virtual_interface_basic/FINAL/tb_top.sv
@@ -1,5 +1,5 @@
 module mem_tb();
    my_if my_connection();
    dut my_dut(.mif(my_connection));
-   test my_test(.this_if(my_connection));   
+   test my_test(.this_if(my_connection));
 endmodule
diff --git a/lesson0003_virtual_interface_basic/FINAL/test.sv b/lesson0003_virtual_interface_basic/FINAL/test.sv
index b5cfbf3..fda1018 100644
--- a/lesson0003_virtual_interface_basic/FINAL/test.sv
+++ b/lesson0003_virtual_interface_basic/FINAL/test.sv
@@ -4,10 +4,10 @@ program test(my_if this_if);
       class_stimulus class_stimulus_u2 = new(.aaa(7), .bbb(9)); //this_if);
 
       class_stimulus_u.run_t(this_if);
-      #100;      
+      #100;
       class_stimulus_u2.run_t(this_if);
 
       #122;
-      $finish;   
+      $finish;
    end
-endprogram 
+endprogram
diff --git a/lesson0003_virtual_interface_basic/class_stimulus.svh b/lesson0003_virtual_interface_basic/class_stimulus.svh
index 49317d0..5ba4943 100644
--- a/lesson0003_virtual_interface_basic/class_stimulus.svh
+++ b/lesson0003_virtual_interface_basic/class_stimulus.svh
@@ -2,20 +2,20 @@ class class_stimulus;
 
    virtual my_if port_vif;
    int 	   my_aaa, my_bbb;
-   
+
    function new(input int aaa,bbb);
       my_aaa 	     = aaa;
-      my_bbb 	     = bbb;      
+      my_bbb 	     = bbb;
    endfunction
 
    task run_t(virtual my_if ports);
       this.port_vif  = ports;
       repeat (1) begin
 	 port_vif.some_data  = my_aaa;
-	 #2;	 
+	 #2;
 	 port_vif.some_data  = my_bbb;
-	 #2;	 
+	 #2;
       end
       this.port_vif  = null;
    endtask
-endclass 
+endclass
diff --git a/lesson0003_virtual_interface_basic/dut.sv b/lesson0003_virtual_interface_basic/dut.sv
index e2540b9..1421c7f 100644
--- a/lesson0003_virtual_interface_basic/dut.sv
+++ b/lesson0003_virtual_interface_basic/dut.sv
@@ -1,6 +1,6 @@
 module dut(my_if mif);
    initial begin
-      $monitor($time," mif.some_data=%2x", 
-	       mif.some_data);      
-   end  
+      $monitor($time," mif.some_data=%2x",
+	       mif.some_data);
+   end
 endmodule
diff --git a/lesson0003_virtual_interface_basic/my_if.sv b/lesson0003_virtual_interface_basic/my_if.sv
index 01a9015..df1f5c0 100644
--- a/lesson0003_virtual_interface_basic/my_if.sv
+++ b/lesson0003_virtual_interface_basic/my_if.sv
@@ -3,4 +3,4 @@ interface my_if();
 endinterface
 
 
-     
\ No newline at end of file
+
diff --git a/lesson0003_virtual_interface_basic/tb_top.sv b/lesson0003_virtual_interface_basic/tb_top.sv
index d18e4a0..7fe6b9e 100644
--- a/lesson0003_virtual_interface_basic/tb_top.sv
+++ b/lesson0003_virtual_interface_basic/tb_top.sv
@@ -1,5 +1,5 @@
 module mem_tb();
    my_if my_connection();
    dut my_dut(.mif(my_connection));
-   test my_test(.this_if(my_connection));   
+   test my_test(.this_if(my_connection));
 endmodule
diff --git a/lesson0003_virtual_interface_basic/test.sv b/lesson0003_virtual_interface_basic/test.sv
index be8e2b6..da1af82 100644
--- a/lesson0003_virtual_interface_basic/test.sv
+++ b/lesson0003_virtual_interface_basic/test.sv
@@ -1,12 +1,12 @@
 program test(my_if this_if);
    initial begin
-      class_stimulus class_stimulus_u  = new(.aaa(4), .bbb(7)); 
-      class_stimulus class_stimulus_u2 = new(.aaa(3), .bbb(9));      
+      class_stimulus class_stimulus_u  = new(.aaa(4), .bbb(7));
+      class_stimulus class_stimulus_u2 = new(.aaa(3), .bbb(9));
 
       class_stimulus_u.run_t(this_if);
-      #33;      
+      #33;
       class_stimulus_u2.run_t(this_if);
       #122;
-      $finish;   
+      $finish;
    end
-endprogram 
+endprogram
diff --git a/lesson0004_queue/my_queue.sv b/lesson0004_queue/my_queue.sv
index 18efa82..46e95a3 100644
--- a/lesson0004_queue/my_queue.sv
+++ b/lesson0004_queue/my_queue.sv
@@ -1,7 +1,7 @@
 module my_queue;
-   int my_int;   
+   int my_int;
    int q_queue[$];
-   
+
    initial begin
       q_queue  = {8,6};
       show_q();
@@ -12,15 +12,15 @@ module my_queue;
       q_queue.push_back(5);
       my_int  = q_queue.pop_front();
       show_q();
-      
+
    end
 
    function void show_q();
       for (int iii=0; iii<q_queue.size(); iii++) begin
 	 $write("q_queue[%0d]=%0d, ",iii, q_queue[iii]);
       end // for (int iii=0; iii<q_queue.size(); iii++)
-      $display(" (my_int=%0d)",my_int);      
+      $display(" (my_int=%0d)",my_int);
    endfunction
-   
+
 endmodule // my_queue
 
diff --git a/lesson0004_queue/use_queue.sv b/lesson0004_queue/use_queue.sv
index 285ae84..1d90c53 100644
--- a/lesson0004_queue/use_queue.sv
+++ b/lesson0004_queue/use_queue.sv
@@ -1,22 +1,22 @@
 module use_queue;
-   int my_int;   
+   int my_int;
    int q_queue[$];
 
    initial begin
-      q_queue  = {8,6};  
+      q_queue  = {8,6};
       show_q();
       q_queue.push_back(1);
       show_q();
       q_queue.push_back(4);
-      show_q();      
-      my_int  = q_queue.pop_front();      
+      show_q();
+      my_int  = q_queue.pop_front();
       show_q();
    end
 
-   function void show_q();   
-      $display("***** Size of q_queue = %0d. **** *",q_queue.size());    
+   function void show_q();
+      $display("***** Size of q_queue = %0d. **** *",q_queue.size());
       for (int iii=0;iii<q_queue.size();iii++) begin
-	 $write("q_queue[%0d]=%0d, ",iii, q_queue[iii]);	 
+	 $write("q_queue[%0d]=%0d, ",iii, q_queue[iii]);
       end
       $display("    (my_int=%0d)", my_int);
    endfunction
diff --git a/lesson0004_typedef_and_enum/class_drink.svh b/lesson0004_typedef_and_enum/class_drink.svh
index 60242dc..2f6349a 100644
--- a/lesson0004_typedef_and_enum/class_drink.svh
+++ b/lesson0004_typedef_and_enum/class_drink.svh
@@ -6,11 +6,11 @@ module tb;
 
    initial begin
       some_cost  = -1;
-      #1;      
+      #1;
       some_cost  = {100{1'b1}};
-      #1;      
+      #1;
       some_cost  = 12;
-      #1;      
+      #1;
       some_cost  = -4;
    end
 
@@ -31,4 +31,4 @@ class class_drink();
    endfunction
 
 endclass
-*/
\ No newline at end of file
+*/
diff --git a/lesson0005_integer_int_real_and_friends/class_drink.svh b/lesson0005_integer_int_real_and_friends/class_drink.svh
index 0e7d3ff..d362a98 100644
--- a/lesson0005_integer_int_real_and_friends/class_drink.svh
+++ b/lesson0005_integer_int_real_and_friends/class_drink.svh
@@ -6,8 +6,8 @@
 
 
 module tb;
-   integer             my_integer;   
-   
+   integer             my_integer;
+
    shortint unsigned   my_shortint;
    int      unsigned   my_int;
    longint  unsigned   my_longint;
@@ -23,13 +23,13 @@ module tb;
       my_integer =  2; my_shortint  =  2;  my_int =  2;  my_longint =  2;
       #1;
       my_integer = (2**16)-1; my_shortint  = (2**16)-1;  my_int =  (2**16)-1;  my_longint =  (2**16)-1;
-      #1;      
+      #1;
       my_integer = (2**16)+1; my_shortint  = (2**16)+1;  my_int =  (2**16)+1;  my_longint =  (2**16)+1;
       #1;
    end
 
    initial begin
-      $monitor("%0d:\t>my_shortint=(hex:%16x)(%10d) / my_int=(hex:%16x)(%10d) / my_longint=(hex:%16x)(%10d) ",my_integer, my_shortint,my_shortint,my_int,my_int,my_longint,my_longint);      
+      $monitor("%0d:\t>my_shortint=(hex:%16x)(%10d) / my_int=(hex:%16x)(%10d) / my_longint=(hex:%16x)(%10d) ",my_integer, my_shortint,my_shortint,my_int,my_int,my_longint,my_longint);
    end
 
 endmodule
diff --git a/lesson0005_queue+1/queue1.sv b/lesson0005_queue+1/queue1.sv
index 0bcc7b5..12c6b30 100644
--- a/lesson0005_queue+1/queue1.sv
+++ b/lesson0005_queue+1/queue1.sv
@@ -1,30 +1,30 @@
 //delete, insert, shuffle, sort
 module queue1;
-   int my_int;   
+   int my_int;
    int q_queue[$];
-   
+
    initial begin
       q_queue  = {1,2,3,4,5,6,7};
       show_q();
-      q_queue  = {q_queue[0:2],333, q_queue[3:$]};      
-      show_q();      
-/*    q_queue.sort();      
+      q_queue  = {q_queue[0:2],333, q_queue[3:$]};
+      show_q();
+/*    q_queue.sort();
       show_q();
       q_queue.push_back(1);
       show_q();
-      q_queue = {};      
+      q_queue = {};
       q_queue.push_back(3);
-      q_queue = q_queue.delete;      
+      q_queue = q_queue.delete;
       q_queue.push_back(9);
       show_q();
-  */    
+  */
    end
 
    function void show_q();
       for (int iii=0; iii<q_queue.size(); iii++) begin
 	 $write("q_queue[%0d]=%0d, ",iii, q_queue[iii]);
       end // for (int iii=0; iii<q_queue.size(); iii++)
-      $display(" (my_int=%0d)",my_int);      
+      $display(" (my_int=%0d)",my_int);
    endfunction
 endmodule // my_queue
 
diff --git a/lesson0006_queue+2/queue2.sv b/lesson0006_queue+2/queue2.sv
index f0d7447..5866c3c 100644
--- a/lesson0006_queue+2/queue2.sv
+++ b/lesson0006_queue+2/queue2.sv
@@ -1,4 +1,4 @@
-//bounded, 
+//bounded,
 module queue2;
    string my_string;
    string q_queue[$:3];
@@ -6,22 +6,22 @@ module queue2;
    initial begin
       q_queue  = {"A","L","O","E"};
       show_q();
-      q_queue.push_front("G");        
+      q_queue.push_front("G");
       show_q();                      //{"G","A","L","O","E"}
       my_string  = q_queue.pop_front();
 
       show_q();                      //{"A","L","O","E"}
       q_queue.push_front("H");
       show_q();                      //{"H","A","L","O","E"}
-      
-      $display("left   =%0d",$left(q_queue));  
-      $display("right  =%0d",$right(q_queue));     
-      $display("low    =%0d",$low(q_queue));      
-      $display("high   =%0d",$high(q_queue));      
-      $display("size                =%0d",$size(q_queue));      
-      $display("dimensions          =%0d",$dimensions(q_queue));      
-      $display("unpacked_dimensions =%0d",$unpacked_dimensions(q_queue));      
- 
+
+      $display("left   =%0d",$left(q_queue));
+      $display("right  =%0d",$right(q_queue));
+      $display("low    =%0d",$low(q_queue));
+      $display("high   =%0d",$high(q_queue));
+      $display("size                =%0d",$size(q_queue));
+      $display("dimensions          =%0d",$dimensions(q_queue));
+      $display("unpacked_dimensions =%0d",$unpacked_dimensions(q_queue));
+
    end
 
    function void show_q();
diff --git a/lesson0007_associate_array/use_associate_array.sv b/lesson0007_associate_array/use_associate_array.sv
index 3a8a802..4f51360 100644
--- a/lesson0007_associate_array/use_associate_array.sv
+++ b/lesson0007_associate_array/use_associate_array.sv
@@ -6,16 +6,16 @@ module use_assiciate_array;
       aa_assocarray  = '{0:"zero",1:"one",2:"two",3:"three",4:"four"};
       aa_show;
       aa_assocarray.shuffle();
-      aa_show;      
+      aa_show;
    end
 
 
    function void aa_show;
-      foreach (aa_assocarray[iii]) begin 
-	 $display(" iii=%0d  aa_assocarray[iii]=%0s", iii, aa_assocarray[iii]);	 
+      foreach (aa_assocarray[iii]) begin
+	 $display(" iii=%0d  aa_assocarray[iii]=%0s", iii, aa_assocarray[iii]);
       end
       $display("");
    endfunction
-   
 
-endmodule
\ No newline at end of file
+
+endmodule
diff --git a/lesson0007_queue+3/queue3.sv b/lesson0007_queue+3/queue3.sv
index 4c84b2f..a316c78 100644
--- a/lesson0007_queue+3/queue3.sv
+++ b/lesson0007_queue+3/queue3.sv
@@ -5,11 +5,11 @@ module queue3;
    initial begin
       qqq  = {-2,1,4,0,4,-8,9};
       show_q();
-      results  = qqq.min(x) with (x<-1);      
+      results  = qqq.min(x) with (x<-1);
       show_q2();
-      results  = qqq.max(x) with (x<7);      
+      results  = qqq.max(x) with (x<7);
       show_q2();
-      results = qqq.unique(x)  with (x>-1);      
+      results = qqq.unique(x)  with (x>-1);
       show_q2();
    end
 
@@ -20,7 +20,7 @@ module queue3;
       $display("");  $write("     ");
       for (int iii=0; iii<qqq.size(); iii++)
 	 $write("%2d  ",       qqq[iii]);
-      $display("");      
+      $display("");
    endfunction
    function void show_q2();
       $write("res=");
@@ -32,4 +32,4 @@ module queue3;
       $display("");
    endfunction
 
-endmodule 
+endmodule
diff --git a/lesson0008_assoc_array/aa.sv b/lesson0008_assoc_array/aa.sv
index cc58177..990dd8e 100644
--- a/lesson0008_assoc_array/aa.sv
+++ b/lesson0008_assoc_array/aa.sv
@@ -5,18 +5,18 @@ module aa;
    initial begin
       aa  = '{2:5, 6:55, 7:3, 16'hFFFE:-6};
       show();
-      aa.delete(6);      
+      aa.delete(6);
       show();
-      aa[8]  =33;      
+      aa[8]  =33;
       show();
    end
 
-   
+
    function void show();
       foreach (aa[i]) begin
-	 $write("aa[%4h]=%0d, ",i,aa[i]);	 
+	 $write("aa[%4h]=%0d, ",i,aa[i]);
       end
-      $display("");   
-      $display(" aa size =%0d",aa.size());      
-   endfunction   
+      $display("");
+      $display(" aa size =%0d",aa.size());
+   endfunction
 endmodule // aa
diff --git a/lesson0008_assoc_array/bb.sv b/lesson0008_assoc_array/bb.sv
index ea0af27..26c377f 100644
--- a/lesson0008_assoc_array/bb.sv
+++ b/lesson0008_assoc_array/bb.sv
@@ -9,9 +9,9 @@ module aa;
 
    function void show();
       foreach (aa[i]) begin
-	 $write("aa[%4h]=%0d, ",i,aa[i]);	 
+	 $write("aa[%4h]=%0d, ",i,aa[i]);
       end
-      $display("");      
+      $display("");
    endfunction
 
  endmodule // aa
diff --git a/lesson0009_assoc_array+1/aa.sv b/lesson0009_assoc_array+1/aa.sv
index 5f941d7..13d1d49 100644
--- a/lesson0009_assoc_array+1/aa.sv
+++ b/lesson0009_assoc_array+1/aa.sv
@@ -1,8 +1,8 @@
 module aa;
 
    integer aa [bit [15:0]];
-   bit [15:0] ii,iii;   
-   
+   bit [15:0] ii,iii;
+
    initial begin
       aa  = '{2:5, 6:55, 7:3, 16'hFFFE:-6, default:0};
       show();
@@ -17,17 +17,17 @@ module aa;
 	 void'(aa.first(iii));
 	 void'(aa.next(iii));
 	 $display(" aa[%0d]=%0d, aa[%0d]=%0d", ii, aa[ii], iii, aa[iii]);
-	 aa[ii]  = aa[iii];	 
-	 show();	 
+	 aa[ii]  = aa[iii];
+	 show();
       end
    end
 
-   
+
    function void show();
       foreach (aa[i]) begin
-	 $write("aa[%4h]=%0d, ",i,aa[i]);	 
+	 $write("aa[%4h]=%0d, ",i,aa[i]);
       end
-      $display("");   
-      $display(" aa size =%0d",aa.size());      
-   endfunction   
+      $display("");
+      $display(" aa size =%0d",aa.size());
+   endfunction
 endmodule // aa
diff --git a/lesson0009_assoc_array+1/bb.sv b/lesson0009_assoc_array+1/bb.sv
index 83f9d5c..9e519df 100644
--- a/lesson0009_assoc_array+1/bb.sv
+++ b/lesson0009_assoc_array+1/bb.sv
@@ -5,20 +5,20 @@ module aa;
    initial begin
       aa  = '{2:5, 6:55, 7:3, 16'hFFFE:-6};
       show();
-      aa.delete(6);      
+      aa.delete(6);
       show();
-      aa[8]  =33;      
+      aa[8]  =33;
       show();
-      
+
       if (aa.exists(6)) aa[6]  =aa[6]+10;
    end
 
-   
+
    function void show();
       foreach (aa[i]) begin
-	 $write("aa[%4h]=%0d, ",i,aa[i]);	 
+	 $write("aa[%4h]=%0d, ",i,aa[i]);
       end
-      $display("");   
-      $display(" aa size =%0d",aa.size());      
-   endfunction   
+      $display("");
+      $display(" aa size =%0d",aa.size());
+   endfunction
 endmodule // aa
diff --git a/lesson000X_mluvm_svsc/uvm_examples/ex_mtm_layering/demo.ecom b/lesson000X_mluvm_svsc/uvm_examples/ex_mtm_layering/demo.ecom
index e9b04db..95d89d3 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/ex_mtm_layering/demo.ecom
+++ b/lesson000X_mluvm_svsc/uvm_examples/ex_mtm_layering/demo.ecom
@@ -3,4 +3,4 @@ load ex_mtm_layering/e/ex_mtm_layering_top
 load ex_mtm_layering/examples/ex_mtm_layering_test.e
 trace sequence
 set message MEDIUM
-test
\ No newline at end of file
+test
diff --git a/lesson000X_mluvm_svsc/uvm_examples/ex_mtm_layering/demo.sh b/lesson000X_mluvm_svsc/uvm_examples/ex_mtm_layering/demo.sh
index f468974..ad411d5 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/ex_mtm_layering/demo.sh
+++ b/lesson000X_mluvm_svsc/uvm_examples/ex_mtm_layering/demo.sh
@@ -32,10 +32,10 @@ while [ $# -gt 0 ]; do
 	;;
       -run)
          quit_cmd="-c @$2"
-	
+
          shift
     esac
-    shift   
+    shift
 done
 #================================================================
 if [ $run_mode = batch ]; then
diff --git a/lesson000X_mluvm_svsc/uvm_examples/ex_mtm_layering/e/ex_mtm_layering_base.e b/lesson000X_mluvm_svsc/uvm_examples/ex_mtm_layering/e/ex_mtm_layering_base.e
index 9702c0d..1f39ff9 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/ex_mtm_layering/e/ex_mtm_layering_base.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/ex_mtm_layering/e/ex_mtm_layering_base.e
@@ -1,17 +1,17 @@
-/*----------------------------------------------------------    
+/*----------------------------------------------------------
 File name   : ex_mtm_layering_base.e
-Title       : Defines the base types for layering 
+Title       : Defines the base types for layering
 Project     : many to many layering example
 Created     : 2007
-Description : Defines the method port for layering and the basic 
+Description : Defines the method port for layering and the basic
             : layering struct.
-Notes       : This is one of four layering examples: One to one, 
+Notes       : This is one of four layering examples: One to one,
             : One to many, Many to one and Many to many
-----------------------------------------------------------    
-Copyright (c) 2007 Cadence Design Systems, Inc. 
+----------------------------------------------------------
+Copyright (c) 2007 Cadence Design Systems, Inc.
 All rights reserved worldwide.
-Please refer to the terms and conditions in $IPCM_HOME 
-----------------------------------------------------------*/ 
+Please refer to the terms and conditions in $IPCM_HOME
+----------------------------------------------------------*/
 
 
 
@@ -20,11 +20,11 @@ o Layering interface declaration
 <'
 struct layering_data_struct_s {
     // can also be list of bit for a more general data representation
-    data: list of byte;             
+    data: list of byte;
 
-    // can deliver structs across layers for user defined application 
+    // can deliver structs across layers for user defined application
     // specific usage
-    upper_layer_struct: any_struct; 
+    upper_layer_struct: any_struct;
 
 };
 
diff --git a/lesson000X_mluvm_svsc/uvm_examples/ex_mtm_layering/e/ex_mtm_layering_ll_pkt_env.e b/lesson000X_mluvm_svsc/uvm_examples/ex_mtm_layering/e/ex_mtm_layering_ll_pkt_env.e
index 672d855..a0341ec 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/ex_mtm_layering/e/ex_mtm_layering_ll_pkt_env.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/ex_mtm_layering/e/ex_mtm_layering_ll_pkt_env.e
@@ -1,24 +1,24 @@
 
-/*----------------------------------------------------------    
+/*----------------------------------------------------------
 File name   : ex_mtm_layering_ll_pkt_env.e
-Title       : Defines the lower and mediating layer pkt env 
+Title       : Defines the lower and mediating layer pkt env
 Project     : many to many layering example
 Created     : 2007
-Description : Defines the ll pkt env, agent and its sequence, item and Driver. 
-            : in the same env it also defines the ml pkt its sequence and the 
+Description : Defines the ll pkt env, agent and its sequence, item and Driver.
+            : in the same env it also defines the ml pkt its sequence and the
             : interface for the upper layer. Defines the BFM.
-Notes       : This is one of four layering examples: One to one, 
+Notes       : This is one of four layering examples: One to one,
             : One to many, Many to one and Many to many
-----------------------------------------------------------    
-Copyright (c) 2007 Cadence Design Systems, Inc. 
+----------------------------------------------------------
+Copyright (c) 2007 Cadence Design Systems, Inc.
 All rights reserved worldwide.
-Please refer to the terms and conditions in $IPCM_HOME 
-----------------------------------------------------------*/ 
+Please refer to the terms and conditions in $IPCM_HOME
+----------------------------------------------------------*/
+
 
-    
 o The ml pkt struct:
-the ml pkt is a mediating layer struct. it gets payload from various upper 
-layer agents. these layers might supply it with lower layer constructs 
+the ml pkt is a mediating layer struct. it gets payload from various upper
+layer agents. these layers might supply it with lower layer constructs
 (such as ll header) or upper layer constructs (such as upper layer packets)
 
 <'
@@ -30,13 +30,13 @@ struct ex_mtm_layering_ml_pkt_s like any_sequence_item {
 '>
 
 o The ll pkt struct:
-this is the combination of headers and upper layer packets that eventually get 
-sent to the BFM. 
+this is the combination of headers and upper layer packets that eventually get
+sent to the BFM.
 <'
 
 struct ex_mtm_layering_ll_pkt_s like any_sequence_item {
     payload: 	list of byte;
-    
+
     // How to print it in the "trace sequence"/"show sequence" output
     nice_string(): string is also {
         return append(result);
@@ -51,22 +51,22 @@ o The BFM:
 
 
 unit ex_mtm_layering_ll_pkt_bfm_u like uvm_bfm {
-    
+
     // public interface
     d_enable: out simple_port of bit is instance; // ports to the DUT
     d_bus: out simple_port of byte is instance;   // ports to the DUT
-    
+
     event a_clock is cycle @sys.any;  	-- The LL_PKT main clock
     event ll_pkt_started;		-- start of transfer to DUT
     event ll_pkt_ended;			-- end of transfer to DUT
 
     driver: ex_mtm_layering_ll_pkt_driver_u;
-    
+
     on a_clock {
         emit driver.clock;
     };
-    
-    
+
+
     -- A method which sends the ll pkt into the DUT
     transfer_ll_pkt_to_dut(ll_pkt: ex_mtm_layering_ll_pkt_s) @a_clock is {
         emit ll_pkt_started;
@@ -81,9 +81,9 @@ unit ex_mtm_layering_ll_pkt_bfm_u like uvm_bfm {
         wait cycle;
         emit ll_pkt_ended;
         messagef(MEDIUM,"Finished sending ll_pkt data\n");
-        
+
     };
-    
+
     pull_send_loop() @a_clock is {
         while TRUE {
             var ll_pkt := driver.get_next_item();
@@ -91,12 +91,12 @@ unit ex_mtm_layering_ll_pkt_bfm_u like uvm_bfm {
             emit driver.item_done;
         };
     };
-    
+
     run() is also {
         start pull_send_loop();
     };
-    
-    
+
+
 };
 '>
 
@@ -106,7 +106,7 @@ o Defining ml_pkt_sequence and hooking it up:
 <'
 
 -- Define ml_pkt_sequence, ml_pkt_sequence_kind and ml_pkt_driver
-sequence ex_mtm_layering_ml_pkt_sequence using item=ex_mtm_layering_ml_pkt_s, 
+sequence ex_mtm_layering_ml_pkt_sequence using item=ex_mtm_layering_ml_pkt_s,
     created_driver=ex_mtm_layering_ml_pkt_driver_u;
 
 -- Extend the base type with essential fields
@@ -115,14 +115,14 @@ extend ex_mtm_layering_ml_pkt_sequence {
 
     // method port for upper layer. enables connection to any apper layer that
     // supports the method port format
-    !get_item_layer_transfer: 
+    !get_item_layer_transfer:
         out method_port of item_layer_transfer;
 
-    // this method waits until an item is received from the method port. 
+    // this method waits until an item is received from the method port.
     // supports non blocking implementation in the upper layer
-    get_item_from_upper_layer(stream_id : uint,remaining_bytes: uint): 
-        layering_data_struct_s @driver.clock is {  
-        
+    get_item_from_upper_layer(stream_id : uint,remaining_bytes: uint):
+        layering_data_struct_s @driver.clock is {
+
         while result == NULL {
             result = get_item_layer_transfer$(stream_id,remaining_bytes);
             if result == NULL then {
@@ -132,7 +132,7 @@ extend ex_mtm_layering_ml_pkt_sequence {
                         "ML sequence got an item from the upper layer");
             };
         };
-    };  
+    };
 };
 
 '>
@@ -142,7 +142,7 @@ o Defining ll_pkt_sequence and hooking it up:
 <'
 
 // Define ll_pkt_sequence, ll_pkt_sequence_kind and ll_pkt_driver
-sequence ex_mtm_layering_ll_pkt_sequence using item=ex_mtm_layering_ll_pkt_s, 
+sequence ex_mtm_layering_ll_pkt_sequence using item=ex_mtm_layering_ll_pkt_s,
     created_driver=ex_mtm_layering_ll_pkt_driver_u;
 
 // Extend the base type with essential fields
@@ -152,20 +152,20 @@ extend ex_mtm_layering_ll_pkt_sequence {
 
 extend ex_mtm_layering_ll_pkt_driver_u {
     // these two parameters use as an inter sequence status holders.
-    // both the ll seq and ml seq has visibility to them, and so, the ml seq 
+    // both the ll seq and ml seq has visibility to them, and so, the ml seq
     // can supply the right amount of data to the ll seq
 
     !remaining_bytes: uint;
     !tmp_payload: list of byte;
 };
 
-// An interface method to upper layer 
-// the ml driver gets as many method ports as the different kinds of upper 
-// layer agents, also it contains a pointer to ll driver to be able to watch 
+// An interface method to upper layer
+// the ml driver gets as many method ports as the different kinds of upper
+// layer agents, also it contains a pointer to ll driver to be able to watch
 // its status.
- 
+
 extend ex_mtm_layering_ml_pkt_driver_u {
-    get_item_layer_transfers: list of  
+    get_item_layer_transfers: list of
         out method_port of item_layer_transfer is instance;
 
     ll_driver: ex_mtm_layering_ll_pkt_driver_u;
@@ -181,7 +181,7 @@ o The enclosing LL_PKT agent:
 <'
 
 unit ex_mtm_layering_ll_pkt_agent_u like uvm_agent {
-    
+
     bfm: ex_mtm_layering_ll_pkt_bfm_u is instance;
     -- One can also instantiate here an LL_PKT monitor unit, etc..
     ll_driver: ex_mtm_layering_ll_pkt_driver_u is instance;
@@ -202,28 +202,28 @@ o The enclosing LL_PKT environment:
 <'
 
 unit ex_mtm_layering_ll_pkt_env_u like uvm_env {
-    
+
     logger    : message_logger is instance;
     file_logger      : message_logger  is instance;
-    
+
     keep soft file_logger.to_screen == FALSE;
     keep soft file_logger.to_file == "ll_pkt";
     -- Instantiate a driver in the LL_PKT env
-    
+
     evc_name : string;
     keep soft evc_name == "LL_PKT ";
-    
+
     short_name(): string is only {
         return append(evc_name);
     };
-    
+
     ll_pkt_color : vt_style;
     keep ll_pkt_color  == DARK_PURPLE;
-    
+
     short_name_style(): vt_style is only {return ll_pkt_color;};
-    
-    agent: ex_mtm_layering_ll_pkt_agent_u is instance;    
-    
+
+    agent: ex_mtm_layering_ll_pkt_agent_u is instance;
+
 };
 
 '>
diff --git a/lesson000X_mluvm_svsc/uvm_examples/ex_mtm_layering/e/ex_mtm_layering_ll_pkt_seq_lib.e b/lesson000X_mluvm_svsc/uvm_examples/ex_mtm_layering/e/ex_mtm_layering_ll_pkt_seq_lib.e
index 13d3da9..3d23dfb 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/ex_mtm_layering/e/ex_mtm_layering_ll_pkt_seq_lib.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/ex_mtm_layering/e/ex_mtm_layering_ll_pkt_seq_lib.e
@@ -1,54 +1,54 @@
 
-/*----------------------------------------------------------    
+/*----------------------------------------------------------
 File name   : ex_mtm_layering_ll_pkt_seq_lib.e
-Title       : packet sequence library 
+Title       : packet sequence library
 Project     : many to many layering example
 Created     : 2007
 Description : Defines reusable ll pkt sequences for usage in tests
-Notes       : This is one of four layering examples: One to one, 
+Notes       : This is one of four layering examples: One to one,
             : One to many, Many to one and Many to many
-----------------------------------------------------------    
-Copyright (c) 2007 Cadence Design Systems, Inc. 
+----------------------------------------------------------
+Copyright (c) 2007 Cadence Design Systems, Inc.
 All rights reserved worldwide.
-Please refer to the terms and conditions in $IPCM_HOME 
-----------------------------------------------------------*/ 
+Please refer to the terms and conditions in $IPCM_HOME
+----------------------------------------------------------*/
 
 
 <'
 define LL_PKT_LEN 3000;
 
-// typically this is the only sequence that is used in the ll env. sometimes 
-// there are special ll pkt transactios and in these cases they must be 
+// typically this is the only sequence that is used in the ll env. sometimes
+// there are special ll pkt transactios and in these cases they must be
 // synchronized with the regular flow
 extend ex_mtm_layering_ll_pkt_sequence_kind: [LAYERED];
 
 extend LAYERED ex_mtm_layering_ll_pkt_sequence {
-    
-    ml_driver: ex_mtm_layering_ml_pkt_driver_u; 
+
+    ml_driver: ex_mtm_layering_ml_pkt_driver_u;
     // the interface to receive processed
     // ul objects (packets or headers)
 
     ll_pkt_length: uint;
     keep soft ll_pkt_length == LL_PKT_LEN;
-    
+
     body() @driver.clock is only{
         var timeout_counter: uint;
         var continue_work: bool;
-        continue_work = TRUE; 
+        continue_work = TRUE;
         all of {
             {
-                // this branch covers the case when the lower layer item 
-                // is ready because of upper layer item (either because the 
+                // this branch covers the case when the lower layer item
+                // is ready because of upper layer item (either because the
                 // size limit is reached or the upper layer signals that the
                 // item is ready)
 
                 while continue_work { // can be turned off from outside
                     var layering_struct: ex_mtm_layering_ml_pkt_s;
-                    driver.remaining_bytes = 
+                    driver.remaining_bytes =
                         ll_pkt_length - driver.tmp_payload.size();
                     layering_struct = ml_driver.get_next_item();
 
-                    // payload 0 means that the upper layer signals that the 
+                    // payload 0 means that the upper layer signals that the
                     // item can be sent to the BFM.
                     if layering_struct.payload.size() == 0 then {
                         driver.tmp_payload.resize(ll_pkt_length,TRUE,0,TRUE);
@@ -58,27 +58,27 @@ extend LAYERED ex_mtm_layering_ll_pkt_sequence {
                         driver.tmp_payload.clear();
                         timeout_counter = 0;
                     } else {
-                        // the new upper layer object is added to the 
+                        // the new upper layer object is added to the
                         // lower layer data
                         driver.tmp_payload.add(layering_struct.payload);
 
-                        // if the size limit is reached, the item is sent 
+                        // if the size limit is reached, the item is sent
                         // to the BFM
                         if driver.tmp_payload.size() == ll_pkt_length {
                             do ll_pkt keeping {
                                 .payload == driver.tmp_payload;
                             };
-                            driver.tmp_payload.clear();                            
-                            timeout_counter = 0;                       
+                            driver.tmp_payload.clear();
+                            timeout_counter = 0;
                         };
                     };
                     emit ml_driver.item_done;
                 };
                 {
-                    // this branch covers the case when the timeout counter 
+                    // this branch covers the case when the timeout counter
                     // expires and an item must be supplied to the BFM.
                     while continue_work { // can be turned off from outside
-                    
+
                         while timeout_counter < ll_pkt_length {
                             wait [1];
                             timeout_counter += 1;
@@ -86,7 +86,7 @@ extend LAYERED ex_mtm_layering_ll_pkt_sequence {
                         driver.tmp_payload.resize(ll_pkt_length,TRUE,0,TRUE);
                         do ll_pkt keeping {
                             .payload == driver.tmp_payload;
-                        };    
+                        };
                         driver.tmp_payload.clear();
                         timeout_counter = 0;
                     };
diff --git a/lesson000X_mluvm_svsc/uvm_examples/ex_mtm_layering/e/ex_mtm_layering_ml_pkt_seq_lib.e b/lesson000X_mluvm_svsc/uvm_examples/ex_mtm_layering/e/ex_mtm_layering_ml_pkt_seq_lib.e
index 3a24b01..9ad7fe5 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/ex_mtm_layering/e/ex_mtm_layering_ml_pkt_seq_lib.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/ex_mtm_layering/e/ex_mtm_layering_ml_pkt_seq_lib.e
@@ -1,47 +1,47 @@
 
-/*----------------------------------------------------------    
+/*----------------------------------------------------------
 File name   : ex_mtm_layering_ml_pkt_seq_lib.e
-Title       : packet sequence library 
+Title       : packet sequence library
 Project     : many to one layering example
 Created     : 2007
-Description : Defines reusable ml pkt sequences for usage in tests. two 
-            : sequences are defined, one for header and one for upper layer 
-            : packets. each sequence interfaces through a designated method 
-            : port with its upper layer.the upper layer sequences sync through 
+Description : Defines reusable ml pkt sequences for usage in tests. two
+            : sequences are defined, one for header and one for upper layer
+            : packets. each sequence interfaces through a designated method
+            : port with its upper layer.the upper layer sequences sync through
             : is_relevant methods with each other.
-Notes       : This is one of four layering examples: One to one, 
+Notes       : This is one of four layering examples: One to one,
             : One to many, Many to one and Many to many
-----------------------------------------------------------    
-Copyright (c) 2007 Cadence Design Systems, Inc. 
+----------------------------------------------------------
+Copyright (c) 2007 Cadence Design Systems, Inc.
 All rights reserved worldwide.
-Please refer to the terms and conditions in $IPCM_HOME 
-----------------------------------------------------------*/ 
+Please refer to the terms and conditions in $IPCM_HOME
+----------------------------------------------------------*/
+
 
-  
 
 <'
 type ml_seq_role_t: [HEADER,PAYLOAD];
 extend ex_mtm_layering_ml_pkt_sequence_kind: [LAYERED];
 
 extend LAYERED ex_mtm_layering_ml_pkt_sequence {
-    
+
     ml_pkt_id: uint; // used for synchronizing with upper layer
     !do_payload: list of byte;
     !tmp_payload : list of byte;
     ml_seq_role : ml_seq_role_t;
-    
+
     body() @driver.clock is only{
         var continue_work: bool;
-        continue_work = TRUE; 
+        continue_work = TRUE;
         while continue_work { // while there are more upper layer items
             var layering_struct: layering_data_struct_s;
-            layering_struct = get_item_from_upper_layer(ml_pkt_id, 
+            layering_struct = get_item_from_upper_layer(ml_pkt_id,
                 driver.ll_driver.remaining_bytes);
- 
+
             // gets upper layer item or stalls when there is none
             tmp_payload = layering_struct.data.copy();
-            
-            while tmp_payload is not empty {                
+
+            while tmp_payload is not empty {
                 driver.wait_for_grant(me);
                 if driver.ll_driver.remaining_bytes > 0 then {
                     if driver.ll_driver.remaining_bytes >= tmp_payload.size() {
@@ -53,7 +53,7 @@ extend LAYERED ex_mtm_layering_ml_pkt_sequence {
                     };
                 } else {
                     do_payload.clear();
-                };  
+                };
                 gen ml_pkt keeping {
                     .payload == do_payload;
                 };
@@ -67,7 +67,7 @@ extend LAYERED ex_mtm_layering_ml_pkt_sequence {
 
 <'
 extend HEADER LAYERED ex_mtm_layering_ml_pkt_sequence {
-    
+
     is_relevant(): bool is {
         result = driver.ll_driver.tmp_payload is empty;
     };
@@ -76,7 +76,7 @@ extend HEADER LAYERED ex_mtm_layering_ml_pkt_sequence {
 
 <'
 extend PAYLOAD LAYERED ex_mtm_layering_ml_pkt_sequence {
-    
+
     is_relevant(): bool is {
         result = driver.ll_driver.tmp_payload is not empty;
     };
diff --git a/lesson000X_mluvm_svsc/uvm_examples/ex_mtm_layering/e/ex_mtm_layering_ml_pkt_seq_lib_using_pre_do.e b/lesson000X_mluvm_svsc/uvm_examples/ex_mtm_layering/e/ex_mtm_layering_ml_pkt_seq_lib_using_pre_do.e
index 64a5474..90e574c 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/ex_mtm_layering/e/ex_mtm_layering_ml_pkt_seq_lib_using_pre_do.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/ex_mtm_layering/e/ex_mtm_layering_ml_pkt_seq_lib_using_pre_do.e
@@ -1,36 +1,36 @@
 
-/*----------------------------------------------------------    
+/*----------------------------------------------------------
 File name   : ex_mtm_layering_ml_pkt_seq_lib_using_pre_do.e
-Title       : packet sequence library 
+Title       : packet sequence library
 Project     : many to one layering example
 Created     : 2007
-Description : Defines reusable ml pkt sequences for usage in tests. two 
-            : sequences are defined, one for header and one for upper layer 
-            : packets. each sequence interfaces through a designated method 
-            : port with its upper layer.the upper layer sequences sync through 
+Description : Defines reusable ml pkt sequences for usage in tests. two
+            : sequences are defined, one for header and one for upper layer
+            : packets. each sequence interfaces through a designated method
+            : port with its upper layer.the upper layer sequences sync through
             : is_relevant methods with each other.
-Notes       : This file implements the ml pkt using the older sequences 
+Notes       : This file implements the ml pkt using the older sequences
             : mechanism, which did not have deliver_item.
             : So building the item is implemented in the pre_do()
-----------------------------------------------------------    
-Copyright (c) 2007 Cadence Design Systems, Inc. 
+----------------------------------------------------------
+Copyright (c) 2007 Cadence Design Systems, Inc.
 All rights reserved worldwide.
-Please refer to the terms and conditions in $IPCM_HOME 
-----------------------------------------------------------*/ 
+Please refer to the terms and conditions in $IPCM_HOME
+----------------------------------------------------------*/
+
 
-  
 
 <'
 type ml_seq_role_t: [HEADER,PAYLOAD];
 extend ex_mtm_layering_ml_pkt_sequence_kind: [LAYERED];
 
 extend LAYERED ex_mtm_layering_ml_pkt_sequence {
-    
+
     ml_pkt_id: uint; // used for synchronizing with upper layer
     !do_payload: list of byte;
     !tmp_payload : list of byte;
     ml_seq_role : ml_seq_role_t;
-    
+
     pre_do(is_item: bool) @sys.any is {
         if is_item {
             if driver.ll_driver.remaining_bytes > 0 then {
@@ -43,21 +43,21 @@ extend LAYERED ex_mtm_layering_ml_pkt_sequence {
                 };
             } else {
                 do_payload.clear();
-            };  
+            };
         };
     };
-    
+
     body() @driver.clock is only{
         var continue_work: bool;
-        continue_work = TRUE; 
+        continue_work = TRUE;
         while continue_work { // while there are more upper layer items
             var layering_struct: layering_data_struct_s;
-            layering_struct = get_item_from_upper_layer(ml_pkt_id, 
+            layering_struct = get_item_from_upper_layer(ml_pkt_id,
                 driver.ll_driver.remaining_bytes);
- 
+
             // gets upper layer item or stalls when there is none
             tmp_payload = layering_struct.data.copy();
-            
+
             while tmp_payload is not empty {
                 do ml_pkt keeping {
                     .payload == do_payload;
@@ -71,7 +71,7 @@ extend LAYERED ex_mtm_layering_ml_pkt_sequence {
 
 <'
 extend HEADER LAYERED ex_mtm_layering_ml_pkt_sequence {
-    
+
     is_relevant(): bool is {
         result = driver.ll_driver.tmp_payload is empty;
     };
@@ -80,7 +80,7 @@ extend HEADER LAYERED ex_mtm_layering_ml_pkt_sequence {
 
 <'
 extend PAYLOAD LAYERED ex_mtm_layering_ml_pkt_sequence {
-    
+
     is_relevant(): bool is {
         result = driver.ll_driver.tmp_payload is not empty;
     };
diff --git a/lesson000X_mluvm_svsc/uvm_examples/ex_mtm_layering/e/ex_mtm_layering_system_env.e b/lesson000X_mluvm_svsc/uvm_examples/ex_mtm_layering/e/ex_mtm_layering_system_env.e
index b8a9ecb..3356401 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/ex_mtm_layering/e/ex_mtm_layering_system_env.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/ex_mtm_layering/e/ex_mtm_layering_system_env.e
@@ -1,24 +1,24 @@
-/*----------------------------------------------------------    
+/*----------------------------------------------------------
 File name   : ex_mtm_layering_system_env.e
-Title       : Defines the system env 
+Title       : Defines the system env
 Project     : many to many layering example
 Created     : 2007
-Description : Defines the system env and its virtual driver. 
+Description : Defines the system env and its virtual driver.
             : Instansiates the two layers and binds them.
-Notes       : This is one of four layering examples: One to one, 
+Notes       : This is one of four layering examples: One to one,
             : One to many, Many to one and Many to many
-----------------------------------------------------------    
-Copyright (c) 2007 Cadence Design Systems, Inc. 
+----------------------------------------------------------
+Copyright (c) 2007 Cadence Design Systems, Inc.
 All rights reserved worldwide.
-Please refer to the terms and conditions in $IPCM_HOME 
-----------------------------------------------------------*/ 
+Please refer to the terms and conditions in $IPCM_HOME
+----------------------------------------------------------*/
 
 o disable MAIN BFM sequences:
 
 <'
 
 
-extend MAIN ex_mtm_layering_ul_pkt_sequence {    
+extend MAIN ex_mtm_layering_ul_pkt_sequence {
     keep soft count == 0;
 };
 
@@ -27,7 +27,7 @@ extend MAIN ex_mtm_layering_ul_header_sequence {
 };
 
 
-extend MAIN ex_mtm_layering_ml_pkt_sequence {    
+extend MAIN ex_mtm_layering_ml_pkt_sequence {
     keep soft count == 0;
 };
 
@@ -49,7 +49,7 @@ extend system_sequence {
     !ml_pkt_sequence: ex_mtm_layering_ml_pkt_sequence;
     !ml_header_sequence: ex_mtm_layering_ml_pkt_sequence;
     !ll_pkt_sequence: ex_mtm_layering_ll_pkt_sequence;
-    !system_sequence: system_sequence;    
+    !system_sequence: system_sequence;
     keep ul_pkt_sequence.driver == driver.ul_pkt_driver;
     keep ll_pkt_sequence.driver == driver.ll_pkt_driver;
     keep ul_header_sequence.driver == driver.ul_header_driver;
@@ -82,21 +82,21 @@ unit system_env_u like any_env {
     ll_pkt_env : ex_mtm_layering_ll_pkt_env_u is instance;
     ul_pkt_env : ex_mtm_layering_ul_pkt_env_u is instance;
     ul_header_env : ex_mtm_layering_ul_header_env_u is instance;
-    keep ll_pkt_env.agent.ml_driver.get_item_layer_transfers.size() == 2;    
+    keep ll_pkt_env.agent.ml_driver.get_item_layer_transfers.size() == 2;
     system_driver: system_driver_u is instance;
 
     keep system_driver.ul_pkt_driver == ul_pkt_env.agent.driver;
-    keep system_driver.ul_header_driver == ul_header_env.agent.driver;    
+    keep system_driver.ul_header_driver == ul_header_env.agent.driver;
     keep system_driver.ll_pkt_driver == ll_pkt_env.agent.ll_driver;
     keep system_driver.ml_pkt_driver == ll_pkt_env.agent.ml_driver;
-    
+
     // binding the layeres together
     keep bind (ll_pkt_env.agent.ml_driver.get_item_layer_transfers[0],
                ul_pkt_env.agent.bfm.down_item_layer_transfer);
 
     keep bind (ll_pkt_env.agent.ml_driver.get_item_layer_transfers[1],
                ul_header_env.agent.bfm.down_item_layer_transfer);
-    
+
     // binding the ll_pkt BFM to the DUT (empty in this example)
     keep bind (ll_pkt_env.agent.bfm.d_enable,empty);
     keep bind (ll_pkt_env.agent.bfm.d_bus,empty);
diff --git a/lesson000X_mluvm_svsc/uvm_examples/ex_mtm_layering/e/ex_mtm_layering_system_seq_lib.e b/lesson000X_mluvm_svsc/uvm_examples/ex_mtm_layering/e/ex_mtm_layering_system_seq_lib.e
index 2db23ea..2894285 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/ex_mtm_layering/e/ex_mtm_layering_system_seq_lib.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/ex_mtm_layering/e/ex_mtm_layering_system_seq_lib.e
@@ -1,16 +1,16 @@
-/*----------------------------------------------------------    
+/*----------------------------------------------------------
 File name   : ex_mtm_layering_system_seq_lib.e
-Title       : system level sequence library file 
+Title       : system level sequence library file
 Project     : many to many layering example
 Created     : 2007
-Description : Defines reusable system level sequences 
-Notes       : This is one of four layering examples: One to one, 
+Description : Defines reusable system level sequences
+Notes       : This is one of four layering examples: One to one,
             : One to many, Many to one and Many to many
-----------------------------------------------------------    
-Copyright (c) 2007 Cadence Design Systems, Inc. 
+----------------------------------------------------------
+Copyright (c) 2007 Cadence Design Systems, Inc.
 All rights reserved worldwide.
-Please refer to the terms and conditions in $IPCM_HOME 
-----------------------------------------------------------*/ 
+Please refer to the terms and conditions in $IPCM_HOME
+----------------------------------------------------------*/
 
 <'
 
@@ -19,7 +19,7 @@ extend MAIN system_sequence {
    pre_body() @sys.any is first {
        driver.raise_objection(TEST_DONE);
    };
-   
+
    post_body() @sys.any is also {
       wait [20] * cycle @driver.clock;
       driver.drop_objection(TEST_DONE);
@@ -37,38 +37,38 @@ extend system_sequence_kind: [DEFAULT_SEQS];
 
 extend DEFAULT_SEQS system_sequence {
     body() @driver.clock is {
-        // The following four sequences are required for most 
+        // The following four sequences are required for most
         // of the tests.
-        // All of them work in endless loops, 
+        // All of them work in endless loops,
 
         // 1) start the lower layer sequence - keeps getting items
         // from the layer above it (the mediator layer)
         gen LAYERED ll_pkt_sequence keeping {
-            .ml_driver == driver.ml_pkt_driver;    
-        };      
+            .ml_driver == driver.ml_pkt_driver;
+        };
         ll_pkt_sequence.start_sequence();
-        
-        // 2) start header mediating sequence - 
+
+        // 2) start header mediating sequence -
         // keeps getting header items from the upper layer layer
         gen HEADER LAYERED ml_header_sequence keeping {
             .ml_pkt_id == 1;
         };
-        
+
         // connect the method port to upper layer
-        ml_header_sequence.get_item_layer_transfer = 
+        ml_header_sequence.get_item_layer_transfer =
             driver.ml_pkt_driver.get_item_layer_transfers[1];
         ml_header_sequence.start_sequence();
-        
-        // 3) start payload mediating sequence  - 
+
+        // 3) start payload mediating sequence  -
         // keeps getting payload items from the upper layer layer
         gen PAYLOAD LAYERED ml_pkt_sequence keeping {
             .ml_pkt_id == 1;
         };
         // connect the method port to upper layer
-        ml_pkt_sequence.get_item_layer_transfer = 
+        ml_pkt_sequence.get_item_layer_transfer =
             driver.ml_pkt_driver.get_item_layer_transfers[0];
         ml_pkt_sequence.start_sequence();
-        
+
         // 4) start header upper sequence - keeps generating headers
         gen HEADER ul_header_sequence keeping {
             .upper_layer_id == 1;
@@ -76,7 +76,7 @@ extend DEFAULT_SEQS system_sequence {
         ul_header_sequence.start_sequence();
     };
 };
-     
+
 
 '>
 
diff --git a/lesson000X_mluvm_svsc/uvm_examples/ex_mtm_layering/e/ex_mtm_layering_top.e b/lesson000X_mluvm_svsc/uvm_examples/ex_mtm_layering/e/ex_mtm_layering_top.e
index 0c06971..f138066 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/ex_mtm_layering/e/ex_mtm_layering_top.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/ex_mtm_layering/e/ex_mtm_layering_top.e
@@ -1,16 +1,16 @@
-/*----------------------------------------------------------    
+/*----------------------------------------------------------
 File name   : ex_mtm_layering_top.e
-Title       : Top file 
+Title       : Top file
 Project     : many to one layering example
 Created     : 2007
 Description : Imports the required files.
-Notes       : This is one of four layering examples: One to one, 
+Notes       : This is one of four layering examples: One to one,
             : One to many, Many to one and Many to many
-----------------------------------------------------------    
-Copyright (c) 2007 Cadence Design Systems, Inc. 
+----------------------------------------------------------
+Copyright (c) 2007 Cadence Design Systems, Inc.
 All rights reserved worldwide.
-Please refer to the terms and conditions in $IPCM_HOME 
-----------------------------------------------------------*/ 
+Please refer to the terms and conditions in $IPCM_HOME
+----------------------------------------------------------*/
 
 
 <'
diff --git a/lesson000X_mluvm_svsc/uvm_examples/ex_mtm_layering/e/ex_mtm_layering_ul_header_env.e b/lesson000X_mluvm_svsc/uvm_examples/ex_mtm_layering/e/ex_mtm_layering_ul_header_env.e
index b6c4074..d951ba8 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/ex_mtm_layering/e/ex_mtm_layering_ul_header_env.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/ex_mtm_layering/e/ex_mtm_layering_ul_header_env.e
@@ -1,26 +1,26 @@
-/*----------------------------------------------------------    
+/*----------------------------------------------------------
 File name   : ex_mtm_layering_ul_header_env.e
-Title       : Defines the upper layer header env 
+Title       : Defines the upper layer header env
 Project     : many to many layering example
 Created     : 2007
-Description : Defines the upper layer header env, agent and its sequence, 
-            : item and Driver. Defines the BFM and the interface method to 
+Description : Defines the upper layer header env, agent and its sequence,
+            : item and Driver. Defines the BFM and the interface method to
             : lower layer.
-Notes       : This is one of four layering examples: One to one, 
+Notes       : This is one of four layering examples: One to one,
             : One to many, Many to one and Many to many
-----------------------------------------------------------    
-Copyright (c) 2007 Cadence Design Systems, Inc. 
+----------------------------------------------------------
+Copyright (c) 2007 Cadence Design Systems, Inc.
 All rights reserved worldwide.
-Please refer to the terms and conditions in $IPCM_HOME 
-----------------------------------------------------------*/ 
+Please refer to the terms and conditions in $IPCM_HOME
+----------------------------------------------------------*/
+
 
-    
 o The header:
 
 <'
 define UL_HEADER_LEN 256;
 
-// The header struct is an abstract data type designed to 
+// The header struct is an abstract data type designed to
 // demonstrate layering. It is not a part of any known protocol
 
 struct ex_mtm_layering_ul_header like any_sequence_item {
@@ -42,30 +42,30 @@ o The ul_header BFM:
 <'
 
 unit ex_mtm_layering_ul_header_bfm_u like uvm_bfm {
-    
+
     // public interface
-    
+
     h_driver: ex_mtm_layering_ul_header_driver_u;
-    
+
     event h_clock is cycle @sys.any;  	-- The ATM main clock
-    
+
     on h_clock {
         emit h_driver.clock;
     };
     // private interface
     driver_locker: locker;
-    -- An interface method to lower layer 
-    
-    down_item_layer_transfer: 
+    -- An interface method to lower layer
+
+    down_item_layer_transfer:
         in method_port of item_layer_transfer is instance;
 
-    // This method tries to get an item from the driver. 
-    // It calls try_next_item and not get_next_item so the driver is 
+    // This method tries to get an item from the driver.
+    // It calls try_next_item and not get_next_item so the driver is
     // not blocked by any lower layer request
-    
-    down_item_layer_transfer(stream_id: uint, remaining_bytes: uint): 
+
+    down_item_layer_transfer(stream_id: uint, remaining_bytes: uint):
             layering_data_struct_s @sys.any is {
-        
+
         driver_locker.lock();
         var ul_header_item: ex_mtm_layering_ul_header;
         h_driver.stream_id = stream_id;
@@ -76,7 +76,7 @@ unit ex_mtm_layering_ul_header_bfm_u like uvm_bfm {
             result.data = pack(NULL, ul_header_item);
             result.upper_layer_struct = ul_header_item;
             message(MEDIUM, "UL BFM gives an item to the lower layer");
-            emit h_driver.item_done; 
+            emit h_driver.item_done;
         } else {
             result = NULL;
         };
@@ -90,7 +90,7 @@ o Defining ul_header_sequence and hooking it up:
 
 <'
 -- Define ul_header_sequence, ul_header_sequence_kind and ul_header_driver
-sequence ex_mtm_layering_ul_header_sequence using item=ex_mtm_layering_ul_header, 
+sequence ex_mtm_layering_ul_header_sequence using item=ex_mtm_layering_ul_header,
     created_driver=ex_mtm_layering_ul_header_driver_u;
 
 extend ex_mtm_layering_ul_header_driver_u {
@@ -112,7 +112,7 @@ o The enclosing UL_HEADER agent:
 unit ex_mtm_layering_ul_header_agent_u like uvm_agent {
 
     driver: ex_mtm_layering_ul_header_driver_u is instance;
-    
+
     bfm: ex_mtm_layering_ul_header_bfm_u is instance;
     keep bfm.h_driver == driver;
 };
@@ -127,12 +127,12 @@ unit ex_mtm_layering_ul_header_env_u like uvm_env {
     -- One can also instantiate here an ul_header monitor unit, etc..
     logger    : message_logger is instance;
     file_logger      : message_logger  is instance;
-    
+
     keep soft file_logger.to_screen == FALSE;
     keep soft file_logger.to_file == "ul_header";
-    
+
     agent: ex_mtm_layering_ul_header_agent_u is instance;
-    
+
 };
 
 '>
diff --git a/lesson000X_mluvm_svsc/uvm_examples/ex_mtm_layering/e/ex_mtm_layering_ul_pkt_env.e b/lesson000X_mluvm_svsc/uvm_examples/ex_mtm_layering/e/ex_mtm_layering_ul_pkt_env.e
index 687c687..544e06b 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/ex_mtm_layering/e/ex_mtm_layering_ul_pkt_env.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/ex_mtm_layering/e/ex_mtm_layering_ul_pkt_env.e
@@ -1,20 +1,20 @@
-/*----------------------------------------------------------    
+/*----------------------------------------------------------
 File name   : ex_mtm_layering_ul_pkt_env.e
-Title       : Defines the upper layer packet env 
+Title       : Defines the upper layer packet env
 Project     : many to many layering example
 Created     : 2007
-Description : Defines the upper layer packet env, agent and its sequence, 
-            : item and driver. Defines the BFM and the interface method to 
+Description : Defines the upper layer packet env, agent and its sequence,
+            : item and driver. Defines the BFM and the interface method to
             : lower layer.
-Notes       : This is one of four layering examples: One to one, 
+Notes       : This is one of four layering examples: One to one,
             : One to many, Many to one and Many to many
-----------------------------------------------------------    
-Copyright (c) 2007 Cadence Design Systems, Inc. 
+----------------------------------------------------------
+Copyright (c) 2007 Cadence Design Systems, Inc.
 All rights reserved worldwide.
-Please refer to the terms and conditions in $IPCM_HOME 
-----------------------------------------------------------*/ 
- 
-    
+Please refer to the terms and conditions in $IPCM_HOME
+----------------------------------------------------------*/
+
+
 o The Packet:
 
 <'
@@ -23,7 +23,7 @@ define UL_PKT_MIN_LEN 64;
 define UL_PKT_THRSH_LEN 96;
 define UL_PKT_MAX_LEN 512;
 
-// The packet struct is an abstract data type designed to 
+// The packet struct is an abstract data type designed to
 // demonstrate layering. It is not a part of any known protocol
 
 type ex_mtm_layering_ul_pkt_length_t: [SHORT_P, LONG_P,ZERO_P];
@@ -37,7 +37,7 @@ struct ex_mtm_layering_ul_pkt like any_sequence_item {
                 soft len in [UL_PKT_MIN_LEN..UL_PKT_THRSH_LEN];
     keep length_range == LONG_P =>
             soft len in [UL_PKT_THRSH_LEN + 1..UL_PKT_MAX_LEN];
-    
+
     %payload[len]: list of byte;
     keep soft length_range != ZERO_P;
 
@@ -54,30 +54,30 @@ o The ul_pkt BFM:
 <'
 
 unit ex_mtm_layering_ul_pkt_bfm_u like uvm_bfm {
-    
+
     // public interface
-    
+
     p_driver: ex_mtm_layering_ul_pkt_driver_u;
-    
+
     event p_clock is cycle @sys.any;  	-- The ATM main clock
-    
+
     on p_clock {
         emit p_driver.clock;
     };
     // private interface
     driver_locker: locker;
-    -- An interface method to lower layer 
-    
-    down_item_layer_transfer: 
+    -- An interface method to lower layer
+
+    down_item_layer_transfer:
         in method_port of item_layer_transfer is instance;
 
-    // This method tries to get an item from the driver. 
-    // It calls try_next_item and not get_next_item so the driver is 
+    // This method tries to get an item from the driver.
+    // It calls try_next_item and not get_next_item so the driver is
     // not blocked by any lower layer request
-    
-    down_item_layer_transfer(stream_id: uint,remaining_bytes: uint): 
+
+    down_item_layer_transfer(stream_id: uint,remaining_bytes: uint):
         layering_data_struct_s @sys.any is {
-        
+
         driver_locker.lock();
         var ul_pkt_item: ex_mtm_layering_ul_pkt;
         p_driver.stream_id = stream_id;
@@ -88,7 +88,7 @@ unit ex_mtm_layering_ul_pkt_bfm_u like uvm_bfm {
             result.data = pack(NULL, ul_pkt_item);
             result.upper_layer_struct = ul_pkt_item;
             message(MEDIUM, "UL BFM gives an item to the lower layer");
-            emit p_driver.item_done; 
+            emit p_driver.item_done;
         } else {
             result = NULL;
         };
@@ -102,7 +102,7 @@ o Defining ul_pkt_sequence and hooking it up:
 
 <'
 -- Define ul_pkt_sequence, ul_pkt_sequence_kind and ul_pkt_driver
-sequence ex_mtm_layering_ul_pkt_sequence using item=ex_mtm_layering_ul_pkt, 
+sequence ex_mtm_layering_ul_pkt_sequence using item=ex_mtm_layering_ul_pkt,
     created_driver=ex_mtm_layering_ul_pkt_driver_u;
 
 extend ex_mtm_layering_ul_pkt_driver_u {
@@ -124,7 +124,7 @@ o The enclosing UL_PKT agent:
 unit ex_mtm_layering_ul_pkt_agent_u like uvm_agent {
 
     driver: ex_mtm_layering_ul_pkt_driver_u is instance;
-    
+
     bfm: ex_mtm_layering_ul_pkt_bfm_u is instance;
     keep bfm.p_driver == driver;
 };
@@ -139,12 +139,12 @@ unit ex_mtm_layering_ul_pkt_env_u like uvm_env {
     -- One can also instantiate here an ul_pkt monitor unit, etc..
     logger    : message_logger is instance;
     file_logger      : message_logger  is instance;
-    
+
     keep soft file_logger.to_screen == FALSE;
     keep soft file_logger.to_file == "ul_pkt";
-    
+
     agent: ex_mtm_layering_ul_pkt_agent_u is instance;
-    
+
 };
 
 '>
diff --git a/lesson000X_mluvm_svsc/uvm_examples/ex_mtm_layering/e/ex_mtm_layering_ul_pkt_seq_lib.e b/lesson000X_mluvm_svsc/uvm_examples/ex_mtm_layering/e/ex_mtm_layering_ul_pkt_seq_lib.e
index 1375bd8..2531e10 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/ex_mtm_layering/e/ex_mtm_layering_ul_pkt_seq_lib.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/ex_mtm_layering/e/ex_mtm_layering_ul_pkt_seq_lib.e
@@ -1,37 +1,37 @@
-/*----------------------------------------------------------    
+/*----------------------------------------------------------
 File name   : ex_mtm_layering_ul_pkt_seq_lib.e
-Title       : upper layer packet sequence library 
+Title       : upper layer packet sequence library
 Project     : many to many layering example
 Created     : 2007
 Description : Defines reusable upper layer packet sequences for usage in tests
-Notes       : This is one of four layering examples: One to one, 
+Notes       : This is one of four layering examples: One to one,
             : One to many, Many to one and Many to many
-----------------------------------------------------------    
-Copyright (c) 2007 Cadence Design Systems, Inc. 
+----------------------------------------------------------
+Copyright (c) 2007 Cadence Design Systems, Inc.
 All rights reserved worldwide.
-Please refer to the terms and conditions in $IPCM_HOME 
-----------------------------------------------------------*/ 
- 
+Please refer to the terms and conditions in $IPCM_HOME
+----------------------------------------------------------*/
+
 <'
 extend ex_mtm_layering_ul_pkt_sequence {
     upper_layer_id: uint;
-    
+
     is_relevant(): bool is only {
         result = (upper_layer_id == driver.stream_id);
     };
 };
 
 '>
-    
+
 <'
-// this is an example for upper layer sequence. it does items only for the 
-// lower layer sequence with the same stream id. it creates a scenario of upper 
+// this is an example for upper layer sequence. it does items only for the
+// lower layer sequence with the same stream id. it creates a scenario of upper
 // layer packet that ends on the border of two lower layer packets.
 
 extend ex_mtm_layering_ul_pkt_sequence_kind: [EXACT];
 
 extend EXACT ex_mtm_layering_ul_pkt_sequence {
-    
+
     is_relevant(): bool is only {
         result = (upper_layer_id == driver.stream_id);
     };
@@ -55,7 +55,7 @@ extend LAYERED ex_mtm_layering_ul_pkt_sequence {
     is_relevant(): bool is only {
         result = (upper_layer_id == driver.stream_id);
     };
-    
+
     body() @driver.clock is {
         do ul_pkt;
     };
@@ -64,11 +64,11 @@ extend LAYERED ex_mtm_layering_ul_pkt_sequence {
 '>
 <'
 
-// calls any ul_headers in an infinite loop (imitates header) 
+// calls any ul_headers in an infinite loop (imitates header)
 
 extend ex_mtm_layering_ul_header_sequence {
     upper_layer_id: uint;
-    
+
     is_relevant(): bool is only {
         result = (upper_layer_id == driver.stream_id);
     };
@@ -78,11 +78,11 @@ extend ex_mtm_layering_ul_header_sequence {
 extend ex_mtm_layering_ul_header_sequence_kind: [HEADER];
 
 extend HEADER ex_mtm_layering_ul_header_sequence {
-    
+
     is_relevant(): bool is only {
         result = (upper_layer_id == driver.stream_id);
     };
-    
+
     body() @driver.clock is {
         while TRUE {
             do ul_header;
diff --git a/lesson000X_mluvm_svsc/uvm_examples/ex_mto_layering/demo.ecom b/lesson000X_mluvm_svsc/uvm_examples/ex_mto_layering/demo.ecom
index 4a48670..6416f77 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/ex_mto_layering/demo.ecom
+++ b/lesson000X_mluvm_svsc/uvm_examples/ex_mto_layering/demo.ecom
@@ -4,4 +4,4 @@ load ex_mto_layering/examples/ex_mto_layering_test
 trace sequence
 set message MEDIUM
 test
-    
\ No newline at end of file
+
diff --git a/lesson000X_mluvm_svsc/uvm_examples/ex_mto_layering/demo.sh b/lesson000X_mluvm_svsc/uvm_examples/ex_mto_layering/demo.sh
index 80f7bfb..1d1d395 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/ex_mto_layering/demo.sh
+++ b/lesson000X_mluvm_svsc/uvm_examples/ex_mto_layering/demo.sh
@@ -33,10 +33,10 @@ while [ $# -gt 0 ]; do
 	;;
       -run)
          quit_cmd="-c @$2"
-	
+
          shift
     esac
-    shift   
+    shift
 done
 #================================================================
 if [ $run_mode = batch ]; then
diff --git a/lesson000X_mluvm_svsc/uvm_examples/ex_mto_layering/e/ex_mto_layering_base.e b/lesson000X_mluvm_svsc/uvm_examples/ex_mto_layering/e/ex_mto_layering_base.e
index 02ed721..6bb0298 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/ex_mto_layering/e/ex_mto_layering_base.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/ex_mto_layering/e/ex_mto_layering_base.e
@@ -1,17 +1,17 @@
-/*----------------------------------------------------------    
+/*----------------------------------------------------------
 File name   : ex_mto_layering_base.e
-Title       : Defines the base types for layering 
+Title       : Defines the base types for layering
 Project     : many to one layering example
 Created     : 2007
-Description : Defines the method port for layering and the basic 
+Description : Defines the method port for layering and the basic
             : layering struct.
-Notes       : This is one of four layering examples: One to one, 
+Notes       : This is one of four layering examples: One to one,
             : One to many, Many to one and Many to many
-----------------------------------------------------------    
-Copyright (c) 2007 Cadence Design Systems, Inc. 
+----------------------------------------------------------
+Copyright (c) 2007 Cadence Design Systems, Inc.
 All rights reserved worldwide.
-Please refer to the terms and conditions in $IPCM_HOME 
-----------------------------------------------------------*/ 
+Please refer to the terms and conditions in $IPCM_HOME
+----------------------------------------------------------*/
 
 
 
@@ -20,11 +20,11 @@ o Layering interface declaration
 <'
 struct layering_data_struct_s {
     // can also be list of bit for a more general data representation
-    data: list of byte;             
+    data: list of byte;
 
-    // can deliver structs across layers for user defined application 
+    // can deliver structs across layers for user defined application
     // specific usage
-    upper_layer_struct: any_struct; 
+    upper_layer_struct: any_struct;
 
 };
 
diff --git a/lesson000X_mluvm_svsc/uvm_examples/ex_mto_layering/e/ex_mto_layering_ll_pkt_env.e b/lesson000X_mluvm_svsc/uvm_examples/ex_mto_layering/e/ex_mto_layering_ll_pkt_env.e
index aa2c4fc..3a75b0a 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/ex_mto_layering/e/ex_mto_layering_ll_pkt_env.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/ex_mto_layering/e/ex_mto_layering_ll_pkt_env.e
@@ -1,20 +1,20 @@
-/*----------------------------------------------------------    
+/*----------------------------------------------------------
 File name   : ex_mto_layering_ll_pkt_env.e
-Title       : Defines the lower layer pkt env 
+Title       : Defines the lower layer pkt env
 Project     : many to one layering example
 Created     : 2007
-Description : Defines the ll pkt env , agent and its sequence, item and 
-            : driver. Also contains the interface for the upper layer. 
+Description : Defines the ll pkt env , agent and its sequence, item and
+            : driver. Also contains the interface for the upper layer.
             : Defines the BFM.
-Notes       : This is one of four layering examples: One to one, 
+Notes       : This is one of four layering examples: One to one,
             : One to many, Many to one and Many to many
-----------------------------------------------------------    
-Copyright (c) 2007 Cadence Design Systems, Inc. 
+----------------------------------------------------------
+Copyright (c) 2007 Cadence Design Systems, Inc.
 All rights reserved worldwide.
-Please refer to the terms and conditions in $IPCM_HOME 
-----------------------------------------------------------*/ 
- 
-    
+Please refer to the terms and conditions in $IPCM_HOME
+----------------------------------------------------------*/
+
+
 o The ll pkt struct:
 
 <'
@@ -26,7 +26,7 @@ struct ex_mto_layering_ll_pkt_s like any_sequence_item {
     color: 	ex_mto_layering_ll_pkt_color;
     payload: 	list of byte;
     keep soft payload.size() in [LL_MIN_PKT_LEN..LL_MAX_PKT_LEN];
-    
+
     -- How to print it in the "trace sequence"/"show sequence" output
     nice_string(): string is also {
         return append(result, " (", color,")");
@@ -41,22 +41,22 @@ o The BFM:
 
 
 unit ex_mto_layering_ll_pkt_bfm_u like uvm_bfm {
-    
+
     // public interface
     d_enable: out simple_port of bit is instance; // ports to the DUT
     d_bus: out simple_port of byte is instance;   // ports to the DUT
-    
+
     event a_clock is cycle @sys.any;  	-- The LL_PKT main clock
     event ll_pkt_started;			-- start of transfer to DUT
     event ll_pkt_ended;			-- end of transfer to DUT
 
     driver:ex_mto_layering_ll_pkt_driver_u;
-    
+
     on a_clock {
         emit driver.clock;
     };
-    
-    
+
+
     -- A method which sends the ll_pkt into the DUT
     transfer_ll_pkt_to_dut(ll_pkt: ex_mto_layering_ll_pkt_s) @a_clock is {
         emit ll_pkt_started;
@@ -71,9 +71,9 @@ unit ex_mto_layering_ll_pkt_bfm_u like uvm_bfm {
         wait cycle;
         emit ll_pkt_ended;
         messagef(MEDIUM, "Finished sending ll_pkt data\n");
-        
+
     };
-    
+
     pull_send_loop() @a_clock is {
         while TRUE {
             var ll_pkt := driver.get_next_item();
@@ -81,12 +81,12 @@ unit ex_mto_layering_ll_pkt_bfm_u like uvm_bfm {
             emit driver.item_done;
         };
     };
-    
+
     run() is also {
         start pull_send_loop();
     };
-    
-    
+
+
 };
 '>
 
@@ -96,7 +96,7 @@ o Defining ll_pkt_sequence and hooking it up:
 <'
 
 -- Define ll_pkt_sequence, ll_pkt_sequence_kind and ll_pkt_driver
-sequence ex_mto_layering_ll_pkt_sequence using item=ex_mto_layering_ll_pkt_s, 
+sequence ex_mto_layering_ll_pkt_sequence using item=ex_mto_layering_ll_pkt_s,
     created_driver=ex_mto_layering_ll_pkt_driver_u;
 
 #ifdef SPECMAN_VERSION_8_2_OR_LATER {
@@ -105,11 +105,11 @@ sequence ex_mto_layering_ll_pkt_sequence using item=ex_mto_layering_ll_pkt_s,
     -- Extend the base type with essential fields
     extend ex_mto_layering_ll_pkt_sequence {
         !ll_pkt: ex_mto_layering_ll_pkt_s;
-        
-        get_item_from_upper_layer(stream_id : uint,remaining_bytes: uint): 
-            layering_data_struct_s @driver.clock is {  
-            
-            // This method returns item or NULL to the lower layer 
+
+        get_item_from_upper_layer(stream_id : uint,remaining_bytes: uint):
+            layering_data_struct_s @driver.clock is {
+
+            // This method returns item or NULL to the lower layer
             result = driver.get_item_layer_transfer$(stream_id,
                 remaining_bytes);
             if result != NULL then {
@@ -118,17 +118,17 @@ sequence ex_mto_layering_ll_pkt_sequence using item=ex_mto_layering_ll_pkt_s,
             };
         };
     };
-} 
+}
 #else {
 
     -- Extend the base type with essential fields
     extend ex_mto_layering_ll_pkt_sequence {
         !ll_pkt: ex_mto_layering_ll_pkt_s;
-        
-        get_item_from_upper_layer(stream_id : uint,remaining_bytes: uint): 
-            layering_data_struct_s @driver.clock is {  
-            
-            // This method blocks the lower layer while enabling other instances 
+
+        get_item_from_upper_layer(stream_id : uint,remaining_bytes: uint):
+            layering_data_struct_s @driver.clock is {
+
+            // This method blocks the lower layer while enabling other instances
             // to call the upper layer
             while result == NULL {
                 result = driver.get_item_layer_transfer$(stream_id,
@@ -145,11 +145,11 @@ sequence ex_mto_layering_ll_pkt_sequence using item=ex_mto_layering_ll_pkt_s,
 };
 
 
--- An interface method to upper layer 
+-- An interface method to upper layer
 
 extend ex_mto_layering_ll_pkt_driver_u {
     // method port to upper layer
-    get_item_layer_transfer: 
+    get_item_layer_transfer:
         out method_port of item_layer_transfer is instance;
 };
 
@@ -163,7 +163,7 @@ o The enclosing LL_PKT agent:
 <'
 
 unit ex_mto_layering_ll_pkt_agent_u like uvm_agent {
-    
+
     bfm: ex_mto_layering_ll_pkt_bfm_u is instance;
     -- One can also instantiate here an LL_PKT monitor unit, etc..
     driver: ex_mto_layering_ll_pkt_driver_u is instance;
@@ -177,24 +177,24 @@ o The enclosing LL_PKT environment:
 <'
 
 unit ex_mto_layering_ll_pkt_env_u like uvm_env {
-    
+
     logger    : message_logger is instance;
     file_logger      : message_logger  is instance;
-    
+
     keep soft file_logger.to_screen == FALSE;
     keep soft file_logger.to_file == "ll_pkt";
     -- Instantiate a driver in the LL_PKT env
-    
+
     evc_name : string;
     keep soft evc_name == "LL_PKT ";
-    
+
     short_name(): string is only {
         return append(evc_name);
     };
-    
+
     ll_pkt_color : vt_style;
     keep ll_pkt_color  == DARK_PURPLE;
-    
+
     short_name_style(): vt_style is only {return ll_pkt_color;};
 
     agent: ex_mto_layering_ll_pkt_agent_u is instance;
diff --git a/lesson000X_mluvm_svsc/uvm_examples/ex_mto_layering/e/ex_mto_layering_ll_pkt_seq_lib.e b/lesson000X_mluvm_svsc/uvm_examples/ex_mto_layering/e/ex_mto_layering_ll_pkt_seq_lib.e
index a637528..dd84538 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/ex_mto_layering/e/ex_mto_layering_ll_pkt_seq_lib.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/ex_mto_layering/e/ex_mto_layering_ll_pkt_seq_lib.e
@@ -1,17 +1,17 @@
-/*----------------------------------------------------------    
+/*----------------------------------------------------------
 File name   : ex_mto_layering_ll_pkt_seq_lib.e
-Title       : packet sequence library 
+Title       : packet sequence library
 Project     : many to one layering example
 Created     : 2007
 Description : Defines reusable ul pkt sequences for usage in tests
-Notes       : This is one of four layering examples: One to one, 
+Notes       : This is one of four layering examples: One to one,
             : One to many, Many to one and Many to many
-----------------------------------------------------------    
-Copyright (c) 2007 Cadence Design Systems, Inc. 
+----------------------------------------------------------
+Copyright (c) 2007 Cadence Design Systems, Inc.
 All rights reserved worldwide.
-Please refer to the terms and conditions in $IPCM_HOME 
-----------------------------------------------------------*/ 
- 
+Please refer to the terms and conditions in $IPCM_HOME
+----------------------------------------------------------*/
+
 
 <'
 define LL_TIMEOUT 4000;
@@ -26,7 +26,7 @@ extend LAYERED ex_mto_layering_ll_pkt_sequence {
     body() @driver.clock is only{
 
         var continue_work: bool;
-        continue_work = TRUE; 
+        continue_work = TRUE;
         var tmp_payload : list of byte;
         var layering_struct: layering_data_struct_s;
         var remaining_bytes : uint;
@@ -35,7 +35,7 @@ extend LAYERED ex_mto_layering_ll_pkt_sequence {
         var granted: bool;
         while continue_work { // while there are more upper layer items
             // continue_work is set to FALSE upon timeout
-            
+
             driver.wait_for_grant(me);
             first of {
                 {
@@ -53,11 +53,11 @@ extend LAYERED ex_mto_layering_ll_pkt_sequence {
                         .payload == tmp_payload;
                     };
                     tmp_payload.clear();
-                    driver.deliver_item(ll_pkt);    
+                    driver.deliver_item(ll_pkt);
                 };
                 {
-                    // time out for upper layer items (can be increased or 
-                    // decreased upon need) should be much bigger then 
+                    // time out for upper layer items (can be increased or
+                    // decreased upon need) should be much bigger then
                     // typical accumulation time. enables stop_run from virtual
                     // sequence
                     wait [LL_TIMEOUT];
@@ -67,8 +67,8 @@ extend LAYERED ex_mto_layering_ll_pkt_sequence {
                         gen ll_pkt keeping {
                             .payload == tmp_payload;
                         };
-                        driver.deliver_item(ll_pkt);    
-                    };    
+                        driver.deliver_item(ll_pkt);
+                    };
                     continue_work = FALSE;
                 };
             };
@@ -79,14 +79,14 @@ extend LAYERED ex_mto_layering_ll_pkt_sequence {
 '>
 
 <'
-// this is an example for regular (non layered) ll_pkt sequence. 
+// this is an example for regular (non layered) ll_pkt sequence.
 // it can be called with no limitations during layered tests.
 
 extend ex_mto_layering_ll_pkt_sequence_kind: [ALL_RED];
 extend ALL_RED ex_mto_layering_ll_pkt_sequence {
 
     count: int[1..10];
-    
+
     body() @driver.clock is {
         for i from 1 to count {
             do ll_pkt keeping {.color == RED};
diff --git a/lesson000X_mluvm_svsc/uvm_examples/ex_mto_layering/e/ex_mto_layering_ll_pkt_seq_lib_using_do.e b/lesson000X_mluvm_svsc/uvm_examples/ex_mto_layering/e/ex_mto_layering_ll_pkt_seq_lib_using_do.e
index a0c2d1a..4235cd2 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/ex_mto_layering/e/ex_mto_layering_ll_pkt_seq_lib_using_do.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/ex_mto_layering/e/ex_mto_layering_ll_pkt_seq_lib_using_do.e
@@ -1,17 +1,17 @@
-/*----------------------------------------------------------    
+/*----------------------------------------------------------
 File name   : ex_mto_layering_ll_pkt_seq_lib.e
-Title       : packet sequence library 
+Title       : packet sequence library
 Project     : many to one layering example
 Created     : 2007
 Description : Defines reusable ul pkt sequences for usage in tests
-Notes       : This is one of four layering examples: One to one, 
+Notes       : This is one of four layering examples: One to one,
             : One to many, Many to one and Many to many
-----------------------------------------------------------    
-Copyright (c) 2007 Cadence Design Systems, Inc. 
+----------------------------------------------------------
+Copyright (c) 2007 Cadence Design Systems, Inc.
 All rights reserved worldwide.
-Please refer to the terms and conditions in $IPCM_HOME 
-----------------------------------------------------------*/ 
- 
+Please refer to the terms and conditions in $IPCM_HOME
+----------------------------------------------------------*/
+
 
 <'
 define LL_TIMEOUT 4000;
@@ -26,7 +26,7 @@ extend LAYERED ex_mto_layering_ll_pkt_sequence {
     body() @driver.clock is only{
 
         var continue_work: bool;
-        continue_work = TRUE; 
+        continue_work = TRUE;
         var tmp_payload : list of byte;
         while continue_work { // while there are more upper layer items
             // continue_work is set to FALSE upon timeout
@@ -39,7 +39,7 @@ extend LAYERED ex_mto_layering_ll_pkt_sequence {
                         ll_pkt_id, remaining_bytes);
                     // gets upper layer item or stalls when there is none
                     if layering_struct.data.size() == 0 then {
-                        // signal to encapsulate and send current payload 
+                        // signal to encapsulate and send current payload
                         do ll_pkt keeping {
                             .payload == tmp_payload;
                         };
@@ -50,8 +50,8 @@ extend LAYERED ex_mto_layering_ll_pkt_sequence {
                     };
                 };
                 {
-                    // time out for upper layer items (can be increased or 
-                    // decreased upon need) should be much bigger then 
+                    // time out for upper layer items (can be increased or
+                    // decreased upon need) should be much bigger then
                     // typical accumulation time. enables stop_run from virtual
                     // sequence
                     wait [LL_TIMEOUT];
@@ -60,7 +60,7 @@ extend LAYERED ex_mto_layering_ll_pkt_sequence {
                         do ll_pkt keeping {
                             .payload == tmp_payload;
                         };
-                    };    
+                    };
                     continue_work = FALSE;
                 };
             };
@@ -71,14 +71,14 @@ extend LAYERED ex_mto_layering_ll_pkt_sequence {
 '>
 
 <'
-// this is an example for regular (non layered) ll_pkt sequence. 
+// this is an example for regular (non layered) ll_pkt sequence.
 // it can be called with no limitations during layered tests.
 
 extend ex_mto_layering_ll_pkt_sequence_kind: [ALL_RED];
 extend ALL_RED ex_mto_layering_ll_pkt_sequence {
 
     count: int[1..10];
-    
+
     body() @driver.clock is {
         for i from 1 to count {
             do ll_pkt keeping {.color == RED};
diff --git a/lesson000X_mluvm_svsc/uvm_examples/ex_mto_layering/e/ex_mto_layering_system_env.e b/lesson000X_mluvm_svsc/uvm_examples/ex_mto_layering/e/ex_mto_layering_system_env.e
index 9347fe1..0b995d9 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/ex_mto_layering/e/ex_mto_layering_system_env.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/ex_mto_layering/e/ex_mto_layering_system_env.e
@@ -1,24 +1,24 @@
-/*----------------------------------------------------------    
+/*----------------------------------------------------------
 File name   : ex_mto_layering_system_env.e
-Title       : Defines the system env 
+Title       : Defines the system env
 Project     : many to one layering example
 Created     : 2007
-Description : Defines the system env and its virtual Driver. 
+Description : Defines the system env and its virtual Driver.
             : Instansiates the two layers and binds them.
-Notes       : This is one of four layering examples: One to one, 
+Notes       : This is one of four layering examples: One to one,
             : One to many, Many to one and Many to many
-----------------------------------------------------------    
-Copyright (c) 2007 Cadence Design Systems, Inc. 
+----------------------------------------------------------
+Copyright (c) 2007 Cadence Design Systems, Inc.
 All rights reserved worldwide.
-Please refer to the terms and conditions in $IPCM_HOME 
-----------------------------------------------------------*/ 
+Please refer to the terms and conditions in $IPCM_HOME
+----------------------------------------------------------*/
 
 o disable MAIN BFM sequences:
 
 <'
 
 
-extend MAIN ex_mto_layering_ul_pkt_sequence {    
+extend MAIN ex_mto_layering_ul_pkt_sequence {
     keep soft count == 0;
 };
 
@@ -38,7 +38,7 @@ extend system_sequence {
     // pointers to BFM sequences
     !ul_pkt_sequence: ex_mto_layering_ul_pkt_sequence;
     !ll_pkt_sequence: ex_mto_layering_ll_pkt_sequence;
-    
+
     // driver hookup
     keep ul_pkt_sequence.driver == driver.ul_pkt_driver;
     keep ll_pkt_sequence.driver == driver.ll_pkt_driver;
@@ -46,8 +46,8 @@ extend system_sequence {
 
 
 extend system_driver_u {
-    // the drivers are instanciated in the sub environments and are 
-    // only reused here 
+    // the drivers are instanciated in the sub environments and are
+    // only reused here
     ul_pkt_driver : ex_mto_layering_ul_pkt_driver_u;
     ll_pkt_driver : ex_mto_layering_ll_pkt_driver_u;
 
@@ -67,17 +67,17 @@ unit system_env_u like uvm_env {
 
     ll_pkt_env : ex_mto_layering_ll_pkt_env_u is instance;
     ul_pkt_env : ex_mto_layering_ul_pkt_env_u is instance;
-    
+
     system_driver: system_driver_u is instance;
 
     keep system_driver.ul_pkt_driver == ul_pkt_env.agent.driver;
-    
+
     keep system_driver.ll_pkt_driver == ll_pkt_env.agent.driver;
-    
+
     // binding the layeres together
     keep bind (ll_pkt_env.agent.driver.get_item_layer_transfer,
                ul_pkt_env.agent.bfm.down_item_layer_transfer);
-    
+
     // binding the ll_pkt BFM to the DUT (empty in this example)
     keep bind (ll_pkt_env.agent.bfm.d_enable,empty);
     keep bind (ll_pkt_env.agent.bfm.d_bus,empty);
diff --git a/lesson000X_mluvm_svsc/uvm_examples/ex_mto_layering/e/ex_mto_layering_system_seq_lib.e b/lesson000X_mluvm_svsc/uvm_examples/ex_mto_layering/e/ex_mto_layering_system_seq_lib.e
index 1a37abc..49fa94b 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/ex_mto_layering/e/ex_mto_layering_system_seq_lib.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/ex_mto_layering/e/ex_mto_layering_system_seq_lib.e
@@ -1,18 +1,18 @@
-/*----------------------------------------------------------    
+/*----------------------------------------------------------
 File name   : ex_mto_layering_system_seq_lib.e
-Title       : system level sequence library file 
+Title       : system level sequence library file
 Project     : many to one layering example
 Created     : 2007
 Description : Defines reusable system level sequences for usage in tests
-Notes       : This is one of four layering examples: One to one, 
+Notes       : This is one of four layering examples: One to one,
             : One to many, Many to one and Many to many
-----------------------------------------------------------    
-Copyright (c) 2007 Cadence Design Systems, Inc. 
+----------------------------------------------------------
+Copyright (c) 2007 Cadence Design Systems, Inc.
 All rights reserved worldwide.
-Please refer to the terms and conditions in $IPCM_HOME 
-----------------------------------------------------------*/ 
+Please refer to the terms and conditions in $IPCM_HOME
+----------------------------------------------------------*/
+
 
- 
 <'
 
 // set stop condition for the test
@@ -20,7 +20,7 @@ extend MAIN system_sequence {
    pre_body() @sys.any is first {
        driver.raise_objection(TEST_DONE);
    };
-   
+
    post_body() @sys.any is also {
       wait [20] * cycle @driver.clock;
       driver.drop_objection(TEST_DONE);
diff --git a/lesson000X_mluvm_svsc/uvm_examples/ex_mto_layering/e/ex_mto_layering_top.e b/lesson000X_mluvm_svsc/uvm_examples/ex_mto_layering/e/ex_mto_layering_top.e
index 6ce2761..17fc2db 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/ex_mto_layering/e/ex_mto_layering_top.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/ex_mto_layering/e/ex_mto_layering_top.e
@@ -1,18 +1,18 @@
-/*----------------------------------------------------------    
+/*----------------------------------------------------------
 File name   : ex_mto_layering_top.e
-Title       : Top file 
+Title       : Top file
 Project     : many to one layering example
 Created     : 2007
 Description : Imports the required files.
-Notes       : This is one of four layering examples: One to one, 
+Notes       : This is one of four layering examples: One to one,
             : One to many, Many to one and Many to many
-----------------------------------------------------------    
-Copyright (c) 2007 Cadence Design Systems, Inc. 
+----------------------------------------------------------
+Copyright (c) 2007 Cadence Design Systems, Inc.
 All rights reserved worldwide.
-Please refer to the terms and conditions in $IPCM_HOME 
-----------------------------------------------------------*/ 
+Please refer to the terms and conditions in $IPCM_HOME
+----------------------------------------------------------*/
+
 
- 
 
 <'
 
diff --git a/lesson000X_mluvm_svsc/uvm_examples/ex_mto_layering/e/ex_mto_layering_ul_pkt_env.e b/lesson000X_mluvm_svsc/uvm_examples/ex_mto_layering/e/ex_mto_layering_ul_pkt_env.e
index a873ade..b921dfd 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/ex_mto_layering/e/ex_mto_layering_ul_pkt_env.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/ex_mto_layering/e/ex_mto_layering_ul_pkt_env.e
@@ -1,18 +1,18 @@
-/*----------------------------------------------------------    
+/*----------------------------------------------------------
 File name   : ex_mto_layering_ul_pkt_env.e
-Title       : Defines the upper layer packet env 
+Title       : Defines the upper layer packet env
 Project     : many to one layering example
 Created     : 2007
-Description : Defines the upper layer packet env and its sequence, 
-            : item and driver. Defines the BFM and the interface method 
+Description : Defines the upper layer packet env and its sequence,
+            : item and driver. Defines the BFM and the interface method
             : to lower layer.
-Notes       : This is one of four layering examples: One to one, 
+Notes       : This is one of four layering examples: One to one,
             : One to many, Many to one and Many to many
-----------------------------------------------------------    
-Copyright (c) 2007 Cadence Design Systems, Inc. 
+----------------------------------------------------------
+Copyright (c) 2007 Cadence Design Systems, Inc.
 All rights reserved worldwide.
-Please refer to the terms and conditions in $IPCM_HOME 
-----------------------------------------------------------*/ 
+Please refer to the terms and conditions in $IPCM_HOME
+----------------------------------------------------------*/
 
 o The Packet:
 
@@ -22,7 +22,7 @@ define UL_MIN_SIZE 64;
 define UL_THRSH_SIZE 96;
 define UL_MAX_SIZE 512;
 
-// The packet struct is an abstract data type designed to 
+// The packet struct is an abstract data type designed to
 // demonstrate layering. It is not a part of any known protocol
 
 type ex_mto_layering_ul_pkt_length_t: [SHORT_P, LONG_P,ZERO_P];
@@ -34,7 +34,7 @@ struct ex_mto_layering_ul_pkt like any_sequence_item {
     keep length_range == SHORT_P => soft len in [UL_MIN_SIZE..UL_THRSH_SIZE];
     keep length_range == LONG_P => soft len in [UL_THRSH_SIZE+1..UL_MAX_SIZE];
     %payload[len]: list of byte;
-    
+
     nice_string(): string is also {
         result = append(result, " (", length_range, " ", len, ")");
     };
@@ -48,31 +48,31 @@ o The ul_pkt BFM:
 <'
 
 unit ex_mto_layering_ul_pkt_bfm_u like uvm_bfm {
-    
+
     // public interface
-    
+
     p_driver: ex_mto_layering_ul_pkt_driver_u;
-    
+
     event p_clock is cycle @sys.any;  	-- The ATM main clock
-    
+
     on p_clock {
         emit p_driver.clock;
     };
     // private interface
     driver_locker: locker;
-    -- An interface method to lower layer 
-    
+    -- An interface method to lower layer
+
     down_item_layer_transfer: in method_port of item_layer_transfer
                                                             is instance;
 
-    // This method try to get an item from the driver. 
-    // It calls try_next_item and not get_next_item so the driver is 
+    // This method try to get an item from the driver.
+    // It calls try_next_item and not get_next_item so the driver is
     // not blocked by any lower layer request
-    
+
     down_item_layer_transfer(stream_id: uint,
-                             remaining_bytes: uint): 
+                             remaining_bytes: uint):
                                  layering_data_struct_s @sys.any is {
-        
+
        driver_locker.lock(); // only one request can be active in each cycle;
         var ul_pkt_item: ex_mto_layering_ul_pkt;
         p_driver.stream_id = stream_id;
@@ -83,7 +83,7 @@ unit ex_mto_layering_ul_pkt_bfm_u like uvm_bfm {
             result.data = pack(NULL, ul_pkt_item);
             result.upper_layer_struct = ul_pkt_item;
             message(MEDIUM, "UL BFM gives an item to the lower layer");
-            emit p_driver.item_done; 
+            emit p_driver.item_done;
         } else { // no item from upper layer
             result = NULL;
         };
@@ -97,7 +97,7 @@ o Defining ul_pkt_sequence and hooking it up:
 
 <'
 -- Define ul_pkt_sequence, ul_pkt_sequence_kind and ul_pkt_driver
-sequence ex_mto_layering_ul_pkt_sequence using item=ex_mto_layering_ul_pkt, 
+sequence ex_mto_layering_ul_pkt_sequence using item=ex_mto_layering_ul_pkt,
     created_driver=ex_mto_layering_ul_pkt_driver_u;
 
 extend ex_mto_layering_ul_pkt_driver_u {
@@ -117,9 +117,9 @@ o The enclosing UL_PKT agent:
 <'
 
 unit ex_mto_layering_ul_pkt_agent_u like uvm_agent {
-    
+
     driver: ex_mto_layering_ul_pkt_driver_u is instance;
-    
+
     bfm: ex_mto_layering_ul_pkt_bfm_u is instance;
     keep bfm.p_driver == driver;
 };
@@ -134,11 +134,11 @@ unit ex_mto_layering_ul_pkt_env_u like uvm_env {
     -- One can also instantiate here an ul_pkt monitor unit, etc..
     logger    : message_logger is instance;
     file_logger      : message_logger  is instance;
-    
+
     keep soft file_logger.to_screen == FALSE;
     keep soft file_logger.to_file == "ul_pkt";
-    
-    agent: ex_mto_layering_ul_pkt_agent_u is instance;    
+
+    agent: ex_mto_layering_ul_pkt_agent_u is instance;
 };
 
 '>
diff --git a/lesson000X_mluvm_svsc/uvm_examples/ex_mto_layering/e/ex_mto_layering_ul_pkt_seq_lib.e b/lesson000X_mluvm_svsc/uvm_examples/ex_mto_layering/e/ex_mto_layering_ul_pkt_seq_lib.e
index fc6068d..e94f6b4 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/ex_mto_layering/e/ex_mto_layering_ul_pkt_seq_lib.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/ex_mto_layering/e/ex_mto_layering_ul_pkt_seq_lib.e
@@ -1,41 +1,41 @@
-/*----------------------------------------------------------    
+/*----------------------------------------------------------
 File name   : ex_mto_layering_ul_pkt_seq_lib.e
-Title       : upper layer packet sequence library 
+Title       : upper layer packet sequence library
 Project     : many to one layering example
 Created     : 2007
-Description : Defines reusable upper layer packet sequences for usage 
+Description : Defines reusable upper layer packet sequences for usage
             : in tests
-Notes       : This is one of four layering examples: One to one, 
+Notes       : This is one of four layering examples: One to one,
             : One to many, Many to one and Many to many
-----------------------------------------------------------    
-Copyright (c) 2007 Cadence Design Systems, Inc. 
+----------------------------------------------------------
+Copyright (c) 2007 Cadence Design Systems, Inc.
 All rights reserved worldwide.
-Please refer to the terms and conditions in $IPCM_HOME 
-----------------------------------------------------------*/ 
+Please refer to the terms and conditions in $IPCM_HOME
+----------------------------------------------------------*/
+
 
-    
 <'
-// this is an example for upper layer sequence. it does items only for the 
+// this is an example for upper layer sequence. it does items only for the
 // lower layer sequence with the same stream id
 
 extend ex_mto_layering_ul_pkt_sequence_kind: [LAYERED];
 
 extend LAYERED ex_mto_layering_ul_pkt_sequence {
     upper_layer_id: uint;
-    
+
     is_relevant(): bool is only {
         result = (upper_layer_id == driver.stream_id);
     };
-    // it is very important that all length calculations are done in the time 
+    // it is very important that all length calculations are done in the time
     // of item generation so no other working sequence can spoil the result.
     body() @driver.clock is {
         do ul_pkt keeping {
             driver.remaining_bytes < UL_MIN_SIZE => .length_range == ZERO_P;
-            driver.remaining_bytes <= UL_THRSH_SIZE and driver.remaining_bytes >= UL_MIN_SIZE => 
+            driver.remaining_bytes <= UL_THRSH_SIZE and driver.remaining_bytes >= UL_MIN_SIZE =>
                 .length_range in [ZERO_P,SHORT_P];
-            driver.remaining_bytes > UL_THRSH_SIZE => 
+            driver.remaining_bytes > UL_THRSH_SIZE =>
                 .length_range in [ZERO_P,SHORT_P,LONG_P];
-            .len <= driver.remaining_bytes            
+            .len <= driver.remaining_bytes
         };
     };
 };
@@ -53,13 +53,13 @@ extend LAYERED_LONG ex_mto_layering_ul_pkt_sequence {
     is_relevant(): bool is only {
         result = (upper_layer_id == driver.stream_id);
     };
-    
+
     body() @driver.clock is {
         do ul_pkt keeping {
             driver.remaining_bytes <= UL_THRSH_SIZE => .length_range == ZERO_P;
             driver.remaining_bytes > UL_THRSH_SIZE => .length_range == LONG_P;
-            .len <= driver.remaining_bytes            
-        };  
+            .len <= driver.remaining_bytes
+        };
     };
 };
 
@@ -77,15 +77,15 @@ extend LAYERED_SHORT ex_mto_layering_ul_pkt_sequence {
     is_relevant(): bool is only {
         result = (upper_layer_id == driver.stream_id);
     };
-    
+
     body() @driver.clock is {
         do ul_pkt keeping {
             driver.remaining_bytes < UL_MIN_SIZE => .length_range == ZERO_P;
             driver.remaining_bytes >= UL_MIN_SIZE => .length_range == SHORT_P;
-            .len <= driver.remaining_bytes            
-        };  
+            .len <= driver.remaining_bytes
+        };
     };
 };
-        
+
 
 '>
diff --git a/lesson000X_mluvm_svsc/uvm_examples/ex_mto_layering/examples/ex_mto_layering_test.e b/lesson000X_mluvm_svsc/uvm_examples/ex_mto_layering/examples/ex_mto_layering_test.e
index b605293..13a626f 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/ex_mto_layering/examples/ex_mto_layering_test.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/ex_mto_layering/examples/ex_mto_layering_test.e
@@ -1,30 +1,30 @@
-/*----------------------------------------------------------    
+/*----------------------------------------------------------
 File name   : ex_mto_layering_test.e
-Title       : example test file 
+Title       : example test file
 Project     : many to one layering example
 Created     : 2007
 Description : Defines test using layered sequences
             : Start 1 low layer sequence, and 10 upper layer
             : sequences. All id numbers are same, so the low
-            : layer sequence gets its items from all the 10 
+            : layer sequence gets its items from all the 10
             : upper layer sequences.
-Notes       : This is one of four layering examples: One to one, 
+Notes       : This is one of four layering examples: One to one,
             : One to many, Many to one and Many to many
-----------------------------------------------------------    
-Copyright (c) 2007 Cadence Design Systems, Inc. 
+----------------------------------------------------------
+Copyright (c) 2007 Cadence Design Systems, Inc.
 All rights reserved worldwide.
-Please refer to the terms and conditions in $IPCM_HOME 
-----------------------------------------------------------*/ 
- 
+Please refer to the terms and conditions in $IPCM_HOME
+----------------------------------------------------------*/
+
 <'
 import ex_mto_layering/e/ex_mto_layering_top.e;
 '>
 
-   
+
 <'
 
 extend MAIN system_sequence {
-   
+
    body() @driver.clock is only {
 
        all of {
@@ -38,10 +38,10 @@ extend MAIN system_sequence {
                    do LAYERED_LONG ul_pkt_sequence keeping {
                        .upper_layer_id == 1;
                    };
-               };  
+               };
            };
        };
-   };   
+   };
 };
 
 
diff --git a/lesson000X_mluvm_svsc/uvm_examples/ex_otm_layering/demo.ecom b/lesson000X_mluvm_svsc/uvm_examples/ex_otm_layering/demo.ecom
index 4c4107c..00b601c 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/ex_otm_layering/demo.ecom
+++ b/lesson000X_mluvm_svsc/uvm_examples/ex_otm_layering/demo.ecom
@@ -4,4 +4,4 @@ load ex_otm_layering/examples/ex_otm_layering_test
 trace sequence
 set message MEDIUM
 test
-    
\ No newline at end of file
+
diff --git a/lesson000X_mluvm_svsc/uvm_examples/ex_otm_layering/demo.sh b/lesson000X_mluvm_svsc/uvm_examples/ex_otm_layering/demo.sh
index 50cd8bd..7d4232d 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/ex_otm_layering/demo.sh
+++ b/lesson000X_mluvm_svsc/uvm_examples/ex_otm_layering/demo.sh
@@ -33,10 +33,10 @@ while [ $# -gt 0 ]; do
 	;;
       -run)
          quit_cmd="-c @$2"
-	
+
          shift
     esac
-    shift   
+    shift
 done
 #================================================================
 if [ $run_mode = batch ]; then
diff --git a/lesson000X_mluvm_svsc/uvm_examples/ex_otm_layering/e/ex_otm_layering_atm_env.e b/lesson000X_mluvm_svsc/uvm_examples/ex_otm_layering/e/ex_otm_layering_atm_env.e
index 182fe80..840a483 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/ex_otm_layering/e/ex_otm_layering_atm_env.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/ex_otm_layering/e/ex_otm_layering_atm_env.e
@@ -1,19 +1,19 @@
-/*----------------------------------------------------------    
+/*----------------------------------------------------------
 File name   : ex_otm_layering_atm_env.e
-Title       : Defines the lower layer (atm) env 
+Title       : Defines the lower layer (atm) env
 Project     : one to many layering example
 Created     : 2007
-Description : Defines the atm env, agent and its sequence, item and Driver 
-            : which also contains the interface for the upper layer. 
+Description : Defines the atm env, agent and its sequence, item and Driver
+            : which also contains the interface for the upper layer.
             : Defines the BFM.
-Notes       : This is one of four layering examples: One to one, 
+Notes       : This is one of four layering examples: One to one,
             : One to many, Many to one and Many to many
-----------------------------------------------------------    
-Copyright (c) 2007 Cadence Design Systems, Inc. 
+----------------------------------------------------------
+Copyright (c) 2007 Cadence Design Systems, Inc.
 All rights reserved worldwide.
-Please refer to the terms and conditions in $IPCM_HOME 
-----------------------------------------------------------*/ 
-    
+Please refer to the terms and conditions in $IPCM_HOME
+----------------------------------------------------------*/
+
 o The cell:
 
 <'
@@ -28,16 +28,16 @@ struct ex_otm_layering_atm_cell like any_sequence_item {
     kind: 	ex_otm_layering_atm_cell_kind;
     color: 	ex_otm_layering_atm_color;
     header: 	uint(bits:ATM_HEADER_LEN_BITS);
-    !header_list[ATM_HEADER_LEN]: list of byte; 
+    !header_list[ATM_HEADER_LEN]: list of byte;
     payload[ATM_PAYLOAD_LEN]: 	list of byte;
-    
+
     -- How to print it in the "trace sequence"/"show sequence" output
     nice_string(): string is also {
         return append(result, " (", kind, " ", color,")");
     };
-    
+
     is_relevant(): bool is {
-        // If change of back pressure value happened during generation 
+        // If change of back pressure value happened during generation
         // and the current item can not be sent to the DUT, it is held
         // until the back_pressure ceases. Other items (from other sequences)
         // are not blocked
@@ -45,7 +45,7 @@ struct ex_otm_layering_atm_cell like any_sequence_item {
         if not result then {
             message(MEDIUM, "backpressure is on. item not relevant");
         };
-    };  
+    };
 };
 
 '>
@@ -56,7 +56,7 @@ o The BFM:
 
 
 unit ex_otm_layering_atm_bfm_u like uvm_bfm {
-    
+
     // public interface
     !driver  : ex_otm_layering_atm_driver_u;
     d_enable : out simple_port of bit is instance;      // ports to the DUT
@@ -66,12 +66,12 @@ unit ex_otm_layering_atm_bfm_u like uvm_bfm {
     event a_clock is cycle @sys.any;  	// The ATM main clock
     event cell_started;			// start of transfer to DUT
     event cell_ended;			// end of transfer to DUT
-    
+
     on a_clock {
         emit driver.clock;
     };
-    
-    
+
+
     -- A method which sends the cell into the DUT
     transfer_cell_to_dut(cell: ex_otm_layering_atm_cell) @a_clock is {
         emit cell_started;
@@ -92,17 +92,17 @@ unit ex_otm_layering_atm_bfm_u like uvm_bfm {
         wait cycle;
         emit cell_ended;
         messagef(MEDIUM, "BFM finished sending atm data\n");
-        
+
     };
-    
-    // Back preassure value might change while next item is generated. 
+
+    // Back preassure value might change while next item is generated.
     detect_back_preassure() @a_clock is {
         while TRUE {
             driver.back_pressure_value = back_pressure$;
             wait[1];
         };
     };
-    
+
     pull_send_loop() @a_clock is {
         start detect_back_preassure();
         while TRUE {
@@ -111,12 +111,12 @@ unit ex_otm_layering_atm_bfm_u like uvm_bfm {
             emit driver.item_done;
         };
     };
-    
+
     run() is also {
         start pull_send_loop();
     };
-    
-    
+
+
 };
 '>
 
@@ -131,8 +131,8 @@ sequence ex_otm_layering_atm_sequence using item=ex_otm_layering_atm_cell, creat
 -- Extend the base type with essential fields
 extend ex_otm_layering_atm_sequence {
     !cell: ex_otm_layering_atm_cell;
-    get_item_from_upper_layer(stream_id : uint): 
-                                 layering_data_struct_s @driver.clock is {  
+    get_item_from_upper_layer(stream_id : uint):
+                                 layering_data_struct_s @driver.clock is {
         while result == NULL {
             result = driver.get_item_layer_transfer$(stream_id);
             if result == NULL then {
@@ -146,7 +146,7 @@ extend ex_otm_layering_atm_sequence {
 };
 
 
--- An interface method to upper layer 
+-- An interface method to upper layer
 
 extend ex_otm_layering_atm_driver_u {
     get_item_layer_transfer: out method_port of item_layer_transfer
@@ -165,11 +165,11 @@ o The enclosing ATM agent:
 <'
 
 unit ex_otm_layering_atm_agent_u like uvm_agent {
-    
+
     bfm    : ex_otm_layering_atm_bfm_u is instance;
     -- One can also instantiate here an ATM monitor unit, etc..
     driver : ex_otm_layering_atm_driver_u is instance;
-    
+
     connect_pointers() is also {
         bfm.driver = driver;
     };
@@ -181,26 +181,26 @@ o The enclosing ATM environment:
 <'
 
 unit ex_otm_layering_atm_env_u like uvm_env {
-    
+
     logger        : message_logger is instance;
     file_logger   : message_logger  is instance;
-    
+
     keep soft file_logger.to_screen == FALSE;
     keep soft file_logger.to_file == "atm";
     -- Instantiate a driver in the ATM env
-    
+
     evc_name : string;
     keep soft evc_name == "ATM ";
-    
+
     short_name(): string is only {
         return append(evc_name);
     };
-    
+
     atm_color : vt_style;
     keep atm_color  == DARK_PURPLE;
-    
+
     short_name_style(): vt_style is only {return atm_color;};
-    
+
     agent: ex_otm_layering_atm_agent_u is instance;
 };
 
diff --git a/lesson000X_mluvm_svsc/uvm_examples/ex_otm_layering/e/ex_otm_layering_atm_seq_lib.e b/lesson000X_mluvm_svsc/uvm_examples/ex_otm_layering/e/ex_otm_layering_atm_seq_lib.e
index f51b0b6..7446726 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/ex_otm_layering/e/ex_otm_layering_atm_seq_lib.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/ex_otm_layering/e/ex_otm_layering_atm_seq_lib.e
@@ -1,16 +1,16 @@
-/*----------------------------------------------------------    
+/*----------------------------------------------------------
 File name   : ex_otm_layering_packet_seq_lib.e
-Title       : packet sequence library 
+Title       : packet sequence library
 Project     : one to many layering example
 Created     : 2007
 Description : Defines reusable atm sequences for usage in tests
-Notes       : This is one of four layering examples: One to one, 
+Notes       : This is one of four layering examples: One to one,
             : One to many, Many to one and Many to many
-----------------------------------------------------------    
-Copyright (c) 2007 Cadence Design Systems, Inc. 
+----------------------------------------------------------
+Copyright (c) 2007 Cadence Design Systems, Inc.
 All rights reserved worldwide.
-Please refer to the terms and conditions in $IPCM_HOME 
-----------------------------------------------------------*/ 
+Please refer to the terms and conditions in $IPCM_HOME
+----------------------------------------------------------*/
 
 <'
 
@@ -19,16 +19,16 @@ define ATM_TIMEOUT 2000;
 extend ex_otm_layering_atm_sequence_kind: [LAYERED];
 
 extend LAYERED ex_otm_layering_atm_sequence {
-    
+
     atm_id: uint; // used for synchronizing with upper layer
-    atm_header : uint (bits:40); 
+    atm_header : uint (bits:40);
     // atm cells are 5 bytes header and 48 bytes cell
-    
+
     body() @driver.clock is only{
 
         var continue_work: bool;
-        continue_work = TRUE; 
-        
+        continue_work = TRUE;
+
         while continue_work { // while there are more upper layer items
             first of {
                 {
@@ -37,8 +37,8 @@ extend LAYERED ex_otm_layering_atm_sequence {
                     var size_of_cells: uint;
                     layering_struct = get_item_from_upper_layer(atm_id);
                     // gets upper layer item or stalls when there is none
-                    
-                    num_of_cells = 
+
+                    num_of_cells =
                         (layering_struct.data.size() - 1)/ ATM_PAYLOAD_LEN + 1;
                     // fragmentation computation and implementation
                     size_of_cells = num_of_cells * ATM_PAYLOAD_LEN;
@@ -51,8 +51,8 @@ extend LAYERED ex_otm_layering_atm_sequence {
                     };
                 };
                 {
-                    // time out for upper layer items (can be increased or 
-                    // decreased upon need) 
+                    // time out for upper layer items (can be increased or
+                    // decreased upon need)
                     // enables stop_run from virtual sequence
                     wait [ATM_TIMEOUT];
                     continue_work = FALSE;
@@ -65,14 +65,14 @@ extend LAYERED ex_otm_layering_atm_sequence {
 '>
 
 <'
-// this is an example for regular (non layered) atm sequence. 
+// this is an example for regular (non layered) atm sequence.
 // it can be called with no limitations during layered tests.
 
 extend ex_otm_layering_atm_sequence_kind: [ALL_RED];
 extend ALL_RED ex_otm_layering_atm_sequence {
 
     count: int[1..10];
-    
+
     body() @driver.clock is {
         for i from 1 to count {
             do cell keeping {.color == RED};
diff --git a/lesson000X_mluvm_svsc/uvm_examples/ex_otm_layering/e/ex_otm_layering_base.e b/lesson000X_mluvm_svsc/uvm_examples/ex_otm_layering/e/ex_otm_layering_base.e
index 743a3ef..d24f4ff 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/ex_otm_layering/e/ex_otm_layering_base.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/ex_otm_layering/e/ex_otm_layering_base.e
@@ -1,16 +1,16 @@
-/*----------------------------------------------------------    
+/*----------------------------------------------------------
 File name   : ex_otm_layering_base.e
-Title       : Defines the base types for layering 
+Title       : Defines the base types for layering
 Project     : one to many layering example
 Created     : 2007
-Description : Defines the method port for layering and the basic layering 
+Description : Defines the method port for layering and the basic layering
             : struct.
 Notes       : This is one of four layering examples: One to one, One to many,
             : Many to one and Many to many
-----------------------------------------------------------    
-Copyright (c) 2007 Cadence Design Systems, Inc. 
+----------------------------------------------------------
+Copyright (c) 2007 Cadence Design Systems, Inc.
 All rights reserved worldwide.
-Please refer to the terms and conditions in $IPCM_HOME 
+Please refer to the terms and conditions in $IPCM_HOME
 --
 
 o Layering interface declaration
@@ -19,7 +19,7 @@ o Layering interface declaration
 struct layering_data_struct_s {
     data: list of byte;             -- can also be list of bit for a more general data representation
 
-    upper_layer_struct: any_struct; -- can deliver structs across layers for user defined 
+    upper_layer_struct: any_struct; -- can deliver structs across layers for user defined
                                     -- application specific usage
 };
 
diff --git a/lesson000X_mluvm_svsc/uvm_examples/ex_otm_layering/e/ex_otm_layering_packet_env.e b/lesson000X_mluvm_svsc/uvm_examples/ex_otm_layering/e/ex_otm_layering_packet_env.e
index 43cd935..5fdb6d0 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/ex_otm_layering/e/ex_otm_layering_packet_env.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/ex_otm_layering/e/ex_otm_layering_packet_env.e
@@ -1,18 +1,18 @@
-/*----------------------------------------------------------    
+/*----------------------------------------------------------
 File name   : ex_otm_layering_packet_env.e
-Title       : Defines the upper layer (packet) env 
+Title       : Defines the upper layer (packet) env
 Project     : one to many layering example
 Created     : 2007
-Description : Defines the packet env, agent and its sequence, item and Driver. 
+Description : Defines the packet env, agent and its sequence, item and Driver.
             : Defines the BFM and the interface method to lower layer.
-Notes       : This is one of four layering examples: One to one, One to many, 
+Notes       : This is one of four layering examples: One to one, One to many,
             : Many to one and Many to many
-----------------------------------------------------------    
-Copyright (c) 2007 Cadence Design Systems, Inc. 
+----------------------------------------------------------
+Copyright (c) 2007 Cadence Design Systems, Inc.
 All rights reserved worldwide.
-Please refer to the terms and conditions in $IPCM_HOME 
-----------------------------------------------------------*/ 
-    
+Please refer to the terms and conditions in $IPCM_HOME
+----------------------------------------------------------*/
+
 o The Packet:
 
 <'
@@ -20,7 +20,7 @@ define PACKET_MAX_LEN 1518;
 define PACKET_MIN_LEN 64;
 define PACKET_THRSH_LEN 96;
 
-// The packet struct is an abstract data type designed to 
+// The packet struct is an abstract data type designed to
 // demonstrate layering.
 // It is not a part of any known protocol
 
@@ -31,12 +31,12 @@ struct ex_otm_layering_packet like any_sequence_item {
     kind : ex_otm_layering_packet_kind_t;
     length_range: ex_otm_layering_packet_length_t;
     len: uint;
-    keep length_range == SHORT_P => 
+    keep length_range == SHORT_P =>
                        soft len in [PACKET_MIN_LEN..PACKET_THRSH_LEN];
     keep length_range == LONG_P =>
                        soft len in [PACKET_THRSH_LEN + 1..PACKET_MAX_LEN];
     %payload[len]: list of byte;
-    
+
     nice_string(): string is also {
         result = append(result, " (",kind, " ", length_range, " ", len, ")");
     };
@@ -50,27 +50,27 @@ o The packet BFM:
 <'
 
 unit ex_otm_layering_packet_bfm_u like uvm_bfm {
-    
+
     // public interface
-    
+
     p_driver: ex_otm_layering_packet_driver_u;
-    
+
     event p_clock is cycle @sys.any;  	-- The ATM main clock
-    
+
     on p_clock {
         emit p_driver.clock;
     };
-    
-    -- An interface method to lower layer 
-    
+
+    -- An interface method to lower layer
+
     down_item_layer_transfer: in method_port of item_layer_transfer
                                                                is instance;
 
-    // This method tries to get an item from the driver. 
+    // This method tries to get an item from the driver.
     // It calls try_next_item and not get_next_item, so the driver is
     // not blocked by any lower layer request
-    
-    down_item_layer_transfer(stream_id: uint): 
+
+    down_item_layer_transfer(stream_id: uint):
                                  layering_data_struct_s @sys.any is {
         var packet_item: ex_otm_layering_packet;
         p_driver.stream_id = stream_id;
@@ -80,7 +80,7 @@ unit ex_otm_layering_packet_bfm_u like uvm_bfm {
             result.data = pack(NULL, packet_item);
             result.upper_layer_struct = packet_item;
             message(MEDIUM, "Packet BFM gives an item to the lower layer");
-            emit p_driver.item_done; 
+            emit p_driver.item_done;
         } else {
             result = NULL;
         };
@@ -113,7 +113,7 @@ o The enclosing PACKET agent:
 unit ex_otm_layering_packet_agent_u like uvm_agent {
 
     driver: ex_otm_layering_packet_driver_u is instance;
-    
+
     bfm: ex_otm_layering_packet_bfm_u is instance;
     keep bfm.p_driver == driver;
 };
@@ -129,10 +129,10 @@ unit ex_otm_layering_packet_env_u like uvm_env {
     -- One can also instantiate here an packet monitor unit, etc..
     logger    : message_logger is instance;
     file_logger      : message_logger  is instance;
-    
+
     keep soft file_logger.to_screen == FALSE;
     keep soft file_logger.to_file == "packet";
-    
+
     agent: ex_otm_layering_packet_agent_u is instance;
 
 };
diff --git a/lesson000X_mluvm_svsc/uvm_examples/ex_otm_layering/e/ex_otm_layering_packet_seq_lib.e b/lesson000X_mluvm_svsc/uvm_examples/ex_otm_layering/e/ex_otm_layering_packet_seq_lib.e
index f573df8..b5e72b7 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/ex_otm_layering/e/ex_otm_layering_packet_seq_lib.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/ex_otm_layering/e/ex_otm_layering_packet_seq_lib.e
@@ -1,20 +1,20 @@
-/*----------------------------------------------------------    
+/*----------------------------------------------------------
 File name   : ex_otm_layering_packet_seq_lib.e
-Title       : packet sequence library 
+Title       : packet sequence library
 Project     : one to many layering example
 Created     : 2007
 Description : Defines reusable packet sequences for usage in tests
 Notes       : This is one of four layering examples: One to one One to many,
             : Many to one and Many to many
-----------------------------------------------------------    
-Copyright (c) 2007 Cadence Design Systems, Inc. 
+----------------------------------------------------------
+Copyright (c) 2007 Cadence Design Systems, Inc.
 All rights reserved worldwide.
-Please refer to the terms and conditions in $IPCM_HOME 
-----------------------------------------------------------*/ 
+Please refer to the terms and conditions in $IPCM_HOME
+----------------------------------------------------------*/
+
 
-    
 <'
-// this is an example for upper layer sequence. it does items only for the 
+// this is an example for upper layer sequence. it does items only for the
 // lower layer sequence with the same stream id
 
 extend ex_otm_layering_packet_sequence_kind: [LAYERED];
@@ -24,7 +24,7 @@ extend LAYERED ex_otm_layering_packet_sequence {
     is_relevant(): bool is only {
         result = (upper_layer_id == driver.stream_id);
     };
-    
+
     body() @driver.clock is {
         do packet;
     };
@@ -43,7 +43,7 @@ extend LAYERED_LONG ex_otm_layering_packet_sequence {
     is_relevant(): bool is only {
         result = (upper_layer_id == driver.stream_id);
     };
-    
+
     body() @driver.clock is {
         do LONG_P packet;
     };
@@ -63,11 +63,11 @@ extend LAYERED_SHORT ex_otm_layering_packet_sequence {
     is_relevant(): bool is only {
         result = (upper_layer_id == driver.stream_id);
     };
-    
+
     body() @driver.clock is {
         do SHORT_P packet;
     };
 };
-        
+
 
 '>
diff --git a/lesson000X_mluvm_svsc/uvm_examples/ex_otm_layering/e/ex_otm_layering_system_env.e b/lesson000X_mluvm_svsc/uvm_examples/ex_otm_layering/e/ex_otm_layering_system_env.e
index 8ee2182..1c51325 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/ex_otm_layering/e/ex_otm_layering_system_env.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/ex_otm_layering/e/ex_otm_layering_system_env.e
@@ -1,24 +1,24 @@
-/*----------------------------------------------------------    
+/*----------------------------------------------------------
 File name   : ex_otm_layering_system_env.e
-Title       : Defines the system env 
+Title       : Defines the system env
 Project     : one to many layering example
 Created     : 2007
-Description : Defines the system env and its virtual Driver. 
+Description : Defines the system env and its virtual Driver.
             : Instansiates the two layers and binds them.
-Notes       : This is one of four layering examples: One to one, 
+Notes       : This is one of four layering examples: One to one,
             : One to many, Many to one and Many to many
-----------------------------------------------------------    
-Copyright (c) 2007 Cadence Design Systems, Inc. 
+----------------------------------------------------------
+Copyright (c) 2007 Cadence Design Systems, Inc.
 All rights reserved worldwide.
-Please refer to the terms and conditions in $IPCM_HOME 
-----------------------------------------------------------*/ 
+Please refer to the terms and conditions in $IPCM_HOME
+----------------------------------------------------------*/
 
 o disable MAIN BFM sequences:
 
 <'
 
 
-extend MAIN ex_otm_layering_packet_sequence {    
+extend MAIN ex_otm_layering_packet_sequence {
     keep soft count == 0;
 };
 
@@ -37,7 +37,7 @@ sequence system_sequence using created_driver = system_driver_u;
 extend system_sequence {
     !packet_sequence: ex_otm_layering_packet_sequence;
     !atm_sequence: ex_otm_layering_atm_sequence;
-    
+
     keep packet_sequence.driver == driver.packet_driver;
     keep atm_sequence.driver == driver.atm_driver;
 };
@@ -63,13 +63,13 @@ unit system_env_u like uvm_env {
 
     atm_env : ex_otm_layering_atm_env_u is instance;
     packet_env : ex_otm_layering_packet_env_u is instance;
-    
+
     system_driver: system_driver_u is instance;
 
     keep system_driver.packet_driver == packet_env.agent.driver;
-    
+
     keep system_driver.atm_driver == atm_env.agent.driver;
-    
+
     // binding the layeres together
     keep bind (atm_env.agent.driver.get_item_layer_transfer,
                packet_env.agent.bfm.down_item_layer_transfer);
@@ -77,14 +77,14 @@ unit system_env_u like uvm_env {
 
 // dummy unit for demonstration purpose
 unit dut_u {
-    back_pressure: out simple_port of byte is instance; // DUT port    
+    back_pressure: out simple_port of byte is instance; // DUT port
     d_enable: in simple_port of bit is instance; // DUT port
     d_bus: in simple_port of byte is instance;   // DUT port
 };
 
 extend sys {
     system_env : system_env_u is instance;
-    dut : dut_u is instance;    
+    dut : dut_u is instance;
     // binding the atm BFM to the DUT (empty in this example)
     keep bind (system_env.atm_env.agent.bfm.d_enable,dut.d_enable);
     keep bind (system_env.atm_env.agent.bfm.d_bus,dut.d_bus);
diff --git a/lesson000X_mluvm_svsc/uvm_examples/ex_otm_layering/e/ex_otm_layering_system_seq_lib.e b/lesson000X_mluvm_svsc/uvm_examples/ex_otm_layering/e/ex_otm_layering_system_seq_lib.e
index f2b9024..cf90cae 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/ex_otm_layering/e/ex_otm_layering_system_seq_lib.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/ex_otm_layering/e/ex_otm_layering_system_seq_lib.e
@@ -1,16 +1,16 @@
-/*----------------------------------------------------------    
+/*----------------------------------------------------------
 File name   : ex_otm_layering_system_seq_lib.e
-Title       : system level sequence library file 
+Title       : system level sequence library file
 Project     : one to many layering example
 Created     : 2007
 Description : Defines reusable system level sequences for usage in tests
-Notes       : This is one of four layering examples: One to one, One to many, 
+Notes       : This is one of four layering examples: One to one, One to many,
             : Many to one and Many to many
-----------------------------------------------------------    
-Copyright (c) 2007 Cadence Design Systems, Inc. 
+----------------------------------------------------------
+Copyright (c) 2007 Cadence Design Systems, Inc.
 All rights reserved worldwide.
-Please refer to the terms and conditions in $IPCM_HOME 
-----------------------------------------------------------*/ 
+Please refer to the terms and conditions in $IPCM_HOME
+----------------------------------------------------------*/
 <'
 
 // set stop condition for the test
@@ -18,7 +18,7 @@ extend MAIN system_sequence {
    pre_body() @sys.any is first {
        driver.raise_objection(TEST_DONE);
    };
-   
+
    post_body() @sys.any is also {
       wait [20] * cycle @driver.clock;
       driver.drop_objection(TEST_DONE);
diff --git a/lesson000X_mluvm_svsc/uvm_examples/ex_otm_layering/e/ex_otm_layering_top.e b/lesson000X_mluvm_svsc/uvm_examples/ex_otm_layering/e/ex_otm_layering_top.e
index 61e4d5e..22dfd87 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/ex_otm_layering/e/ex_otm_layering_top.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/ex_otm_layering/e/ex_otm_layering_top.e
@@ -1,16 +1,16 @@
-/*----------------------------------------------------------    
+/*----------------------------------------------------------
 File name   : ex_otm_layering_top.e
-Title       : Top file 
+Title       : Top file
 Project     : one to many layering example
 Created     : 2007
 Description : Imports the required files.
 Notes       : This is one of four layering examples: One to One, One to many,
             : Many to one and Many to many
-----------------------------------------------------------    
-Copyright (c) 2007 Cadence Design Systems, Inc. 
+----------------------------------------------------------
+Copyright (c) 2007 Cadence Design Systems, Inc.
 All rights reserved worldwide.
-Please refer to the terms and conditions in $IPCM_HOME 
-----------------------------------------------------------*/ 
+Please refer to the terms and conditions in $IPCM_HOME
+----------------------------------------------------------*/
 
 <'
 
diff --git a/lesson000X_mluvm_svsc/uvm_examples/ex_otm_layering/examples/ex_otm_layering_test.e b/lesson000X_mluvm_svsc/uvm_examples/ex_otm_layering/examples/ex_otm_layering_test.e
index 9333840..f8e4253 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/ex_otm_layering/examples/ex_otm_layering_test.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/ex_otm_layering/examples/ex_otm_layering_test.e
@@ -1,31 +1,31 @@
-/*----------------------------------------------------------    
+/*----------------------------------------------------------
 File name   : ex_otm_layering_test.e
-Title       : example test file 
+Title       : example test file
 Project     : one to many layering example
 Created     : 2007
 Description : Defines test using layered sequences
             : Starts 2 ATM sequences, and 2 packet sequences.
             : The sequences id numbers are constrained such that
-            : each ATM sequence gets its item from one of the 
+            : each ATM sequence gets its item from one of the
             : packet sequences.
 Notes       : This is one of four layering examples: One to one,
             : One to many, Many to one and Many to many
-----------------------------------------------------------    
-Copyright (c) 2007 Cadence Design Systems, Inc. 
+----------------------------------------------------------
+Copyright (c) 2007 Cadence Design Systems, Inc.
 All rights reserved worldwide.
-Please refer to the terms and conditions in $IPCM_HOME 
-----------------------------------------------------------*/ 
-    
+Please refer to the terms and conditions in $IPCM_HOME
+----------------------------------------------------------*/
+
 <'
 import ex_otm_layering/e/ex_otm_layering_top.e;
 '>
 
- 
-    
+
+
 <'
 
 extend MAIN system_sequence {
-   
+
    body() @driver.clock is only {
 
        all of {
@@ -38,7 +38,7 @@ extend MAIN system_sequence {
            {
                do LAYERED packet_sequence keeping {
                    .upper_layer_id == 1;
-               };  
+               };
            };
            {
                do LAYERED atm_sequence keeping {
@@ -49,10 +49,10 @@ extend MAIN system_sequence {
            {
                do LAYERED packet_sequence keeping {
                    .upper_layer_id == 2;
-               };  
+               };
            };
        };
-   };   
+   };
 };
 
 
diff --git a/lesson000X_mluvm_svsc/uvm_examples/ex_otm_layering/examples/ex_otm_layering_test_item_relevant.e b/lesson000X_mluvm_svsc/uvm_examples/ex_otm_layering/examples/ex_otm_layering_test_item_relevant.e
index 3f3d915..86ffed6 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/ex_otm_layering/examples/ex_otm_layering_test_item_relevant.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/ex_otm_layering/examples/ex_otm_layering_test_item_relevant.e
@@ -1,19 +1,19 @@
-/*----------------------------------------------------------    
+/*----------------------------------------------------------
 File name    : ex_otm_layering_test_item_relevant.e
-Title        : example test file 
+Title        : example test file
 Project      : one to many layering example
 Created      : 2007
-Description  : Defines test using layered sequences. A dummy DUT 
+Description  : Defines test using layered sequences. A dummy DUT
              : imitates a back-pressure, for demonstrating the item
              : post generation is_relevant
-Notes        : This is one of four layering examples: One to one, 
+Notes        : This is one of four layering examples: One to one,
              : One to many, Many to one and Many to many
-----------------------------------------------------------    
-Copyright (c) 2007 Cadence Design Systems, Inc. 
+----------------------------------------------------------
+Copyright (c) 2007 Cadence Design Systems, Inc.
 All rights reserved worldwide.
-Please refer to the terms and conditions in $IPCM_HOME 
-----------------------------------------------------------*/ 
- 
+Please refer to the terms and conditions in $IPCM_HOME
+----------------------------------------------------------*/
+
 <'
 import ex_otm_layering/e/ex_otm_layering_top.e;
 '>
@@ -43,15 +43,15 @@ extend dut_u {
 Time consuming generation:
 
 For better demonstration of the item post generation is_relevant,
-imitate time consuming generation. In the time the item is being 
-generation, back pressure status might be modified (and hence - 
+imitate time consuming generation. In the time the item is being
+generation, back pressure status might be modified (and hence -
 it_relevant status will change).
 
 <'
 extend ex_otm_layering_atm_sequence {
     pre_do(is_item: bool) @sys.any is also {
         if is_item then {
-            wait[5]; 
+            wait[5];
             // ... perform time consuming generation ...
         };
     };
@@ -59,7 +59,7 @@ extend ex_otm_layering_atm_sequence {
 
 
 extend MAIN system_sequence {
-   
+
    body() @driver.clock is only {
 
        all of {
@@ -73,11 +73,11 @@ extend MAIN system_sequence {
                for i from 0 to 3 {
                    do LAYERED packet_sequence keeping {
                        .upper_layer_id == 1;
-                   };  
+                   };
                };
            };
        };
-   };   
+   };
 };
 
 
diff --git a/lesson000X_mluvm_svsc/uvm_examples/ex_otm_layering/examples/ex_otm_layering_test_multi_layered.e b/lesson000X_mluvm_svsc/uvm_examples/ex_otm_layering/examples/ex_otm_layering_test_multi_layered.e
index 96b9691..4de5ef1 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/ex_otm_layering/examples/ex_otm_layering_test_multi_layered.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/ex_otm_layering/examples/ex_otm_layering_test_multi_layered.e
@@ -1,40 +1,40 @@
-/*----------------------------------------------------------    
+/*----------------------------------------------------------
 File name   : ex_otm_layering_test_multi_layered.e
-Title       : example test file 
+Title       : example test file
 Project     : one to many layering example
 Created     : 2007
 Description : Defines test using layered sequences
-            : Starts several sequences in parallel: 
-            :   4 sequences of the upper layer (packet) 
+            : Starts several sequences in parallel:
+            :   4 sequences of the upper layer (packet)
             :   3 sequences of the lower layer (ATM)
             : The sequences are constrained such that:
-            :    - layered ATM sequence id 1 gets items from 
-            :      three packet sequences 
-            :    - layered ATM sequence id 2 gets items from 
+            :    - layered ATM sequence id 1 gets items from
+            :      three packet sequences
+            :    - layered ATM sequence id 2 gets items from
             :      one packet sequence
             :    - ALL_RED frame sequence generates its own items
             :      (it is a low layer, but not a layered sequence)
-Notes       : This is one of four layering examples: One to one, 
+Notes       : This is one of four layering examples: One to one,
             : One to many, Many to one and Many to many
-----------------------------------------------------------    
-Copyright (c) 2007 Cadence Design Systems, Inc. 
+----------------------------------------------------------
+Copyright (c) 2007 Cadence Design Systems, Inc.
 All rights reserved worldwide.
-Please refer to the terms and conditions in $IPCM_HOME 
-----------------------------------------------------------*/ 
-    
+Please refer to the terms and conditions in $IPCM_HOME
+----------------------------------------------------------*/
+
 <'
 import ex_otm_layering/e/ex_otm_layering_top.e;
 '>
 
- 
+
 <'
 
 extend MAIN system_sequence {
-   
+
    body() @driver.clock is only {
 
        all of {
-           // id 1 layered scenario 
+           // id 1 layered scenario
            {
                do LAYERED atm_sequence keeping {
                    .atm_id == 1;
@@ -45,19 +45,19 @@ extend MAIN system_sequence {
            {
                do LAYERED_LONG packet_sequence keeping {
                    .upper_layer_id == 1;
-               };  
-               
+               };
+
                do LAYERED_SHORT packet_sequence keeping {
                    .upper_layer_id == 1;
-               };  
-               
+               };
+
                do LAYERED_LONG packet_sequence keeping {
                    .upper_layer_id == 1;
-               };  
-               
+               };
+
                message(HIGH,"PACKET LAYERED1 done");
            };
-           // id 2 layered scenario 
+           // id 2 layered scenario
            {
                do LAYERED atm_sequence keeping {
                    .atm_id == 2;
@@ -68,16 +68,16 @@ extend MAIN system_sequence {
            {
                do LAYERED packet_sequence keeping {
                    .upper_layer_id == 2;
-               };  
+               };
                message(HIGH,"PACKET LAYERED2 done");
            };
-           // "independent" ATM sequence 
+           // "independent" ATM sequence
            {
                do ALL_RED atm_sequence;
                message(HIGH,"ATM UN-LAYERED done");
            };
        };
-   };   
+   };
 };
 
 
diff --git a/lesson000X_mluvm_svsc/uvm_examples/ex_otm_layering/examples/ex_otm_layering_test_simple.e b/lesson000X_mluvm_svsc/uvm_examples/ex_otm_layering/examples/ex_otm_layering_test_simple.e
index aae97bc..f99ea43 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/ex_otm_layering/examples/ex_otm_layering_test_simple.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/ex_otm_layering/examples/ex_otm_layering_test_simple.e
@@ -1,19 +1,19 @@
-/*----------------------------------------------------------    
+/*----------------------------------------------------------
 File name   : ex_otm_layering_test_simple.e
-Title       : example test file 
+Title       : example test file
 Project     : one to many layering example
 Created     : 2007
 Description : Defines test using layered sequences
-            : Two sequences, one ATM (lower layer) sequence, getting 
+            : Two sequences, one ATM (lower layer) sequence, getting
             : its items from one Packet (upper layer) sequence.
 Notes       : This is one of four layering examples: One to one,
             : One to many, Many to one and Many to many
-----------------------------------------------------------    
-Copyright (c) 2007 Cadence Design Systems, Inc. 
+----------------------------------------------------------
+Copyright (c) 2007 Cadence Design Systems, Inc.
 All rights reserved worldwide.
-Please refer to the terms and conditions in $IPCM_HOME 
-----------------------------------------------------------*/ 
-    
+Please refer to the terms and conditions in $IPCM_HOME
+----------------------------------------------------------*/
+
 <'
 import ex_otm_layering/e/ex_otm_layering_top.e;
 '>
@@ -21,7 +21,7 @@ import ex_otm_layering/e/ex_otm_layering_top.e;
 <'
 
 extend MAIN system_sequence {
-   
+
    body() @driver.clock is only {
 
        all of {
@@ -34,10 +34,10 @@ extend MAIN system_sequence {
            {
                do LAYERED packet_sequence keeping {
                    .upper_layer_id == 1;
-               };  
+               };
            };
        };
-   };   
+   };
 };
 
 
diff --git a/lesson000X_mluvm_svsc/uvm_examples/ex_oto_layering/demo.ecom b/lesson000X_mluvm_svsc/uvm_examples/ex_oto_layering/demo.ecom
index 9be0d34..ea99d78 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/ex_oto_layering/demo.ecom
+++ b/lesson000X_mluvm_svsc/uvm_examples/ex_oto_layering/demo.ecom
@@ -4,4 +4,4 @@ load ex_oto_layering/examples/ex_oto_layering_test
 trace sequence
 set message MEDIUM
 test
-    
\ No newline at end of file
+
diff --git a/lesson000X_mluvm_svsc/uvm_examples/ex_oto_layering/demo.sh b/lesson000X_mluvm_svsc/uvm_examples/ex_oto_layering/demo.sh
index 1d3975b..497d15a 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/ex_oto_layering/demo.sh
+++ b/lesson000X_mluvm_svsc/uvm_examples/ex_oto_layering/demo.sh
@@ -33,10 +33,10 @@ while [ $# -gt 0 ]; do
 	;;
       -run)
          quit_cmd="-c @$2"
-	
+
          shift
     esac
-    shift   
+    shift
 done
 #================================================================
 if [ $run_mode = batch ]; then
diff --git a/lesson000X_mluvm_svsc/uvm_examples/ex_oto_layering/e/ex_oto_layering_base.e b/lesson000X_mluvm_svsc/uvm_examples/ex_oto_layering/e/ex_oto_layering_base.e
index d261dc8..39c7e56 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/ex_oto_layering/e/ex_oto_layering_base.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/ex_oto_layering/e/ex_oto_layering_base.e
@@ -1,34 +1,34 @@
-/*----------------------------------------------------------    
+/*----------------------------------------------------------
 File name   : ex_oto_layering_base.e
-Title       : Defines the base types for layering 
+Title       : Defines the base types for layering
 Project     : one to one layering example
 Created     : 2007
-Description : Defines the method port for layering and the basic 
+Description : Defines the method port for layering and the basic
             : layering struct.
 Notes       : This is one of four layering examples: One to one,
             : One to many, Many to one and Many to many
-----------------------------------------------------------    
-Copyright (c) 2007 Cadence Design Systems, Inc. 
+----------------------------------------------------------
+Copyright (c) 2007 Cadence Design Systems, Inc.
 All rights reserved worldwide.
-Please refer to the terms and conditions in $IPCM_HOME 
-----------------------------------------------------------*/ 
+Please refer to the terms and conditions in $IPCM_HOME
+----------------------------------------------------------*/
 
 
 o Layering interface declaration
 
 <'
 struct layering_data_struct_s {
-    data: list of byte;             
+    data: list of byte;
     -- can also be list of bit for a more general data representation
 
-    upper_layer_struct: any_struct; 
-    -- can deliver structs across layers for user defined 
+    upper_layer_struct: any_struct;
+    -- can deliver structs across layers for user defined
     -- application specific usage
 };
 
-method_type 
+method_type
     item_layer_transfer(stream_id: uint):layering_data_struct_s @sys.any;
-method_type 
+method_type
     check_do_available(stream_id: uint): bool;
 
 '>
diff --git a/lesson000X_mluvm_svsc/uvm_examples/ex_oto_layering/e/ex_oto_layering_frame_env.e b/lesson000X_mluvm_svsc/uvm_examples/ex_oto_layering/e/ex_oto_layering_frame_env.e
index 32ea9b2..a2b599c 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/ex_oto_layering/e/ex_oto_layering_frame_env.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/ex_oto_layering/e/ex_oto_layering_frame_env.e
@@ -1,26 +1,26 @@
-/*----------------------------------------------------------    
+/*----------------------------------------------------------
 File name   : ex_oto_layering_ll_frame_env.e
-Title       : Defines the lower layer env 
+Title       : Defines the lower layer env
 Project     : one to one layering example
 Created     : 2007
-Description : Defines the lower layer env, data-item (frame), bfm,  
+Description : Defines the lower layer env, data-item (frame), bfm,
             : driver, sequence.
             :
-            : The main part in this file is the 
+            : The main part in this file is the
             : oto_ll_frame_driver_u and its methods:
             :   out method_port ll_check_do_available
             :   out method_port get_item_layer_transfer
             :   method get_item_from_upper_layer
-            :      Gets item from upper layer, via the 
-            :      get_item_layer_transfer port. 
+            :      Gets item from upper layer, via the
+            :      get_item_layer_transfer port.
             :
 Notes       : This is one of four layering examples: One to one,
             : One to many, Many to one and Many to many
-----------------------------------------------------------    
-Copyright (c) 2007 Cadence Design Systems, Inc. 
+----------------------------------------------------------
+Copyright (c) 2007 Cadence Design Systems, Inc.
 All rights reserved worldwide.
-Please refer to the terms and conditions in $IPCM_HOME 
-----------------------------------------------------------*/ 
+Please refer to the terms and conditions in $IPCM_HOME
+----------------------------------------------------------*/
 
 o The frame:
 
@@ -33,9 +33,9 @@ struct ex_oto_layering_frame_s like any_sequence_item {
     color: 	ex_oto_layering_frame_color;
     source_address: 	   uint(bits:ADDRESS_LEN_BITS);
     destination_address:   uint(bits:ADDRESS_LEN_BITS);
-    !header_list[HEADER_LEN]: list of byte; 
+    !header_list[HEADER_LEN]: list of byte;
     payload: 	list of byte;
-    
+
     -- How to print it in the "trace sequence"/"show sequence" output
     nice_string(): string is also {
         return append(result, " (", color,")");
@@ -50,22 +50,22 @@ o The BFM:
 
 
 unit ex_oto_layering_frame_bfm_u like uvm_bfm {
-    
+
     // public interface
     d_enable: out simple_port of bit is instance; // ports to the DUT
     d_bus: out simple_port of byte is instance;   // ports to the DUT
-    
+
     event a_clock is cycle @sys.any;  	-- The FRAME main clock
     event frame_started;			-- start of transfer to DUT
     event frame_ended;			-- end of transfer to DUT
 
     driver:ex_oto_layering_frame_driver_u;
-    
+
     on a_clock {
         emit driver.clock;
     };
-    
-    
+
+
     -- A method which sends the frame into the DUT
     transfer_frame_to_dut(frame: ex_oto_layering_frame_s) @a_clock is {
         emit frame_started;
@@ -88,9 +88,9 @@ unit ex_oto_layering_frame_bfm_u like uvm_bfm {
         wait cycle;
         emit frame_ended;
         messagef(MEDIUM,"Finished sending frame data\n");
-        
+
     };
-    
+
     pull_send_loop() @a_clock is {
         while TRUE {
             var frame := driver.get_next_item();
@@ -98,12 +98,12 @@ unit ex_oto_layering_frame_bfm_u like uvm_bfm {
             emit driver.item_done;
         };
     };
-    
+
     run() is also {
         start pull_send_loop();
     };
-    
-    
+
+
 };
 '>
 
@@ -113,7 +113,7 @@ o Defining frame_sequence and hooking it up:
 <'
 
 -- Define frame_sequence, frame_sequence_kind and frame_driver
-sequence ex_oto_layering_frame_sequence using item=ex_oto_layering_frame_s, 
+sequence ex_oto_layering_frame_sequence using item=ex_oto_layering_frame_s,
     created_driver=ex_oto_layering_frame_driver_u;
 
 -- Extend the base type with essential fields
@@ -122,19 +122,19 @@ extend ex_oto_layering_frame_sequence {
 };
 
 
--- An interface method to upper layer 
+-- An interface method to upper layer
 
 extend ex_oto_layering_frame_driver_u {
     ll_check_do_available   : out method_port of check_do_available
-                                                              is instance; 
+                                                              is instance;
     get_item_layer_transfer : out method_port of item_layer_transfer
                                                               is instance;
-    
+
     // get_item_from_upper_layer()
     //
     get_item_from_upper_layer(stream_id : uint):
-                              layering_data_struct_s @clock is {  
-        
+                              layering_data_struct_s @clock is {
+
         while result == NULL {
             result = get_item_layer_transfer$(stream_id);
             if result == NULL then {
@@ -157,7 +157,7 @@ o The enclosing FRAME agent:
 <'
 
 unit ex_oto_layering_frame_agent_u like uvm_agent {
-    
+
     bfm: ex_oto_layering_frame_bfm_u is instance;
     -- One can also instantiate here an FRAME monitor unit, etc..
     driver: ex_oto_layering_frame_driver_u is instance;
@@ -171,27 +171,27 @@ o The enclosing FRAME environment:
 <'
 
 unit ex_oto_layering_frame_env_u like uvm_env {
-    
+
     logger    : message_logger is instance;
     file_logger      : message_logger  is instance;
-    
+
     keep soft file_logger.to_screen == FALSE;
     keep soft file_logger.to_file == "frame";
     -- Instantiate a driver in the FRAME env
-    
+
     evc_name : string;
     keep soft evc_name == "FRAME ";
-    
+
     short_name(): string is only {
         return append(evc_name);
     };
-    
+
     frame_color : vt_style;
     keep frame_color  == DARK_PURPLE;
-    
+
     short_name_style(): vt_style is only {return frame_color;};
 
-    agent: ex_oto_layering_frame_agent_u is instance;    
+    agent: ex_oto_layering_frame_agent_u is instance;
 };
 
 '>
diff --git a/lesson000X_mluvm_svsc/uvm_examples/ex_oto_layering/e/ex_oto_layering_frame_seq_lib.e b/lesson000X_mluvm_svsc/uvm_examples/ex_oto_layering/e/ex_oto_layering_frame_seq_lib.e
index 63bca9c..489c87b 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/ex_oto_layering/e/ex_oto_layering_frame_seq_lib.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/ex_oto_layering/e/ex_oto_layering_frame_seq_lib.e
@@ -1,61 +1,61 @@
-/*----------------------------------------------------------    
+/*----------------------------------------------------------
 File name   : ex_oto_layering_frame_seq_lib.e
-Title       : frame sequence library 
+Title       : frame sequence library
 Project     : one to one layering example
 Created     : 2007
 Description : Defines reusable frame sequences for usage in tests
 Notes       : This is one of four layering examples: One to one,
             : One to many, Many to one and Many to many
-----------------------------------------------------------    
-Copyright (c) 2007 Cadence Design Systems, Inc. 
+----------------------------------------------------------
+Copyright (c) 2007 Cadence Design Systems, Inc.
 All rights reserved worldwide.
-Please refer to the terms and conditions in $IPCM_HOME 
-----------------------------------------------------------*/ 
+Please refer to the terms and conditions in $IPCM_HOME
+----------------------------------------------------------*/
+
 
 
-  
 
 <'
 extend ex_oto_layering_frame_sequence_kind: [LAYERED];
 
 extend LAYERED ex_oto_layering_frame_sequence {
     ll_id: uint; // used for synchronizing with upper layer
-    destination_address : uint (bits:48); 
-    source_address : uint (bits:48); 
+    destination_address : uint (bits:48);
+    source_address : uint (bits:48);
     !frame_payload: list of byte;
-    
+
     is_relevant() : bool is {
         result = driver.ll_check_do_available$(ll_id);
     };
-        
+
     body() @driver.clock is only{
 
         var continue_work: bool;
-        continue_work = TRUE; 
-        
+        continue_work = TRUE;
+
         while continue_work { // while there are more upper layer items
             first of {
                 {
-                    
+
                     driver.wait_for_grant(me);
-                    
+
                     var layering_struct: layering_data_struct_s;
                     layering_struct = driver.get_item_from_upper_layer(ll_id);
-                    // gets upper layer item or stalls when there is none          
+                    // gets upper layer item or stalls when there is none
                     frame_payload = pack(NULL,layering_struct.data);
-                    
+
                     gen frame keeping {
                         .payload == frame_payload;
                         .destination_address == destination_address;
                         .source_address == source_address;
                     };
-                    
+
                     driver.deliver_item(frame);
-                    
+
                 };
                 {
-                    // time out for upper layer items (can be increased or 
-                    // decreased upon need) 
+                    // time out for upper layer items (can be increased or
+                    // decreased upon need)
                     // enables stop_run from virtual sequence
                     wait [2000];
                     continue_work = FALSE;
@@ -68,14 +68,14 @@ extend LAYERED ex_oto_layering_frame_sequence {
 '>
 
 <'
-// this is an example for regular (non layered) frame sequence. 
+// this is an example for regular (non layered) frame sequence.
 // it can be called with no limitations during layered tests.
 
 extend ex_oto_layering_frame_sequence_kind: [ALL_RED];
 extend ALL_RED ex_oto_layering_frame_sequence {
 
     count: int[1..10];
-    
+
     body() @driver.clock is {
         for i from 1 to count {
             do frame keeping {.color == RED};
diff --git a/lesson000X_mluvm_svsc/uvm_examples/ex_oto_layering/e/ex_oto_layering_frame_seq_lib_using_pre_do.e b/lesson000X_mluvm_svsc/uvm_examples/ex_oto_layering/e/ex_oto_layering_frame_seq_lib_using_pre_do.e
index f08dd47..1249f79 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/ex_oto_layering/e/ex_oto_layering_frame_seq_lib_using_pre_do.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/ex_oto_layering/e/ex_oto_layering_frame_seq_lib_using_pre_do.e
@@ -1,46 +1,46 @@
-/*----------------------------------------------------------    
+/*----------------------------------------------------------
 File name   : ex_oto_layering_frame_seq_lib_using_pre_do.e
-Title       : frame sequence library 
+Title       : frame sequence library
 Project     : one to one layering example
 Created     : 2007
 Description : Defines reusable frame sequences for usage in tests
-Notes       : This file implements the ml pkt using the older sequences 
+Notes       : This file implements the ml pkt using the older sequences
             : mechanism, which did not have deliver_item.
             : So building the item is implemented in the pre_do()
-----------------------------------------------------------    
-Copyright (c) 2007 Cadence Design Systems, Inc. 
+----------------------------------------------------------
+Copyright (c) 2007 Cadence Design Systems, Inc.
 All rights reserved worldwide.
-Please refer to the terms and conditions in $IPCM_HOME 
-----------------------------------------------------------*/ 
+Please refer to the terms and conditions in $IPCM_HOME
+----------------------------------------------------------*/
+
 
-  
 <'
 extend ex_oto_layering_frame_sequence_kind: [LAYERED];
 
 extend LAYERED ex_oto_layering_frame_sequence {
     ll_id: uint; // used for synchronizing with upper layer
-    destination_address : uint (bits:48); 
-    source_address : uint (bits:48); 
+    destination_address : uint (bits:48);
+    source_address : uint (bits:48);
     !frame_payload: list of byte;
-    
+
     is_relevant() : bool is {
         result = driver.ll_check_do_available$(ll_id);
     };
-        
+
     pre_do(is_item: bool) @sys.any is {
         if is_item {
             var layering_struct: layering_data_struct_s;
             layering_struct = driver.get_item_from_upper_layer(ll_id);
-            // gets upper layer item or stalls when there is none          
+            // gets upper layer item or stalls when there is none
             frame_payload = pack(NULL,layering_struct.data);
         };
     };
-    
+
     body() @driver.clock is only{
 
         var continue_work: bool;
-        continue_work = TRUE; 
-        
+        continue_work = TRUE;
+
         while continue_work { // while there are more upper layer items
             first of {
                 {
@@ -51,8 +51,8 @@ extend LAYERED ex_oto_layering_frame_sequence {
                     };
                 };
                 {
-                    // time out for upper layer items (can be increased or 
-                    // decreased upon need) 
+                    // time out for upper layer items (can be increased or
+                    // decreased upon need)
                     // enables stop_run from virtual sequence
                     wait [2000];
                     continue_work = FALSE;
@@ -65,14 +65,14 @@ extend LAYERED ex_oto_layering_frame_sequence {
 '>
 
 <'
-// this is an example for regular (non layered) frame sequence. 
+// this is an example for regular (non layered) frame sequence.
 // it can be called with no limitations during layered tests.
 
 extend ex_oto_layering_frame_sequence_kind: [ALL_RED];
 extend ALL_RED ex_oto_layering_frame_sequence {
 
     count: int[1..10];
-    
+
     body() @driver.clock is {
         for i from 1 to count {
             do frame keeping {.color == RED};
@@ -82,4 +82,4 @@ extend ALL_RED ex_oto_layering_frame_sequence {
 
 '>
 
-  
+
diff --git a/lesson000X_mluvm_svsc/uvm_examples/ex_oto_layering/e/ex_oto_layering_packet_env.e b/lesson000X_mluvm_svsc/uvm_examples/ex_oto_layering/e/ex_oto_layering_packet_env.e
index 190bd4f..c53571d 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/ex_oto_layering/e/ex_oto_layering_packet_env.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/ex_oto_layering/e/ex_oto_layering_packet_env.e
@@ -1,29 +1,29 @@
-/*----------------------------------------------------------    
+/*----------------------------------------------------------
 File name   : ex_oto_layering_ul_packet_env.e
-Title       : Defines the upper layer env 
+Title       : Defines the upper layer env
 Project     : one to one layering example
 Created     : 2007
-Description : Defines the packet env, agent and its sequence, item and 
-            : Driver. 
-            : In the agent, defines the BFM and the interface method to 
+Description : Defines the packet env, agent and its sequence, item and
+            : Driver.
+            : In the agent, defines the BFM and the interface method to
             : lower layer.
-            : The main parts in this file are the BFM and its ports 
+            : The main parts in this file are the BFM and its ports
             : and methods
             :   in method_port down_item_layer_transfer
-            :   in method_port ul_check_do_available 
+            :   in method_port ul_check_do_available
 Notes       : This is one of four layering examples: One to one,
             : One to many, Many to one and Many to many
-----------------------------------------------------------    
-Copyright (c) 2007 Cadence Design Systems, Inc. 
+----------------------------------------------------------
+Copyright (c) 2007 Cadence Design Systems, Inc.
 All rights reserved worldwide.
-Please refer to the terms and conditions in $IPCM_HOME 
-----------------------------------------------------------*/ 
+Please refer to the terms and conditions in $IPCM_HOME
+----------------------------------------------------------*/
+
 
-    
 o The Packet:
 
 <'
-// The packet struct is an abstract data type designed to 
+// The packet struct is an abstract data type designed to
 // demonstrate layering. It is not a part of any known protocol
 define PACKET_MIN_LEN 64;
 define PACKET_THRSH_LEN 96;
@@ -36,12 +36,12 @@ struct ex_oto_layering_packet like any_sequence_item {
     kind : ex_oto_layering_packet_kind_t;
     length_range: ex_oto_layering_packet_length_t;
     len: uint;
-    keep length_range == SHORT_P => soft len in 
+    keep length_range == SHORT_P => soft len in
         [PACKET_MIN_LEN..PACKET_THRSH_LEN];
-    keep length_range == LONG_P => soft len in 
+    keep length_range == LONG_P => soft len in
         [PACKET_THRSH_LEN + 1 ..PACKET_MAX_LEN];
     %payload[len]: list of byte;
-    
+
     nice_string(): string is also {
         result = append(result, " (",kind, " ", length_range, " ", len, ")");
     };
@@ -55,28 +55,28 @@ o The packet BFM:
 <'
 
 unit ex_oto_layering_packet_bfm_u like uvm_bfm {
-    
+
     // public interface
-    
+
     p_driver: ex_oto_layering_packet_driver_u;
-    
+
     event p_clock is cycle @sys.any;  	-- The ATM main clock
-    
+
     on p_clock {
         emit p_driver.clock;
     };
-    
-    -- An interface method to lower layer 
-    
+
+    -- An interface method to lower layer
+
     down_item_layer_transfer: in method_port of item_layer_transfer
                                                             is instance;
-    // This method tries to get an item from the driver. 
+    // This method tries to get an item from the driver.
     // It calls try_next_item and not get_next_item, so the driver
     // is not blocked by any lower layer request
-    
+
     down_item_layer_transfer(stream_id: uint):
                      layering_data_struct_s @sys.any is {
-        
+
         var packet_item: ex_oto_layering_packet;
         p_driver.stream_id = stream_id;
         packet_item = p_driver.try_next_item();
@@ -85,7 +85,7 @@ unit ex_oto_layering_packet_bfm_u like uvm_bfm {
             result.data = pack(NULL, packet_item);
             result.upper_layer_struct = packet_item;
             message(MEDIUM, "Packet BFM gives an item to the lower layer");
-            emit p_driver.item_done; 
+            emit p_driver.item_done;
         } else {
             result = NULL;
         };
@@ -104,7 +104,7 @@ o Defining packet_sequence and hooking it up:
 
 <'
 -- Define packet_sequence, packet_sequence_kind and packet_driver
-sequence ex_oto_layering_packet_sequence using item=ex_oto_layering_packet, 
+sequence ex_oto_layering_packet_sequence using item=ex_oto_layering_packet,
     created_driver=ex_oto_layering_packet_driver_u;
 
 extend ex_oto_layering_packet_driver_u {
@@ -125,9 +125,9 @@ o The enclosing PACKET agent:
 unit ex_oto_layering_packet_agent_u like uvm_agent {
 
     driver: ex_oto_layering_packet_driver_u is instance;
-    
+
     bfm: ex_oto_layering_packet_bfm_u is instance;
-    
+
     keep bfm.p_driver == driver;
 };
 
@@ -141,11 +141,11 @@ unit ex_oto_layering_packet_env_u like any_env {
     -- One can also instantiate here an packet monitor unit, etc..
     logger    : message_logger is instance;
     file_logger      : message_logger  is instance;
-    
+
     keep soft file_logger.to_screen == FALSE;
     keep soft file_logger.to_file == "packet";
-    
-    agent: ex_oto_layering_packet_agent_u is instance;    
+
+    agent: ex_oto_layering_packet_agent_u is instance;
 };
 
 '>
diff --git a/lesson000X_mluvm_svsc/uvm_examples/ex_oto_layering/e/ex_oto_layering_packet_seq_lib.e b/lesson000X_mluvm_svsc/uvm_examples/ex_oto_layering/e/ex_oto_layering_packet_seq_lib.e
index 21b02cd..1e87a05 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/ex_oto_layering/e/ex_oto_layering_packet_seq_lib.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/ex_oto_layering/e/ex_oto_layering_packet_seq_lib.e
@@ -1,22 +1,22 @@
-/*----------------------------------------------------------    
+/*----------------------------------------------------------
 File name   : ex_oto_layering_packet_seq_lib.e
-Title       : packet sequence library 
+Title       : packet sequence library
 Project     : one to one layering example
 Created     : 2007
 Description : Defines reusable packet sequences for usage in tests
 Notes       : This is one of four layering examples: One to one,
             : One to many, Many to one and Many to many
-----------------------------------------------------------    
-Copyright (c) 2007 Cadence Design Systems, Inc. 
+----------------------------------------------------------
+Copyright (c) 2007 Cadence Design Systems, Inc.
 All rights reserved worldwide.
-Please refer to the terms and conditions in $IPCM_HOME 
-----------------------------------------------------------*/ 
+Please refer to the terms and conditions in $IPCM_HOME
+----------------------------------------------------------*/
+
+
 
-  
 
-    
 <'
-// this is an example for upper layer sequence. it does items only for the 
+// this is an example for upper layer sequence. it does items only for the
 // lower layer sequence with the same stream id
 
 extend ex_oto_layering_packet_sequence_kind: [LAYERED];
@@ -26,7 +26,7 @@ extend LAYERED ex_oto_layering_packet_sequence {
     is_relevant(): bool is only {
         result = (upper_layer_id == driver.stream_id);
     };
-    
+
     body() @driver.clock is {
         do packet;
     };
@@ -45,7 +45,7 @@ extend LAYERED_LONG ex_oto_layering_packet_sequence {
     is_relevant(): bool is only {
         result = (upper_layer_id == driver.stream_id);
     };
-    
+
     body() @driver.clock is {
         do LONG_P packet;
     };
@@ -65,11 +65,11 @@ extend LAYERED_SHORT ex_oto_layering_packet_sequence {
     is_relevant(): bool is only {
         result = (upper_layer_id == driver.stream_id);
     };
-    
+
     body() @driver.clock is {
         do SHORT_P packet;
     };
 };
-        
+
 
 '>
diff --git a/lesson000X_mluvm_svsc/uvm_examples/ex_oto_layering/e/ex_oto_layering_system_env.e b/lesson000X_mluvm_svsc/uvm_examples/ex_oto_layering/e/ex_oto_layering_system_env.e
index 428617a..e09d702 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/ex_oto_layering/e/ex_oto_layering_system_env.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/ex_oto_layering/e/ex_oto_layering_system_env.e
@@ -1,30 +1,30 @@
-/*----------------------------------------------------------    
+/*----------------------------------------------------------
 File name   : ex_oto_layering_system_env.e
-Title       : Defines the system env 
+Title       : Defines the system env
 Project     : one to one layering example
 Created     : 2007
-Description : Defines the system env and its virtual Driver. 
+Description : Defines the system env and its virtual Driver.
             : Instansiates the two layers and binds them.
 Notes       : This is one of four layering examples: One to one,
             : One to many, Many to one and Many to many
-----------------------------------------------------------    
-Copyright (c) 2007 Cadence Design Systems, Inc. 
+----------------------------------------------------------
+Copyright (c) 2007 Cadence Design Systems, Inc.
 All rights reserved worldwide.
-Please refer to the terms and conditions in $IPCM_HOME 
-----------------------------------------------------------*/ 
+Please refer to the terms and conditions in $IPCM_HOME
+----------------------------------------------------------*/
+
 
-  
 o disable MAIN BFM sequences:
 
 <'
 
 
-extend MAIN ex_oto_layering_packet_sequence {    
+extend MAIN ex_oto_layering_packet_sequence {
     keep soft count == 0;
 };
 
 
-extend MAIN ex_oto_layering_frame_sequence {    
+extend MAIN ex_oto_layering_frame_sequence {
     keep soft count == 0;
 };
 
@@ -38,7 +38,7 @@ sequence system_sequence using created_driver = system_driver_u;
 extend system_sequence {
     !packet_sequence: ex_oto_layering_packet_sequence;
     !frame_sequence: ex_oto_layering_frame_sequence;
-    
+
     keep packet_sequence.driver == driver.packet_driver;
     keep frame_sequence.driver == driver.frame_driver;
 };
@@ -64,13 +64,13 @@ unit system_env_u like uvm_env {
 
     frame_env : ex_oto_layering_frame_env_u is instance;
     packet_env : ex_oto_layering_packet_env_u is instance;
-    
+
     system_driver: system_driver_u is instance;
 
     keep system_driver.packet_driver == packet_env.agent.driver;
-    
+
     keep system_driver.frame_driver == frame_env.agent.driver;
-    
+
     // binding the layeres together
     keep bind (frame_env.agent.driver.get_item_layer_transfer,
         packet_env.agent.bfm.down_item_layer_transfer);
diff --git a/lesson000X_mluvm_svsc/uvm_examples/ex_oto_layering/e/ex_oto_layering_system_seq_lib.e b/lesson000X_mluvm_svsc/uvm_examples/ex_oto_layering/e/ex_oto_layering_system_seq_lib.e
index 0550c8e..a2e7726 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/ex_oto_layering/e/ex_oto_layering_system_seq_lib.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/ex_oto_layering/e/ex_oto_layering_system_seq_lib.e
@@ -1,16 +1,16 @@
-/*----------------------------------------------------------    
+/*----------------------------------------------------------
 File name   : ex_oto_layering_system_seq_lib.e
-Title       : system level sequence library file 
+Title       : system level sequence library file
 Project     : one to one layering example
 Created     : 2007
 Description : Defines reusable system level sequences for usage in tests
 Notes       : This is one of four layering examples: One to one,
             : One to many, Many to one and Many to many
-----------------------------------------------------------    
-Copyright (c) 2007 Cadence Design Systems, Inc. 
+----------------------------------------------------------
+Copyright (c) 2007 Cadence Design Systems, Inc.
 All rights reserved worldwide.
-Please refer to the terms and conditions in $IPCM_HOME 
-----------------------------------------------------------*/ 
+Please refer to the terms and conditions in $IPCM_HOME
+----------------------------------------------------------*/
 
 <'
 
@@ -19,7 +19,7 @@ extend MAIN system_sequence {
    pre_body() @sys.any is first {
        driver.raise_objection(TEST_DONE);
    };
-   
+
    post_body() @sys.any is also {
       wait [20] * cycle @driver.clock;
       driver.drop_objection(TEST_DONE);
diff --git a/lesson000X_mluvm_svsc/uvm_examples/ex_oto_layering/e/ex_oto_layering_top.e b/lesson000X_mluvm_svsc/uvm_examples/ex_oto_layering/e/ex_oto_layering_top.e
index 330eac7..499165a 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/ex_oto_layering/e/ex_oto_layering_top.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/ex_oto_layering/e/ex_oto_layering_top.e
@@ -1,16 +1,16 @@
-/*----------------------------------------------------------    
+/*----------------------------------------------------------
 File name   : ex_oto_layering_top.e
-Title       : Top file 
+Title       : Top file
 Project     : one to one layering example
 Created     : 2007
 Description : Imports the required files.
 Notes       : This is one of four layering examples: One to one,
             : One to many, Many to one and Many to many
-----------------------------------------------------------    
-Copyright (c) 2007 Cadence Design Systems, Inc. 
+----------------------------------------------------------
+Copyright (c) 2007 Cadence Design Systems, Inc.
 All rights reserved worldwide.
-Please refer to the terms and conditions in $IPCM_HOME 
-----------------------------------------------------------*/ 
+Please refer to the terms and conditions in $IPCM_HOME
+----------------------------------------------------------*/
 
 <'
 
diff --git a/lesson000X_mluvm_svsc/uvm_examples/ex_oto_layering/examples/ex_oto_layering_test.e b/lesson000X_mluvm_svsc/uvm_examples/ex_oto_layering/examples/ex_oto_layering_test.e
index 073b1f3..94de618 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/ex_oto_layering/examples/ex_oto_layering_test.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/ex_oto_layering/examples/ex_oto_layering_test.e
@@ -1,22 +1,22 @@
-/*----------------------------------------------------------    
+/*----------------------------------------------------------
 File name   : ex_oto_layering_test.e
-Title       : example test file 
+Title       : example test file
 Project     : one to one layering example
 Created     : 2007
 Description : Defines test using layered sequences.
-            : Start 4 sequences in parallel: 
-            :   2 sequences of the upper layer (packet) 
+            : Start 4 sequences in parallel:
+            :   2 sequences of the upper layer (packet)
             :   2 sequences of the lower layer (frame)
             : The sequences id numbers are contrained such that
-            : each frame sequence is paired to one of the packet 
+            : each frame sequence is paired to one of the packet
             : sequences.
-Notes       : This is one of four layering examples: One to one, 
+Notes       : This is one of four layering examples: One to one,
             : One to many, Many to one and Many to many
-----------------------------------------------------------    
-Copyright (c) 2007 Cadence Design Systems, Inc. 
+----------------------------------------------------------
+Copyright (c) 2007 Cadence Design Systems, Inc.
 All rights reserved worldwide.
-Please refer to the terms and conditions in $IPCM_HOME 
-----------------------------------------------------------*/ 
+Please refer to the terms and conditions in $IPCM_HOME
+----------------------------------------------------------*/
 
 <'
 import ex_oto_layering/e/ex_oto_layering_top.e;
@@ -25,7 +25,7 @@ import ex_oto_layering/e/ex_oto_layering_top.e;
 <'
 
 extend MAIN system_sequence {
-   
+
    body() @driver.clock is only {
 
        all of {
@@ -33,28 +33,28 @@ extend MAIN system_sequence {
                do LAYERED frame_sequence keeping {
                    .ll_id == 1;
                    .destination_address == 0x001100110011;
-                   .source_address == 0x002200220022;    
+                   .source_address == 0x002200220022;
                };
            };
            {
                do LAYERED packet_sequence keeping {
                    .upper_layer_id == 1;
-               };  
+               };
            };
            {
                do LAYERED frame_sequence keeping {
                    .ll_id == 2;
                    .destination_address == 0x003300440055;
-                   .source_address == 0x006600770088;    
+                   .source_address == 0x006600770088;
                };
            };
            {
                do LAYERED packet_sequence keeping {
                    .upper_layer_id == 2;
-               };  
+               };
            };
        };
-   };   
+   };
 };
 
 
diff --git a/lesson000X_mluvm_svsc/uvm_examples/ex_oto_layering/examples/ex_oto_layering_test_multi_layered.e b/lesson000X_mluvm_svsc/uvm_examples/ex_oto_layering/examples/ex_oto_layering_test_multi_layered.e
index f6b3362..faa45a2 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/ex_oto_layering/examples/ex_oto_layering_test_multi_layered.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/ex_oto_layering/examples/ex_oto_layering_test_multi_layered.e
@@ -1,26 +1,26 @@
-/*----------------------------------------------------------    
+/*----------------------------------------------------------
 File name   : ex_oto_layering_test_multi_layered.e
-Title       : example test file 
+Title       : example test file
 Project     : one to one layering example
 Created     : 2007
 Description : Defines test using layered sequences
-            : Starts several sequences in parallel: 
-            :   4 sequences of the upper layer (packet) 
+            : Starts several sequences in parallel:
+            :   4 sequences of the upper layer (packet)
             :   3 sequences of the lower layer (frame)
             : The sequences are constrained such that:
-            :    - layered frame sequence id 1 gets items from 
-            :      three packet sequences 
-            :    - layered frame sequence id 2 gets items from 
-            :      one packet sequence 
+            :    - layered frame sequence id 1 gets items from
+            :      three packet sequences
+            :    - layered frame sequence id 2 gets items from
+            :      one packet sequence
             :    - ALL_RED frame sequence generates its own items
             :      (it is a low layer, but not a layered sequence)
-Notes       : This is one of four layering examples: One to one, 
+Notes       : This is one of four layering examples: One to one,
             : One to many, Many to one and Many to many
-----------------------------------------------------------    
-Copyright (c) 2007 Cadence Design Systems, Inc. 
+----------------------------------------------------------
+Copyright (c) 2007 Cadence Design Systems, Inc.
 All rights reserved worldwide.
-Please refer to the terms and conditions in $IPCM_HOME 
-----------------------------------------------------------*/ 
+Please refer to the terms and conditions in $IPCM_HOME
+----------------------------------------------------------*/
 
 <'
 import ex_oto_layering/e/ex_oto_layering_top.e;
@@ -29,11 +29,11 @@ import ex_oto_layering/e/ex_oto_layering_top.e;
 <'
 
 extend MAIN system_sequence {
-   
+
    body() @driver.clock is only {
 
        all of {
-           // id 1 layered scenario 
+           // id 1 layered scenario
            {
                do LAYERED frame_sequence keeping {
                    .ll_id == 1;
@@ -45,19 +45,19 @@ extend MAIN system_sequence {
            {
                do LAYERED_LONG packet_sequence keeping {
                    .upper_layer_id == 1;
-               };  
-               
+               };
+
                do LAYERED_SHORT packet_sequence keeping {
                    .upper_layer_id == 1;
-               };  
-               
+               };
+
                do LAYERED_LONG packet_sequence keeping {
                    .upper_layer_id == 1;
-               };  
-               
+               };
+
                message(MEDIUM, "PACKET LAYERED1 done");
            };
-           // id 2 layered scenario 
+           // id 2 layered scenario
            {
                do LAYERED frame_sequence keeping {
                    .ll_id == 2;
@@ -69,7 +69,7 @@ extend MAIN system_sequence {
            {
                do LAYERED packet_sequence keeping {
                    .upper_layer_id == 2;
-               };  
+               };
                message(MEDIUM,"PACKET LAYERED2 done");
            };
            // "independent" frame sequence
@@ -78,7 +78,7 @@ extend MAIN system_sequence {
                message(MEDIUM,"frame UN-LAYERED done");
            };
        };
-   };   
+   };
 };
 
 
diff --git a/lesson000X_mluvm_svsc/uvm_examples/ex_oto_layering/examples/ex_oto_layering_test_simple.e b/lesson000X_mluvm_svsc/uvm_examples/ex_oto_layering/examples/ex_oto_layering_test_simple.e
index be62663..d243655 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/ex_oto_layering/examples/ex_oto_layering_test_simple.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/ex_oto_layering/examples/ex_oto_layering_test_simple.e
@@ -1,20 +1,20 @@
-/*----------------------------------------------------------    
+/*----------------------------------------------------------
 File name   : ex_oto_layering_test_simple.e
-Title       : example test file 
+Title       : example test file
 Project     : one to one layering example
 Created     : 2007
 Description : Defines test using layered sequences
-            : Start 2 sequences in parallel: 
-            :   a sequence of the upper layer (packet) 
+            : Start 2 sequences in parallel:
+            :   a sequence of the upper layer (packet)
             :   a sequence of the lower layer (frame)
             : The id numbers are contrained to be the same
-Notes       : This is one of four layering examples: One to one, 
+Notes       : This is one of four layering examples: One to one,
             : One to many, Many to one and Many to many
-----------------------------------------------------------    
-Copyright (c) 2007 Cadence Design Systems, Inc. 
+----------------------------------------------------------
+Copyright (c) 2007 Cadence Design Systems, Inc.
 All rights reserved worldwide.
-Please refer to the terms and conditions in $IPCM_HOME 
-----------------------------------------------------------*/ 
+Please refer to the terms and conditions in $IPCM_HOME
+----------------------------------------------------------*/
 
 <'
 import ex_oto_layering/e/ex_oto_layering_top.e;
@@ -37,10 +37,10 @@ extend MAIN system_sequence {
            {
                do LAYERED packet_sequence keeping {
                    .upper_layer_id == 1;
-               };  
+               };
            };
        };
-   };   
+   };
 };
 
 
diff --git a/lesson000X_mluvm_svsc/uvm_examples/playpen/sc_producer_sv_consumer_test/Makefile b/lesson000X_mluvm_svsc/uvm_examples/playpen/sc_producer_sv_consumer_test/Makefile
index b51c7dc..1ec8bf1 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/playpen/sc_producer_sv_consumer_test/Makefile
+++ b/lesson000X_mluvm_svsc/uvm_examples/playpen/sc_producer_sv_consumer_test/Makefile
@@ -1,10 +1,10 @@
 #
-# For the definition of the possible targets and macros, 
-# please see the README in `ncroot`/tools/systemc/files/make 
+# For the definition of the possible targets and macros,
+# please see the README in `ncroot`/tools/systemc/files/make
 #
 
-# Whichever line below is not commented is the default. Override 
-# by specifying on the make command line. For example 
+# Whichever line below is not commented is the default. Override
+# by specifying on the make command line. For example
 #  "make dynamic COMPILER=gnu"
 
 GCC_VERS =
@@ -14,9 +14,9 @@ COMPILER = native
 #COMPILER = gnu
 
 #user can put their own ncsc, elaborator and simulator options
-USER_SIM_OPTIONS = 
-USER_ELAB_OPTIONS = 
-USER_NCSC_OPTIONS = 
+USER_SIM_OPTIONS =
+USER_ELAB_OPTIONS =
+USER_NCSC_OPTIONS =
 
 # User should list the systemc source files on this macro
 SYSTEMC_SOURCES = test.cpp
@@ -25,7 +25,7 @@ SYSTEMC_SOURCES = test.cpp
 VERILOG_SOURCES = test.sv
 
 # User should list the VHDL source files on this macro
-VHDL_SOURCES = 
+VHDL_SOURCES =
 
 # User should name top level module in the hdl hierarchy
 DESIGN_TOP = topmodule
@@ -37,19 +37,19 @@ USER_DFLAGS =
 USER_IFLAGS =
 
 # For user to add their own -L on the compiler command line.
-USER_LFLAGS = 
+USER_LFLAGS =
 
-# For user to add their own libraries to link with the simulation. 
-USER_LIBS = 
+# For user to add their own libraries to link with the simulation.
+USER_LIBS =
 
-# Do not modify. Location of the SystemC make files. 
+# Do not modify. Location of the SystemC make files.
 SYSTEMC_MAKEFILES = `ncroot`/tools/systemc/files/make
 
 # User should modify this to point at their own dependency file.
 DEPENDENCIES_FILE = Makefile.depends
 
 # Build a shared object to be linked into NC.
-dynamic: 
+dynamic:
 	make -f ${SYSTEMC_MAKEFILES}/Makefile.sc 		        \
 	   "SYSTEMC_MAKEFILES=${SYSTEMC_MAKEFILES}"                     \
 	   "USER_NCSC_OPTIONS=${USER_NCSC_OPTIONS}"                     \
@@ -61,7 +61,7 @@ dynamic:
 	   "NC_ROOT=`ncroot`" "ARCH=`cds_plat`" "GCC_VERS=${GCC_VERS}" "COMPILER=${COMPILER}"	\
 	   "SYSTEMC_SOURCES=${SYSTEMC_SOURCES}" dynamic
 
-# Build a version of the elaborator and the simulator that 
+# Build a version of the elaborator and the simulator that
 # contain the user's SystemC model statically linked in.
 static:
 	make -f ${SYSTEMC_MAKEFILES}/Makefile.sc 		        \
@@ -75,7 +75,7 @@ static:
            "DEPENDENCIES_FILE=${DEPENDENCIES_FILE}"                     \
 	   "SYSTEMC_SOURCES=${SYSTEMC_SOURCES}" static
 
-simulate_dynamic: 
+simulate_dynamic:
 	-make -f ${SYSTEMC_MAKEFILES}/Makefile.sc            		\
 	   "SYSTEMC_MAKEFILES=${SYSTEMC_MAKEFILES}" 			\
 	   "USER_NCSC_OPTIONS=${USER_NCSC_OPTIONS}"                     \
@@ -92,7 +92,7 @@ simulate_dynamic:
 	   "DEPENDENCIES_FILE=${DEPENDENCIES_FILE}"                     \
 	   "SYSTEMC_SOURCES=${SYSTEMC_SOURCES}" simulate_dynamic
 
-simulate_static: 
+simulate_static:
 	-make -f ${SYSTEMC_MAKEFILES}/Makefile.sc             		\
 	   "SYSTEMC_MAKEFILES=${SYSTEMC_MAKEFILES}" 			\
 	   "USER_NCSC_OPTIONS=${USER_NCSC_OPTIONS}"                     \
@@ -112,7 +112,7 @@ simulate_static:
 
 TARGET_TEST_INSTALL	= simulate_dynamic
 
-test_install: clean use_irun 
+test_install: clean use_irun
 
 use_irun:
 	@echo "############################"
@@ -123,14 +123,14 @@ use_irun:
 	grep -v "ncsim> source" ncsim.log | grep -v "DEPUVM" |grep -v "CDNS" | grep -v "Mentor Graphics" | grep -v "Cadence Design" | grep -v "Synopsys" > ncsim_.log
 	cp ncsim_.log ncsim.log
 	diff ncsim.au ncsim.log > ncsim.log.df
-	rm -rf *.df 
+	rm -rf *.df
 	irun -clean
 
 clean:
 	make -f ${SYSTEMC_MAKEFILES}/Makefile.sc                        \
 	SYSTEMC_MAKEFILES=${SYSTEMC_MAKEFILES} NC_ROOT=`ncroot`         \
         "DEPENDENCIES_FILE=${DEPENDENCIES_FILE}"                        \
-	ARCH=`cds_plat` "GCC_VERS=${GCC_VERS}" COMPILER=${COMPILER} clean 
+	ARCH=`cds_plat` "GCC_VERS=${GCC_VERS}" COMPILER=${COMPILER} clean
 	irun -clean
 
 automatic:
diff --git a/lesson000X_mluvm_svsc/uvm_examples/playpen/sc_producer_sv_consumer_test/Makefile.depends b/lesson000X_mluvm_svsc/uvm_examples/playpen/sc_producer_sv_consumer_test/Makefile.depends
index be43e1b..b195936 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/playpen/sc_producer_sv_consumer_test/Makefile.depends
+++ b/lesson000X_mluvm_svsc/uvm_examples/playpen/sc_producer_sv_consumer_test/Makefile.depends
@@ -1 +1 @@
-test.o : test.cpp 
+test.o : test.cpp
diff --git a/lesson000X_mluvm_svsc/uvm_examples/playpen/sc_producer_sv_consumer_test/consumer.sv b/lesson000X_mluvm_svsc/uvm_examples/playpen/sc_producer_sv_consumer_test/consumer.sv
index 314fbc0..9d8d51f 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/playpen/sc_producer_sv_consumer_test/consumer.sv
+++ b/lesson000X_mluvm_svsc/uvm_examples/playpen/sc_producer_sv_consumer_test/consumer.sv
@@ -18,20 +18,20 @@ class consumer #(type T=packet) extends uvm_component;
   typedef consumer#(T) this_type;
   `uvm_component_utils_begin(this_type)
   `uvm_component_utils_end
-   
+
   // implement put() task
   task put(T t);
     $display($realtime,,"consumer putting in fifo ", t.data);
     // dump the token into the fifo
     f.put(t);
   endtask
- 
+
   task run_phase (uvm_phase phase);
     T t;
     phase.raise_objection(this);
     for (int i = 0; i < 5; i++) begin
       // get tokens from the fifo
-      f.get(t); 
+      f.get(t);
       $display($realtime,,"consumer::run got from fifo: ", t.data);
     end
   endtask
diff --git a/lesson000X_mluvm_svsc/uvm_examples/playpen/sc_producer_sv_consumer_test/packet.sv b/lesson000X_mluvm_svsc/uvm_examples/playpen/sc_producer_sv_consumer_test/packet.sv
index 2eaae06..40f7090 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/playpen/sc_producer_sv_consumer_test/packet.sv
+++ b/lesson000X_mluvm_svsc/uvm_examples/playpen/sc_producer_sv_consumer_test/packet.sv
@@ -1,6 +1,6 @@
 // define a data object "packet" that derives from uvm_object;
-// for mixed-lamguage UVM communication, this SystemVerilog object needs 
-// to have the same name and same data type of member fields in the same 
+// for mixed-lamguage UVM communication, this SystemVerilog object needs
+// to have the same name and same data type of member fields in the same
 // order as the corresponding SystemC class
 
 class packet extends uvm_object;
diff --git a/lesson000X_mluvm_svsc/uvm_examples/playpen/sc_producer_sv_consumer_test/run.f b/lesson000X_mluvm_svsc/uvm_examples/playpen/sc_producer_sv_consumer_test/run.f
index 09e85a1..b9e6d70 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/playpen/sc_producer_sv_consumer_test/run.f
+++ b/lesson000X_mluvm_svsc/uvm_examples/playpen/sc_producer_sv_consumer_test/run.f
@@ -1,6 +1,6 @@
 // Set up env variable CDS_INST_DIR to point to the root of the IUS install
 
-// Use -nocopyright -and -reduce_messages so that results will 
+// Use -nocopyright -and -reduce_messages so that results will
 // match .au file no matter what version
 -NOCOPYRIGHT
 -reduce_messages
@@ -10,13 +10,13 @@
 
 // specify the SV test top as -uvmtop argument
 -uvmtop SV:svtest
-  
+
 // specify the SC test top as -uvmtop argument
 -uvmtop SC:sctest
-  
+
 // specify that sysc is in the design
 -sysc
-  
+
 // specify the name of the top Verilog module and snapshot
 -top topmodule
 
diff --git a/lesson000X_mluvm_svsc/uvm_examples/playpen/sc_producer_sv_consumer_test/test.cpp b/lesson000X_mluvm_svsc/uvm_examples/playpen/sc_producer_sv_consumer_test/test.cpp
index 78b58ed..1ac1006 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/playpen/sc_producer_sv_consumer_test/test.cpp
+++ b/lesson000X_mluvm_svsc/uvm_examples/playpen/sc_producer_sv_consumer_test/test.cpp
@@ -2,7 +2,7 @@
 #include "packet.h"
 
 // register producer templated by packet;
-// use the appropriate macro for registering components 
+// use the appropriate macro for registering components
 // with one template parameter
 
 UVM_COMPONENT_REGISTER_T(producer, packet)
@@ -15,11 +15,11 @@ SC_MODULE(sctest) {
     cerr << "sctest::sctest" << endl;
 
     // register the producer's port for mixed-language UVM communication
-    ml_uvm_register(&prod.out); 
+    ml_uvm_register(&prod.out);
 
-    // connect the producer's output port to SystemVerilog consumer's 
+    // connect the producer's output port to SystemVerilog consumer's
     // imp using a mixed-languag UVM connection function
-    ml_uvm_connect(prod.out.name(), "svtest.top_env.consumer.in"); 
+    ml_uvm_connect(prod.out.name(), "svtest.top_env.consumer.in");
   }
 };
 
diff --git a/lesson000X_mluvm_svsc/uvm_examples/playpen/sc_producer_sv_consumer_test/test.sv b/lesson000X_mluvm_svsc/uvm_examples/playpen/sc_producer_sv_consumer_test/test.sv
index 7ce3a61..41a6976 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/playpen/sc_producer_sv_consumer_test/test.sv
+++ b/lesson000X_mluvm_svsc/uvm_examples/playpen/sc_producer_sv_consumer_test/test.sv
@@ -29,7 +29,7 @@ import ml_uvm::*;
 
     `uvm_component_utils(env)
 
-  endclass    
+  endclass
 
   class svtest extends uvm_env;
     env top_env;
@@ -45,6 +45,6 @@ import ml_uvm::*;
     endfunction
 
     `uvm_component_utils(svtest)
-  endclass    
+  endclass
 
 endmodule
diff --git a/lesson000X_mluvm_svsc/uvm_examples/sc_producer_sv_consumer_test/Makefile b/lesson000X_mluvm_svsc/uvm_examples/sc_producer_sv_consumer_test/Makefile
index b51c7dc..1ec8bf1 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/sc_producer_sv_consumer_test/Makefile
+++ b/lesson000X_mluvm_svsc/uvm_examples/sc_producer_sv_consumer_test/Makefile
@@ -1,10 +1,10 @@
 #
-# For the definition of the possible targets and macros, 
-# please see the README in `ncroot`/tools/systemc/files/make 
+# For the definition of the possible targets and macros,
+# please see the README in `ncroot`/tools/systemc/files/make
 #
 
-# Whichever line below is not commented is the default. Override 
-# by specifying on the make command line. For example 
+# Whichever line below is not commented is the default. Override
+# by specifying on the make command line. For example
 #  "make dynamic COMPILER=gnu"
 
 GCC_VERS =
@@ -14,9 +14,9 @@ COMPILER = native
 #COMPILER = gnu
 
 #user can put their own ncsc, elaborator and simulator options
-USER_SIM_OPTIONS = 
-USER_ELAB_OPTIONS = 
-USER_NCSC_OPTIONS = 
+USER_SIM_OPTIONS =
+USER_ELAB_OPTIONS =
+USER_NCSC_OPTIONS =
 
 # User should list the systemc source files on this macro
 SYSTEMC_SOURCES = test.cpp
@@ -25,7 +25,7 @@ SYSTEMC_SOURCES = test.cpp
 VERILOG_SOURCES = test.sv
 
 # User should list the VHDL source files on this macro
-VHDL_SOURCES = 
+VHDL_SOURCES =
 
 # User should name top level module in the hdl hierarchy
 DESIGN_TOP = topmodule
@@ -37,19 +37,19 @@ USER_DFLAGS =
 USER_IFLAGS =
 
 # For user to add their own -L on the compiler command line.
-USER_LFLAGS = 
+USER_LFLAGS =
 
-# For user to add their own libraries to link with the simulation. 
-USER_LIBS = 
+# For user to add their own libraries to link with the simulation.
+USER_LIBS =
 
-# Do not modify. Location of the SystemC make files. 
+# Do not modify. Location of the SystemC make files.
 SYSTEMC_MAKEFILES = `ncroot`/tools/systemc/files/make
 
 # User should modify this to point at their own dependency file.
 DEPENDENCIES_FILE = Makefile.depends
 
 # Build a shared object to be linked into NC.
-dynamic: 
+dynamic:
 	make -f ${SYSTEMC_MAKEFILES}/Makefile.sc 		        \
 	   "SYSTEMC_MAKEFILES=${SYSTEMC_MAKEFILES}"                     \
 	   "USER_NCSC_OPTIONS=${USER_NCSC_OPTIONS}"                     \
@@ -61,7 +61,7 @@ dynamic:
 	   "NC_ROOT=`ncroot`" "ARCH=`cds_plat`" "GCC_VERS=${GCC_VERS}" "COMPILER=${COMPILER}"	\
 	   "SYSTEMC_SOURCES=${SYSTEMC_SOURCES}" dynamic
 
-# Build a version of the elaborator and the simulator that 
+# Build a version of the elaborator and the simulator that
 # contain the user's SystemC model statically linked in.
 static:
 	make -f ${SYSTEMC_MAKEFILES}/Makefile.sc 		        \
@@ -75,7 +75,7 @@ static:
            "DEPENDENCIES_FILE=${DEPENDENCIES_FILE}"                     \
 	   "SYSTEMC_SOURCES=${SYSTEMC_SOURCES}" static
 
-simulate_dynamic: 
+simulate_dynamic:
 	-make -f ${SYSTEMC_MAKEFILES}/Makefile.sc            		\
 	   "SYSTEMC_MAKEFILES=${SYSTEMC_MAKEFILES}" 			\
 	   "USER_NCSC_OPTIONS=${USER_NCSC_OPTIONS}"                     \
@@ -92,7 +92,7 @@ simulate_dynamic:
 	   "DEPENDENCIES_FILE=${DEPENDENCIES_FILE}"                     \
 	   "SYSTEMC_SOURCES=${SYSTEMC_SOURCES}" simulate_dynamic
 
-simulate_static: 
+simulate_static:
 	-make -f ${SYSTEMC_MAKEFILES}/Makefile.sc             		\
 	   "SYSTEMC_MAKEFILES=${SYSTEMC_MAKEFILES}" 			\
 	   "USER_NCSC_OPTIONS=${USER_NCSC_OPTIONS}"                     \
@@ -112,7 +112,7 @@ simulate_static:
 
 TARGET_TEST_INSTALL	= simulate_dynamic
 
-test_install: clean use_irun 
+test_install: clean use_irun
 
 use_irun:
 	@echo "############################"
@@ -123,14 +123,14 @@ use_irun:
 	grep -v "ncsim> source" ncsim.log | grep -v "DEPUVM" |grep -v "CDNS" | grep -v "Mentor Graphics" | grep -v "Cadence Design" | grep -v "Synopsys" > ncsim_.log
 	cp ncsim_.log ncsim.log
 	diff ncsim.au ncsim.log > ncsim.log.df
-	rm -rf *.df 
+	rm -rf *.df
 	irun -clean
 
 clean:
 	make -f ${SYSTEMC_MAKEFILES}/Makefile.sc                        \
 	SYSTEMC_MAKEFILES=${SYSTEMC_MAKEFILES} NC_ROOT=`ncroot`         \
         "DEPENDENCIES_FILE=${DEPENDENCIES_FILE}"                        \
-	ARCH=`cds_plat` "GCC_VERS=${GCC_VERS}" COMPILER=${COMPILER} clean 
+	ARCH=`cds_plat` "GCC_VERS=${GCC_VERS}" COMPILER=${COMPILER} clean
 	irun -clean
 
 automatic:
diff --git a/lesson000X_mluvm_svsc/uvm_examples/sc_producer_sv_consumer_test/Makefile.depends b/lesson000X_mluvm_svsc/uvm_examples/sc_producer_sv_consumer_test/Makefile.depends
index be43e1b..b195936 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/sc_producer_sv_consumer_test/Makefile.depends
+++ b/lesson000X_mluvm_svsc/uvm_examples/sc_producer_sv_consumer_test/Makefile.depends
@@ -1 +1 @@
-test.o : test.cpp 
+test.o : test.cpp
diff --git a/lesson000X_mluvm_svsc/uvm_examples/sc_producer_sv_consumer_test/consumer.sv b/lesson000X_mluvm_svsc/uvm_examples/sc_producer_sv_consumer_test/consumer.sv
index 314fbc0..9d8d51f 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/sc_producer_sv_consumer_test/consumer.sv
+++ b/lesson000X_mluvm_svsc/uvm_examples/sc_producer_sv_consumer_test/consumer.sv
@@ -18,20 +18,20 @@ class consumer #(type T=packet) extends uvm_component;
   typedef consumer#(T) this_type;
   `uvm_component_utils_begin(this_type)
   `uvm_component_utils_end
-   
+
   // implement put() task
   task put(T t);
     $display($realtime,,"consumer putting in fifo ", t.data);
     // dump the token into the fifo
     f.put(t);
   endtask
- 
+
   task run_phase (uvm_phase phase);
     T t;
     phase.raise_objection(this);
     for (int i = 0; i < 5; i++) begin
       // get tokens from the fifo
-      f.get(t); 
+      f.get(t);
       $display($realtime,,"consumer::run got from fifo: ", t.data);
     end
   endtask
diff --git a/lesson000X_mluvm_svsc/uvm_examples/sc_producer_sv_consumer_test/packet.sv b/lesson000X_mluvm_svsc/uvm_examples/sc_producer_sv_consumer_test/packet.sv
index 2eaae06..40f7090 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/sc_producer_sv_consumer_test/packet.sv
+++ b/lesson000X_mluvm_svsc/uvm_examples/sc_producer_sv_consumer_test/packet.sv
@@ -1,6 +1,6 @@
 // define a data object "packet" that derives from uvm_object;
-// for mixed-lamguage UVM communication, this SystemVerilog object needs 
-// to have the same name and same data type of member fields in the same 
+// for mixed-lamguage UVM communication, this SystemVerilog object needs
+// to have the same name and same data type of member fields in the same
 // order as the corresponding SystemC class
 
 class packet extends uvm_object;
diff --git a/lesson000X_mluvm_svsc/uvm_examples/sc_producer_sv_consumer_test/run.f b/lesson000X_mluvm_svsc/uvm_examples/sc_producer_sv_consumer_test/run.f
index 09e85a1..b9e6d70 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/sc_producer_sv_consumer_test/run.f
+++ b/lesson000X_mluvm_svsc/uvm_examples/sc_producer_sv_consumer_test/run.f
@@ -1,6 +1,6 @@
 // Set up env variable CDS_INST_DIR to point to the root of the IUS install
 
-// Use -nocopyright -and -reduce_messages so that results will 
+// Use -nocopyright -and -reduce_messages so that results will
 // match .au file no matter what version
 -NOCOPYRIGHT
 -reduce_messages
@@ -10,13 +10,13 @@
 
 // specify the SV test top as -uvmtop argument
 -uvmtop SV:svtest
-  
+
 // specify the SC test top as -uvmtop argument
 -uvmtop SC:sctest
-  
+
 // specify that sysc is in the design
 -sysc
-  
+
 // specify the name of the top Verilog module and snapshot
 -top topmodule
 
diff --git a/lesson000X_mluvm_svsc/uvm_examples/sc_producer_sv_consumer_test/test.cpp b/lesson000X_mluvm_svsc/uvm_examples/sc_producer_sv_consumer_test/test.cpp
index 78b58ed..1ac1006 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/sc_producer_sv_consumer_test/test.cpp
+++ b/lesson000X_mluvm_svsc/uvm_examples/sc_producer_sv_consumer_test/test.cpp
@@ -2,7 +2,7 @@
 #include "packet.h"
 
 // register producer templated by packet;
-// use the appropriate macro for registering components 
+// use the appropriate macro for registering components
 // with one template parameter
 
 UVM_COMPONENT_REGISTER_T(producer, packet)
@@ -15,11 +15,11 @@ SC_MODULE(sctest) {
     cerr << "sctest::sctest" << endl;
 
     // register the producer's port for mixed-language UVM communication
-    ml_uvm_register(&prod.out); 
+    ml_uvm_register(&prod.out);
 
-    // connect the producer's output port to SystemVerilog consumer's 
+    // connect the producer's output port to SystemVerilog consumer's
     // imp using a mixed-languag UVM connection function
-    ml_uvm_connect(prod.out.name(), "svtest.top_env.consumer.in"); 
+    ml_uvm_connect(prod.out.name(), "svtest.top_env.consumer.in");
   }
 };
 
diff --git a/lesson000X_mluvm_svsc/uvm_examples/sc_producer_sv_consumer_test/test.sv b/lesson000X_mluvm_svsc/uvm_examples/sc_producer_sv_consumer_test/test.sv
index 7ce3a61..41a6976 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/sc_producer_sv_consumer_test/test.sv
+++ b/lesson000X_mluvm_svsc/uvm_examples/sc_producer_sv_consumer_test/test.sv
@@ -29,7 +29,7 @@ import ml_uvm::*;
 
     `uvm_component_utils(env)
 
-  endclass    
+  endclass
 
   class svtest extends uvm_env;
     env top_env;
@@ -45,6 +45,6 @@ import ml_uvm::*;
     endfunction
 
     `uvm_component_utils(svtest)
-  endclass    
+  endclass
 
 endmodule
diff --git a/lesson000X_mluvm_svsc/uvm_examples/sv_test_sc_tlm10_dut/Makefile b/lesson000X_mluvm_svsc/uvm_examples/sv_test_sc_tlm10_dut/Makefile
index 86cb3e4..afa8ded 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/sv_test_sc_tlm10_dut/Makefile
+++ b/lesson000X_mluvm_svsc/uvm_examples/sv_test_sc_tlm10_dut/Makefile
@@ -1,10 +1,10 @@
 #
-# For the definition of the possible targets and macros, 
-# please see the README in `ncroot`/tools/systemc/files/make 
+# For the definition of the possible targets and macros,
+# please see the README in `ncroot`/tools/systemc/files/make
 #
 
-# Whichever line below is not commented is the default. Override 
-# by specifying on the make command line. For example 
+# Whichever line below is not commented is the default. Override
+# by specifying on the make command line. For example
 #  "make dynamic COMPILER=gnu"
 
 GCC_VERS =
@@ -14,9 +14,9 @@ COMPILER = native
 #COMPILER = gnu
 
 #user can put their own ncsc, elaborator and simulator options
-USER_SIM_OPTIONS = 
-USER_ELAB_OPTIONS = 
-USER_NCSC_OPTIONS = 
+USER_SIM_OPTIONS =
+USER_ELAB_OPTIONS =
+USER_NCSC_OPTIONS =
 
 # User should list the systemc source files on this macro
 SYSTEMC_SOURCES = tbtop.cpp
@@ -25,10 +25,10 @@ SYSTEMC_SOURCES = tbtop.cpp
 VERILOG_SOURCES = test.sv
 
 # User should list the VHDL source files on this macro
-VHDL_SOURCES = 
+VHDL_SOURCES =
 
 # User should name top level module in the hdl hierarchy
-DESIGN_TOP = 
+DESIGN_TOP =
 
 # For user to add their own -D on the compiler command line.
 USER_DFLAGS =
@@ -37,19 +37,19 @@ USER_DFLAGS =
 USER_IFLAGS =
 
 # For user to add their own -L on the compiler command line.
-USER_LFLAGS = 
+USER_LFLAGS =
 
-# For user to add their own libraries to link with the simulation. 
-USER_LIBS = 
+# For user to add their own libraries to link with the simulation.
+USER_LIBS =
 
-# Do not modify. Location of the SystemC make files. 
+# Do not modify. Location of the SystemC make files.
 SYSTEMC_MAKEFILES = `ncroot`/tools/systemc/files/make
 
 # User should modify this to point at their own dependency file.
 DEPENDENCIES_FILE = Makefile.depends
 
 # Build a shared object to be linked into NC.
-dynamic: 
+dynamic:
 	make -f ${SYSTEMC_MAKEFILES}/Makefile.sc 		        \
 	   "SYSTEMC_MAKEFILES=${SYSTEMC_MAKEFILES}"                     \
 	   "USER_NCSC_OPTIONS=${USER_NCSC_OPTIONS}"                     \
@@ -61,7 +61,7 @@ dynamic:
 	   "NC_ROOT=`ncroot`" "ARCH=`cds_plat`" "GCC_VERS=${GCC_VERS}" "COMPILER=${COMPILER}"	\
 	   "SYSTEMC_SOURCES=${SYSTEMC_SOURCES}" dynamic
 
-# Build a version of the elaborator and the simulator that 
+# Build a version of the elaborator and the simulator that
 # contain the user's SystemC model statically linked in.
 static:
 	make -f ${SYSTEMC_MAKEFILES}/Makefile.sc 		        \
@@ -75,7 +75,7 @@ static:
            "DEPENDENCIES_FILE=${DEPENDENCIES_FILE}"                     \
 	   "SYSTEMC_SOURCES=${SYSTEMC_SOURCES}" static
 
-simulate_dynamic: 
+simulate_dynamic:
 	-make -f ${SYSTEMC_MAKEFILES}/Makefile.sc            		\
 	   "SYSTEMC_MAKEFILES=${SYSTEMC_MAKEFILES}" 			\
 	   "USER_NCSC_OPTIONS=${USER_NCSC_OPTIONS}"                     \
@@ -92,7 +92,7 @@ simulate_dynamic:
 	   "DEPENDENCIES_FILE=${DEPENDENCIES_FILE}"                     \
 	   "SYSTEMC_SOURCES=${SYSTEMC_SOURCES}" simulate_dynamic
 
-simulate_static: 
+simulate_static:
 	-make -f ${SYSTEMC_MAKEFILES}/Makefile.sc             		\
 	   "SYSTEMC_MAKEFILES=${SYSTEMC_MAKEFILES}" 			\
 	   "USER_NCSC_OPTIONS=${USER_NCSC_OPTIONS}"                     \
@@ -112,7 +112,7 @@ simulate_static:
 
 TARGET_TEST_INSTALL	= simulate_dynamic
 
-test_install: clean use_irun 
+test_install: clean use_irun
 
 use_irun:
 	@echo "############################"
@@ -123,14 +123,14 @@ use_irun:
 	grep -v "ncsim> source" ncsim.log | grep -v "DEPUVM" |grep -v "CDNS" | grep -v "Mentor Graphics" | grep -v "Synopsys" | grep -v "Cadence Design" | grep -v "uvm_root.svh" | sed 's,\/.*\/tools,INST_PATH\/tools,' > ncsim_.log
 	cp ncsim_.log ncsim.log
 	diff ncsim.au ncsim.log > ncsim.log.df
-	rm -rf *.df 
+	rm -rf *.df
 	irun -clean
 
 clean:
 	make -f ${SYSTEMC_MAKEFILES}/Makefile.sc                        \
 	SYSTEMC_MAKEFILES=${SYSTEMC_MAKEFILES} NC_ROOT=`ncroot`         \
         "DEPENDENCIES_FILE=${DEPENDENCIES_FILE}"                        \
-	ARCH=`cds_plat` "GCC_VERS=${GCC_VERS}" COMPILER=${COMPILER} clean 
+	ARCH=`cds_plat` "GCC_VERS=${GCC_VERS}" COMPILER=${COMPILER} clean
 	irun -clean
 
 automatic:
diff --git a/lesson000X_mluvm_svsc/uvm_examples/sv_test_sc_tlm10_dut/Makefile.depends b/lesson000X_mluvm_svsc/uvm_examples/sv_test_sc_tlm10_dut/Makefile.depends
index be43e1b..b195936 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/sv_test_sc_tlm10_dut/Makefile.depends
+++ b/lesson000X_mluvm_svsc/uvm_examples/sv_test_sc_tlm10_dut/Makefile.depends
@@ -1 +1 @@
-test.o : test.cpp 
+test.o : test.cpp
diff --git a/lesson000X_mluvm_svsc/uvm_examples/sv_test_sc_tlm10_dut/packet.h b/lesson000X_mluvm_svsc/uvm_examples/sv_test_sc_tlm10_dut/packet.h
index 8ac3af3..c091ef3 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/sv_test_sc_tlm10_dut/packet.h
+++ b/lesson000X_mluvm_svsc/uvm_examples/sv_test_sc_tlm10_dut/packet.h
@@ -46,10 +46,10 @@ public:
   }
 public:
   int data;
-};  
+};
 UVM_OBJECT_REGISTER(packet)
-  
+
 /////////////////
-  
+
 #endif
 
diff --git a/lesson000X_mluvm_svsc/uvm_examples/sv_test_sc_tlm10_dut/run.f b/lesson000X_mluvm_svsc/uvm_examples/sv_test_sc_tlm10_dut/run.f
index 145e8e7..b2e10f5 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/sv_test_sc_tlm10_dut/run.f
+++ b/lesson000X_mluvm_svsc/uvm_examples/sv_test_sc_tlm10_dut/run.f
@@ -1,4 +1,4 @@
-// Use -nocopyright -and -reduce_messages so that results will 
+// Use -nocopyright -and -reduce_messages so that results will
 // match .au file no matter what version
 -NOCOPYRIGHT
 -reduce_messages
@@ -8,10 +8,10 @@
 
 // specify the SV test top as -uvmtop argument
 -uvmtop SV:test
-  
+
 // specify the SC testbench top as static top
 -sctop tbtop
-  
+
 // specify that sysc is in the design
 -sysc
 
diff --git a/lesson000X_mluvm_svsc/uvm_examples/sv_test_sc_tlm10_dut/test.sv b/lesson000X_mluvm_svsc/uvm_examples/sv_test_sc_tlm10_dut/test.sv
index 109055b..21da694 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/sv_test_sc_tlm10_dut/test.sv
+++ b/lesson000X_mluvm_svsc/uvm_examples/sv_test_sc_tlm10_dut/test.sv
@@ -62,7 +62,7 @@ import ml_uvm::*;
   class env extends uvm_env;
     producer #(packet) prod;
     checker #(packet) chk;
-  
+
     function new (string name, uvm_component parent=null);
       super.new(name,parent);
     endfunction
@@ -92,7 +92,7 @@ import ml_uvm::*;
     function new (string name, uvm_component parent=null);
       super.new(name,parent);
     endfunction
-    
+
     function void build();
       super.build();
       top_env = new("top_env", this);
@@ -100,7 +100,7 @@ import ml_uvm::*;
 
     `uvm_component_utils(test)
 
-  endclass    
-    
+  endclass
+
 endmodule
 
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/demo.sh b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/demo.sh
index 66bd726..7b121da 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/demo.sh
+++ b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/demo.sh
@@ -2,7 +2,7 @@
 #!/bin/sh -f
 #
 # Script for running xbus demo
-# 
+#
 #   demo.sh mti|vcs|nc[sim] verilog|vhdl
 # =============================================================================
 
@@ -24,13 +24,13 @@ fi
 
 package_path=`sn_which.sh xbus_e`
 xbus_path=`sn_which.sh xbus_e`
-demo_file="test_1.e" 
+demo_file="test_1.e"
 vlg_hdl_files="$xbus_path/v/tb_xbus.v"
 vhd_hdl_files="$xbus_path/vhdl/tb_xbus.vhd"
 debussy_do_file="$package_path/examples/debussy_cmd.txt"
 mti_do_file="$package_path/examples/sv.do"
-vcs_do_file="$package_path/examples/vcs.i"   
-nc_do_file="$package_path/examples/nc.i"    
+vcs_do_file="$package_path/examples/vcs.i"
+nc_do_file="$package_path/examples/nc.i"
 nc_waves="$package_path/examples/xbus.sv"
 vtop="xbus_evc_demo"
 abstract_l=SIGNAL
@@ -100,9 +100,9 @@ while [ "$#" -gt 0 ]; do
                         run_file="$2"
                         shift
                         ;;
-   
+
       esac
-	shift       
+	shift
 done
 
 
@@ -111,7 +111,7 @@ do_file="$nc_do_file"
 
 if [ -n "$run_file" ]; then
    cat $do_file > sim_cmd.txt
-   cat $run_file >> sim_cmd.txt 
+   cat $run_file >> sim_cmd.txt
    do_file="sim_cmd.txt"
 fi
 
@@ -122,12 +122,12 @@ echo ""  >> ./ncsim_run.tcl
 if [ $run_mode = batch ]; then
     gui_flag=""
     echo "run"  >> ./ncsim_run.tcl
-    echo "exit" >> ./ncsim_run.tcl 
+    echo "exit" >> ./ncsim_run.tcl
 
 fi
 
 
-if [ $abstract_l = ACCEL_SIM ]; then    
+if [ $abstract_l = ACCEL_SIM ]; then
   $package_path/scripts/demo_on_sim.sh 1 $demo_file $gui_flag
   exit
 fi
@@ -139,8 +139,8 @@ if [ $abstract_l = ACCEL_PXP ]; then
 fi
 
 demo_file=`sn_which.sh $package_path/examples/$demo_file`
- 
-cat $nc_waves > xbus.sv    
+
+cat $nc_waves > xbus.sv
 
 
  irun \
@@ -153,8 +153,8 @@ cat $nc_waves > xbus.sv
     $tcl_flag \
     -nosncomp  \
     -input ./ncsim_run.tcl \
-    -defineall SPECMAN_INCLUDED 
- 
+    -defineall SPECMAN_INCLUDED
+
 
 
 exit
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/dut/xbus_bus_monitor_bfm.sv b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/dut/xbus_bus_monitor_bfm.sv
index 319c3d2..f1f9d19 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/dut/xbus_bus_monitor_bfm.sv
+++ b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/dut/xbus_bus_monitor_bfm.sv
@@ -36,7 +36,7 @@ reg [7:0] [7:0] o_data;
 
 
 reg [15:0] temp_grant=0;
-always@(sig_grant[0] or sig_grant[1] or sig_grant[2] or sig_grant[3] or sig_grant[4] or sig_grant[5] or sig_grant[6] or sig_grant[7] or sig_grant[8] or sig_grant[9] or sig_grant[10] or sig_grant[11] or sig_grant[12] or sig_grant[13] or sig_grant[14] or sig_grant[15]) 
+always@(sig_grant[0] or sig_grant[1] or sig_grant[2] or sig_grant[3] or sig_grant[4] or sig_grant[5] or sig_grant[6] or sig_grant[7] or sig_grant[8] or sig_grant[9] or sig_grant[10] or sig_grant[11] or sig_grant[12] or sig_grant[13] or sig_grant[14] or sig_grant[15])
 begin
   temp_grant = sig_grant;
   odata_r = sig_grant;
@@ -82,7 +82,7 @@ begin
           odata_a[19] = sig_write;
           odata_a[23:20] = 4'h0;
           //$display("BM BFM @ %0t: addr = %0x, read = %0b, write = %0b, size = %0b", $time, sig_addr, sig_read, sig_write, sig_size);
-          case(odata_a[17:16]) 
+          case(odata_a[17:16])
             2'b00: word_cnt = 1;
             2'b01: word_cnt = 2;
             2'b10: word_cnt = 4;
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/dut/xbus_master_driver_bfm.sv b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/dut/xbus_master_driver_bfm.sv
index 153cdfa..db678ed 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/dut/xbus_master_driver_bfm.sv
+++ b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/dut/xbus_master_driver_bfm.sv
@@ -91,7 +91,7 @@ begin
           begin
             ipipe.receive(1,num_valid_ele,idata, eom);
 	     // $display("got from ipipe num_valid_ele %d ", num_valid_ele);
-	     
+
             i_addr = idata[15:0];
 	   //  $display("iaddr %h ", i_addr);
 
@@ -138,7 +138,7 @@ begin
 `ifdef MULTIPLE_MS
             active = 1'b1;
 `endif
-	     
+
             sig_request = 1'b0;
             sig_addr = i_addr;
             sig_size = i_size;
@@ -150,14 +150,14 @@ begin
           end
           end
     4'd2: begin
-       
+
           sig_addr = 16'b0;
           sig_size = 2'b0;
           sig_read = 1'b0;
           sig_write = 1'b0;
           if ({i_read,i_write} == 2'b01)
             begin
-	       
+
             n = 0;
             word_cnt = word_cnt -1;
             if (word_cnt == 0)
@@ -165,7 +165,7 @@ begin
             else
               sig_bip = 1;
             sig_data = i_data[n];
-	       
+
             n = n+1;
             //$display("MD BFM @ %0t: data = %0x", $time, sig_data);
             if(word_cnt > 0)
@@ -173,9 +173,9 @@ begin
             else
               state = 4'd4;
           end
-          else 
+          else
             begin
-	       
+
             odata = idata;
             i = 0;
             state = 4'd3;
@@ -186,13 +186,13 @@ begin
           if(!sig_wait && word_cnt > 0)
           begin
             if ({i_read,i_write} == 2'b01)
-            begin 
+            begin
               word_cnt = word_cnt - 1;
               if (word_cnt == 0)
                 sig_bip = 0;
               else
                 sig_bip = 1;
-           
+
               //$display("MD BFM @ %0t: data = %0x", $time, sig_data);
               sig_data = i_data[n];
               n = n+1;
@@ -201,9 +201,9 @@ begin
                 state = 4'd4;
               end
             end
-            else 
+            else
             begin
-              
+
               word_cnt = word_cnt -1;
               case(i)
                 0: begin odata[31:24] = sig_data; end
@@ -220,7 +220,7 @@ begin
               if(word_cnt == 0)
               begin
                 sig_data = 8'b0;
-                sig_bip = 1'b0;		 
+                sig_bip = 1'b0;
                  opipe.send(1,odata,1);
 		 slave_ctrl = 1'b0;
                 state = 4'd0;
@@ -247,7 +247,7 @@ begin
           end
   endcase
 end // always @ (posedge sig_clock )
-   
 
-   
+
+
 endmodule
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/dut/xbus_master_monitor_bfm.sv b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/dut/xbus_master_monitor_bfm.sv
index 9b43051..e6af495 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/dut/xbus_master_monitor_bfm.sv
+++ b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/dut/xbus_master_monitor_bfm.sv
@@ -60,7 +60,7 @@ begin
           odata[18] = sig_read;
           odata[19] = sig_write;
           //$display("MM BFM @ %0t: addr = %0x, read = %0b, write = %0b, size = %0b", $time, sig_addr, sig_read, sig_write, sig_size);
-          case(odata[17:16]) 
+          case(odata[17:16])
             2'b00: word_cnt = 1;
             2'b01: word_cnt = 2;
             2'b10: word_cnt = 4;
@@ -81,7 +81,7 @@ begin
           i = i+1;
           if(word_cnt == 0)
           begin
-           odata[31:24]=o_data[0]; odata[39:32]=o_data[1];odata[47:40]=o_data[2]; odata[55:48]=o_data[3];odata[63:56]=o_data[4]; odata[71:64]=o_data[5];odata[79:72]=o_data[6]; odata[87:80]=o_data[7]; 
+           odata[31:24]=o_data[0]; odata[39:32]=o_data[1];odata[47:40]=o_data[2]; odata[55:48]=o_data[3];odata[63:56]=o_data[4]; odata[71:64]=o_data[5];odata[79:72]=o_data[6]; odata[87:80]=o_data[7];
 
 	     opipe.send(1,odata,1);
             state = 4'd0;
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/dut/xbus_slave_driver_bfm.sv b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/dut/xbus_slave_driver_bfm.sv
index 850c488..3a371d1 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/dut/xbus_slave_driver_bfm.sv
+++ b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/dut/xbus_slave_driver_bfm.sv
@@ -39,9 +39,9 @@ reg [3:0] state=0;
 reg [3:0]  wait_count=0;
 int word_count=0;
 int i=0;
-   
 
-   
+
+
 always @(posedge sig_clock )
 begin
   case (state)
@@ -51,12 +51,12 @@ begin
           sig_error      = 1'b0;
           sig_wait       = 1'b0;
         end
-        else if(ipipe.can_receive()) 
+        else if(ipipe.can_receive())
           begin
-	     
+
           ipipe.receive(1,num_ele_valid,idata,eom);
           i = 0;
-         // $display("SD BFM @ %0t: addr = %0x, read = %0b, write = %0b, size = %0b, wait_state = %d", 
+         // $display("SD BFM @ %0t: addr = %0x, read = %0b, write = %0b, size = %0b, wait_state = %d",
 	     //	   $time, idata[15:0], idata[18], idata[19], idata[17:16], idata[23:20]);
           //   $display("SD BFM idata[31:24] %x idata[39:32] %x",  idata[31:24], idata[39:32]);
 	     wait_count = idata[23:20];
@@ -121,6 +121,6 @@ begin
         end
   endcase
 end
- 
+
 
 endmodule
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/dut/xbus_slave_monitor_bfm.sv b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/dut/xbus_slave_monitor_bfm.sv
index e19a647..d9102f2 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/dut/xbus_slave_monitor_bfm.sv
+++ b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/dut/xbus_slave_monitor_bfm.sv
@@ -61,11 +61,11 @@ begin
             endcase // case(odata[17:16])
 	  //   $display("SLAVE HW Monitor will send addr %x size %x read %x write %x ",
 		    // odata[15:0], odata[17:16],   odata[18] , odata[19] );
-	     
+
             //$display("SM BFM @ %0t: addr = %0x, read = %0b, write = %0b, size = %0b", $time, sig_addr, sig_read, sig_write, sig_size);
             o_data[0]=8'h00;o_data[1]=8'h00;o_data[2]=8'h00;o_data[3]=8'h00;
             o_data[4]=8'h00;o_data[5]=8'h00;o_data[6]=8'h00;o_data[7]=8'h00;
-	     
+
             opipe.send(1,odata,1);
 	     state = 4'd1;
           end
@@ -92,7 +92,7 @@ begin
             end
             else
               state = 4'd2;
-          end 
+          end
     4'd2: begin
           if(!sig_wait && word_count < sig_data_size)
           begin
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/simple_ram_env.e b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/simple_ram_env.e
index 7b23172..8c3b2ea 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/simple_ram_env.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/simple_ram_env.e
@@ -1,13 +1,13 @@
-/*------------------------------------------------------------------------- 
+/*-------------------------------------------------------------------------
 File name   : simple_ram_env.e
 Title       : Simple RAM model env
 Project     : UVM xbus
-Developers  : 
+Developers  :
 Created     : 2008
 Description : Provide a generic RAM model. This is implemented as a simple
             : sparse byte-oriented RAM.
-Notes       : 
---------------------------------------------------------------------------- 
+Notes       :
+---------------------------------------------------------------------------
 //----------------------------------------------------------------------
 //   Copyright 2008-2010 Cadence Design Systems, Inc.
 //   All Rights Reserved Worldwide
@@ -26,7 +26,7 @@ Notes       :
 //   the License for the specific language governing
 //   permissions and limitations under the License.
 //----------------------------------------------------------------------
--------------------------------------------------------------------------*/ 
+-------------------------------------------------------------------------*/
 
 <'
 package cdn_xbus;
@@ -54,7 +54,7 @@ unit simple_ram_env_u like uvm_env {
     -- keyed list of locations in the RAM
     !locations : list(key : address) of simple_ram_location_s;
 
-    
+
     -- write a single byte to the RAM
     write_byte(addr : uint, data : byte) is {
         if locations.key_exists(addr) {
@@ -66,7 +66,7 @@ unit simple_ram_env_u like uvm_env {
             locations.add(temp);
         };
     }; -- write_byte()
-    
+
 
     -- check whether a byte already exists in the RAM
     byte_exists(addr : uint) : bool is {
@@ -77,20 +77,20 @@ unit simple_ram_env_u like uvm_env {
     -- read a single byte from the RAM
     read_byte(addr : uint) : uint is {
         if locations.key_exists(addr) then {
-            result = locations.key(addr).value 
+            result = locations.key(addr).value
         } else {
-            result = 0; -- higher levels of code should use byte_exists() 
+            result = 0; -- higher levels of code should use byte_exists()
                         -- method to check for this posibility
         };
     }; -- read_byte()
-    
+
     -- write multiple bytes to the RAM
     write(addr : uint, data : list of byte) is {
         for each (d) in data do {
             write_byte(addr + index, d);
         };
     }; -- write()
-    
+
     -- zero multiple bytes in the RAM
     zero(addr : uint, size : uint) is {
         for i from 0 to (size - 1) {
@@ -104,12 +104,12 @@ unit simple_ram_env_u like uvm_env {
             result.add(read_byte(addr + i));
         };
     }; -- read()
-    
+
     -- clear entire contents of the RAM
     clear() is {
         locations.clear();
     }; -- clear()
-        
+
 }; -- uvm_env simple_ram_env_u
 
 
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_accel.e b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_accel.e
index 0722493..89d2bf0 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_accel.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_accel.e
@@ -39,35 +39,35 @@ Connected to HW BFM
 <'
 
 extend UVM_ACCEL MASTER xbus_bfm_u {
-    
+
     // The name of the instance of the HDL transactor, the xbus_master_driver_bfm
     keep hdl_path() == "driver_bfm";
 
     // Input - SW to HW
     m_ip : uvm_accel_input_pipe_proxy of MASTER xbus_trans_s is instance;
     // The name of the instance of the transactor input scemi port:
-    keep m_ip.hdl_path() == "ipipe"; 
+    keep m_ip.hdl_path() == "ipipe";
 
     // Output - HW to WW
     m_op : uvm_accel_output_pipe_proxy of MASTER xbus_trans_s is instance;
     // The name of the instance of the transactor output scemi port:
-    keep m_op.hdl_path() == "opipe"; 
+    keep m_op.hdl_path() == "opipe";
 
     // TLM ports, connected to the scemi
     m_in :  interface_port of tlm_put of MASTER xbus_trans_s is instance;
     m_out : interface_port of tlm_get of MASTER xbus_trans_s is instance;
 
-    connect_ports() is also { 
+    connect_ports() is also {
         m_in.connect(m_ip.m_in);
         m_out.connect(m_op.m_out);
     };
 
     private drive_transfer(t : MASTER xbus_trans_s) @tf_phase_clock is {
-       
+
         message(LOW, abstraction_level, " master_bfm drive: ", t,
                 " address : ", t.addr,
-                " read_write : ", t.read_write, 
-                " size : ", t.size ); 
+                " read_write : ", t.read_write,
+                " size : ", t.size );
 
         if(t.read_write == WRITE) {
             m_in$.put(t);
@@ -79,21 +79,21 @@ extend UVM_ACCEL MASTER xbus_bfm_u {
         };
         message(HIGH, abstraction_level, " master_bfm done: ", t);
     };
-    
-    // in acceleration - do not wait for resetindication before starting 
+
+    // in acceleration - do not wait for resetindication before starting
     // driving transfers
     tf_env_setup() @tf_phase_clock is also {
        start drive_transfers();
     };
-    
+
     private drive_transfers() @tf_phase_clock is only {
-        
+
         // Until pases supported in Acceleration
-        
+
         if tf_get_domain_mgr().get_current_phase() != ENV_SETUP {
             return;
         };
-          
+
         while TRUE {
             var next_trans := driver.get_next_item();
             drive_transfer(next_trans);
@@ -110,40 +110,40 @@ extend MONITOR xbus_trans_s {
 extend xbus_trans_s {
     do_unpack(options:pack_options, l: list of bit, begin: int): int is only {
         var L : list of bit = l[begin..];
-          
+
         unpack(packing.low, L, addr, size_ctrl, read_write);
-        
+
         case size_ctrl {
             0 : {size = 1};
             1 : {size = 2};
             2 : {size = 4};
             3 : {size = 8};
         };
-        
+
         for i from 0 to size-1 {
             data.add(pack(packing.low,L[24+i*8..24+i*8+7]))
         };
-        
+
     };
 };
 extend xbus_trans_s {
     do_pack(options : pack_options, l :*list of bit) is also {
-        
+
         // These bits are where HW BFM expects to see wait-states
         l[20] = 0;
         l[21] = 0;
         l[22] = 0;
         l[23] = 0;
-   
+
         l.resize(24, TRUE, 0, TRUE);
-            
+
         // Add the data
         for each in data {
             l.add(pack(packing.low,it));
         };
-        
+
         l.resize(88, TRUE, 0, TRUE);
-        
+
     };
 };
 '>
@@ -164,29 +164,29 @@ extend UVM_ACCEL MASTER xbus_agent_monitor_u {
     // Output - HW to WW
     m_op : uvm_accel_output_pipe_proxy of MONITOR xbus_trans_s is instance;
     // The name of the instance of the transactor output scemi port:
-    keep m_op.hdl_path() == "opipe"; 
+    keep m_op.hdl_path() == "opipe";
 
     // TLM ports, connected to the scemi
     m_out : interface_port of tlm_get of MONITOR xbus_trans_s is instance;
 
-    // Port exporting to upper levels 
+    // Port exporting to upper levels
     transfer_got_from_hw : out interface_port of tlm_analysis of
                                          MONITOR xbus_trans_s is instance;
-    
-    connect_ports() is also { 
+
+    connect_ports() is also {
         // Getting data -  Connect to Pipe Proxy port
         m_out.connect(m_op.m_out);
-        
+
         // Sending data - Connect to monitor TLM port
         transfer_got_from_hw.connect(transfer_ended_o);
     };
-    
+
     !transfer : MONITOR xbus_trans_s;
-    
+
     collect_transfers() @sys.any is {
 
         while TRUE {
-            transfer = NULL;       
+            transfer = NULL;
             m_out$.get(transfer);
             transfer.master_name = agent_name;
             case transfer.size_ctrl {
@@ -195,13 +195,13 @@ extend UVM_ACCEL MASTER xbus_agent_monitor_u {
                 2 : {transfer.size = 4};
                 3 : {transfer.size = 8};
             };
-        
+
             message(LOW, abstraction_level, " Master monitor got transfer ",
                     transfer,
                     " address : ", transfer.addr,
                     " read_write : ", transfer.read_write,
-                    " size : ", transfer.size); 
-                        
+                    " size : ", transfer.size);
+
             transfer_got_from_hw$.write(transfer);
         };
     };
@@ -227,54 +227,54 @@ extend UVM_ACCEL SLAVE xbus_bfm_u {
     // Input - SW to HW
     m_ip : uvm_accel_input_pipe_proxy of xbus_slave_response_s is instance;
     // The name of the instance of the transactor input scemi port:
-    keep m_ip.hdl_path() == "ipipe"; 
+    keep m_ip.hdl_path() == "ipipe";
 
 
     // TLM ports, connected to the scemi
     m_in :  interface_port of tlm_put of xbus_slave_response_s is instance;
 
-    connect_ports() is also { 
+    connect_ports() is also {
         m_in.connect(m_ip.m_in);
     };
 
     private drive_responses() @tf_phase_clock is only {
-        // Do nothing. Responses will be done according to indication of 
+        // Do nothing. Responses will be done according to indication of
         // transfer started, from the monitor
     };
-    
-    
-    // Port getting started-transfers I should respond to 
+
+
+    // Port getting started-transfers I should respond to
      transfer_started_ip : in interface_port of tlm_analysis of
                                          MONITOR xbus_trans_s is instance;
 
     !next_response : xbus_slave_response_s;
       keep next_response.driver == me.driver;
       keep next_response.error_pos == UNDEF;
-      
-    // Port implementation 
+
+    // Port implementation
     // Respond to transfer
     write(transfer : MONITOR xbus_trans_s) is {
         driver.transfer = transfer;
-        
+
         transfer.data.clear();
         for i from 0 to transfer.size-1 {
             transfer.data.add(ram.read_byte(transfer.addr + i));
         };
-        
-        // Generate once, will be overriden during the run, 
+
+        // Generate once, will be overriden during the run,
         // according to current transfer
         if next_response == NULL then {
             gen next_response;
         };
         next_response.transfer = transfer;
-        
+
         start respond(next_response);
     };
-    
+
     respond(response : xbus_slave_response_s) @sys.any is {
         message(LOW, "Send response ", response);
         m_in$.put(response);
-    };   
+    };
 };
 
 
@@ -299,39 +299,39 @@ extend UVM_ACCEL SLAVE xbus_agent_monitor_u {
     // Output - HW to WW
     // This port is for data captured during the transaction
     m_op_partial : uvm_accel_output_pipe_proxy of MONITOR xbus_trans_s is instance;
-    
+
     // The name of the instance of the transactor output scemi port:
-    keep m_op_partial.hdl_path() == "opipe"; 
+    keep m_op_partial.hdl_path() == "opipe";
 
     // TLM ports, connected to the scemi
     m_out_partial : interface_port of tlm_get of MONITOR xbus_trans_s is instance;
-   
+
     // Output - HW to WW
     // This port is for full transfer, captured at end ofthe transaction
     m_transfer_op : uvm_accel_output_pipe_proxy of MONITOR xbus_trans_s is instance;
     // The name of the instance of the transactor output scemi port:
-    keep m_transfer_op.hdl_path() == "opipe_data"; 
+    keep m_transfer_op.hdl_path() == "opipe_data";
 
     // TLM ports, connected to the scemi
     m_transfer_out : interface_port of tlm_get of MONITOR xbus_trans_s is instance;
 
-    // Port exporting to upper levels 
-    // Passing partial 
-    partial_transfer_got_from_hw : out interface_port of tlm_analysis 
+    // Port exporting to upper levels
+    // Passing partial
+    partial_transfer_got_from_hw : out interface_port of tlm_analysis
                                                       of MONITOR xbus_trans_s is instance;
-     
-    connect_ports() is also { 
+
+    connect_ports() is also {
         // Getting data -  Connect to Pipe Proxy port
         m_out_partial.connect(m_op_partial.m_out);
-        
+
         // Getting data -  Connect to Pipe Proxy port
-        m_transfer_out.connect(m_transfer_op.m_out); 
-    };                           
-    
+        m_transfer_out.connect(m_transfer_op.m_out);
+    };
+
     !transfer_partial : MONITOR xbus_trans_s;
-    
+
     !during_transfer  : bool;
-    
+
     // collect_transfers_full()
     //
     // Getting from a port that passes transfers both on started and and ended.
@@ -339,9 +339,9 @@ extend UVM_ACCEL SLAVE xbus_agent_monitor_u {
     //
     collect_transfers_full() @sys.any is {
         while TRUE {
-            transfer_partial = NULL;       
+            transfer_partial = NULL;
             m_out_partial$.get(transfer_partial);
-            
+
             if during_transfer then {
                 continue;
             };
@@ -354,7 +354,7 @@ extend UVM_ACCEL SLAVE xbus_agent_monitor_u {
                 2 : {transfer_partial.size = 4};
                 3 : {transfer_partial.size = 8};
             };
-            message(MEDIUM, abstraction_level, " Slave monitor got transfer started ", 
+            message(MEDIUM, abstraction_level, " Slave monitor got transfer started ",
                     transfer_partial,
                     " address : ", transfer_partial.addr,
                     " read_write : ", transfer_partial.read_write,
@@ -364,16 +364,16 @@ extend UVM_ACCEL SLAVE xbus_agent_monitor_u {
     };
 
     !transfer : MONITOR xbus_trans_s;
-    
+
     collect_transfers() @sys.any is {
-        
+
         while TRUE {
-            transfer = NULL;       
+            transfer = NULL;
             m_transfer_out$.get(transfer);
             if not during_transfer then {
                 continue;
             };
-            
+
             transfer.slave_name = agent_name;
 
             var l : list of byte = pack(packing.low, transfer);
@@ -383,22 +383,22 @@ extend UVM_ACCEL SLAVE xbus_agent_monitor_u {
                 2 : {transfer.size = 4};
                 3 : {transfer.size = 8};
             };
-            
 
-            message(LOW, abstraction_level, 
+
+            message(LOW, abstraction_level,
                     " Slave monitor got transfer " ,
                     transfer,
                     " address : ", transfer.addr,
                     " read_write : ", transfer.read_write,
                     " size : ", transfer.size);
-            
+
             if transfer.read_write == WRITE {
                 for each in transfer.data {
                     ram.write_byte(transfer.addr + index, it);
                 };
             };
             during_transfer = FALSE;
-            
+
        };
     };
 
@@ -414,31 +414,31 @@ extend UVM_ACCEL SLAVE xbus_agent_monitor_u {
 
 
 extend ACTIVE UVM_ACCEL SLAVE xbus_agent_u {
-      
-    connect_pointers() is also {      
+
+    connect_pointers() is also {
         // Connect collected transfer, to the BFM so it will respond
         agent_monitor.as_a(UVM_ACCEL SLAVE xbus_agent_monitor_u).ram = ram;
     };
-          
-    connect_ports() is also {      
+
+    connect_ports() is also {
         // Connect collected transfer, to the BFM so it will respond
-        agent_monitor.as_a(UVM_ACCEL SLAVE xbus_agent_monitor_u).partial_transfer_got_from_hw.connect(bfm.as_a(UVM_ACCEL SLAVE xbus_bfm_u).transfer_started_ip); 
-        
-       
+        agent_monitor.as_a(UVM_ACCEL SLAVE xbus_agent_monitor_u).partial_transfer_got_from_hw.connect(bfm.as_a(UVM_ACCEL SLAVE xbus_bfm_u).transfer_started_ip);
+
+
     };
 };
 
 
 extend UVM_ACCEL MASTER xbus_agent_u {
 
-    connect_ports() is also {              
+    connect_ports() is also {
         // Connect transfer end - for the monitor to use
         agent_monitor.as_a(UVM_ACCEL MASTER xbus_agent_monitor_u).transfer_got_from_hw.connect(get_enclosing_unit(xbus_env_u).bus_monitor.transfer_ended_i);
     };
 };
 
 extend UVM_ACCEL xbus_bus_monitor_u {
-    ended_write(new_transfer : MONITOR xbus_trans_s ) is first {  
+    ended_write(new_transfer : MONITOR xbus_trans_s ) is first {
         transfer = new_transfer;
     };
 };
@@ -457,7 +457,7 @@ UVM_ACCEL bus_collector
 
 <'
 
-// Dummy data, just getting 
+// Dummy data, just getting
 struct hw_address {
     %value : uint (bits : 24);
 };
@@ -474,31 +474,31 @@ struct hw_reset {
 extend UVM_ACCEL xbus_bus_collector_u {
 
     keep hdl_path() == "bus_monitor_bfm";
-    
-   
+
+
     // Output - HW to WW
-    
+
     hw_address_op : uvm_accel_output_pipe_proxy of hw_address is instance;
     // The name of the instance of the transactor output scemi port:
-    keep hw_address_op.hdl_path() == "opipe_a"; 
+    keep hw_address_op.hdl_path() == "opipe_a";
 
     hw_address_out : out interface_port of tlm_get of hw_address is instance;
 
     hw_grant_op : uvm_accel_output_pipe_proxy of hw_grant is instance;
     // The name of the instance of the transactor output scemi port:
-    keep hw_grant_op.hdl_path() == "opipe_r"; 
+    keep hw_grant_op.hdl_path() == "opipe_r";
 
     hw_grant_out : out interface_port of tlm_get of hw_grant is instance;
- 
+
     hw_data_op : uvm_accel_output_pipe_proxy of hw_data is instance;
     // The name of the instance of the transactor output scemi port:
-    keep hw_data_op.hdl_path() == "opipe_d"; 
+    keep hw_data_op.hdl_path() == "opipe_d";
 
     hw_data_out : out interface_port of tlm_get of hw_data is instance;
-    
+
     hw_reset_op : uvm_accel_output_pipe_proxy of hw_reset is instance;
     // The name of the instance of the transactor output scemi port:
-    keep hw_reset_op.hdl_path() == "opipe_reset"; 
+    keep hw_reset_op.hdl_path() == "opipe_reset";
 
     hw_reset_out : out interface_port of tlm_get of hw_reset is instance;
 
@@ -566,19 +566,19 @@ extend UVM_ACCEL xbus_synchronizer_u {
         sig_reset.disconnect();
         do_bind (sig_reset, empty);
     };
-    
+
     event never;
-    
+
     // These clocks are not required in acceleration
     event unqualified_clock_rise  is only cycle @never;
     event unqualified_clock_fall  is only cycle @never;
     event reset_change  is only cycle @never;
     event clock_fall    is only cycle @never;
-   
-    // Envoironment one and only clock. 
+
+    // Envoironment one and only clock.
     // Ticking only on each context switch from HW
     event clock_rise  is only cycle @sys.any;
-}; 
+};
 
 
 
@@ -614,7 +614,7 @@ extend UVM_ACCEL xbus_master_signal_map_u {
         sig_request.disconnect();
         do_bind(sig_request, empty);
         sig_grant.disconnect();
-        do_bind(sig_grant,   empty);    
+        do_bind(sig_grant,   empty);
     };
 };
 '>
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_agent_h.e b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_agent_h.e
index 9ffddbe..ac919d1 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_agent_h.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_agent_h.e
@@ -1,11 +1,11 @@
-/*-------------------------------------------------------------------------  
+/*-------------------------------------------------------------------------
 File name   : xbus_agent_h.e
 Title       : Agent unit declaration
 Project     : XBus UVC
 Created     : 2008
 Description : This file declares the agent unit.
-Notes       : 
---------------------------------------------------------------------------- 
+Notes       :
+---------------------------------------------------------------------------
 //----------------------------------------------------------------------
 //   Copyright 2008-2010 Cadence Design Systems, Inc.
 //   All Rights Reserved Worldwide
@@ -24,20 +24,20 @@ Notes       :
 //   the License for the specific language governing
 //   permissions and limitations under the License.
 //----------------------------------------------------------------------
--------------------------------------------------------------------------*/ 
+-------------------------------------------------------------------------*/
 
 <'
 
 package cdn_xbus;
-     
-     
+
+
 
 -- This unit is the base type for all agents (masters, slaves and arbiters)
 -- that are connected to the bus.
 unit xbus_agent_u like uvm_agent {
 
     tf_testflow_unit;
-    
+
     -- This unit and all units under it belong to the XBUS_TF
     -- TestFlow domain
     keep soft tf_domain == XBUS_TF;
@@ -47,13 +47,13 @@ unit xbus_agent_u like uvm_agent {
     -- UVM_SIGNAL, UVM_TLM, UVM_ACCEL, UVM_SIGNAL_SC
     abstraction_level : uvm_abstraction_level_t;
       keep soft abstraction_level == UVM_SIGNAL;
-    
+
     -- This field provides a screen logger for each UVC instance. By default,
     -- it's verbosity is set to NONE so that it is disabled.
     logger : message_logger is instance;
         keep soft logger.verbosity == NONE;
         keep soft logger.tags == {TESTFLOW_EX};
-      
+
     -- This field is the logical name of the bus the agent is connected to.
     -- This field is automatically constrained by the UVC and should not be
     -- constrained by the user.
@@ -63,7 +63,7 @@ unit xbus_agent_u like uvm_agent {
     -- automatically constrained by the UVC and should not be constrained by
     -- the user.
     agent_name : xbus_agent_name_t;
-    
+
     -- This field controls what sort of agent this is (MASTER, SLAVE or
     -- ARBITER). This field is automatically constrained by the UVC and should
     -- not be constrained by the user.
@@ -76,10 +76,10 @@ unit xbus_agent_u like uvm_agent {
        keep agent_monitor.agent == read_only(me);
        keep agent_monitor.abstraction_level == read_only(abstraction_level);
 
-    
+
     -- This field is a pointer to the synchronizer.
     synch : xbus_synchronizer_u;
-    
+
     -- This field is a pointer to the bus signal map.
     smp : xbus_signal_map_u;
 
@@ -93,7 +93,7 @@ unit xbus_agent_u like uvm_agent {
     -- The short_name() method should return the name of this agent instance.
     short_name(): string is {
         result = append(agent_name);
-    }; -- short_name()    
+    }; -- short_name()
 }; -- unit xbus_agent_u
 
 '>
@@ -115,15 +115,15 @@ extend xbus_master_signal_map_u {
 
     -- This field is a pointer to the MASTER agent that uses this signal map.
     master : MASTER xbus_agent_u;
-    
+
 }; -- extend xbus_master_signal_map_u
 '>
 
 
-  Configuration 
+  Configuration
 
 <'
-// the macro instantiates unit xserial_agent_config_u and struct 
+// the macro instantiates unit xserial_agent_config_u and struct
 // xserial_agent_config_params, in xserial_agent_u.
 // In this example, xserial_agent_config_u xserial_agent_config_params have
 // been defined earlier (in xbus_types_h.e)
@@ -147,7 +147,7 @@ extend xbus_slave_config_u {
     -- max_addr).
     in_range(addr : xbus_addr_t) : bool is {
         result = (addr >= params.min_addr) and (addr <= params.max_addr);
-    }; -- in_range()    
+    }; -- in_range()
 };
 '>
 
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_agent_monitor.e b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_agent_monitor.e
index a41dd20..c09ce31 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_agent_monitor.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_agent_monitor.e
@@ -1,11 +1,11 @@
-/*------------------------------------------------------------------------- 
+/*-------------------------------------------------------------------------
 File name   : xbus_agent_monitor.e
 Title       : Agent Monitor implementation
 Project     : XBus UVC
 Created     : 2008
 Description : This file implements the agent monitor unit.
-Notes       : 
---------------------------------------------------------------------------- 
+Notes       :
+---------------------------------------------------------------------------
 //----------------------------------------------------------------------
 //   Copyright 2008-2010 Cadence Design Systems, Inc.
 //   All Rights Reserved Worldwide
@@ -24,7 +24,7 @@ Notes       :
 //   the License for the specific language governing
 //   permissions and limitations under the License.
 //----------------------------------------------------------------------
--------------------------------------------------------------------------*/ 
+-------------------------------------------------------------------------*/
 
 <'
 
@@ -37,13 +37,13 @@ extend xbus_agent_monitor_u {
     -- This field is a pointer to the bus monitor. Note that this is set
     -- procedurally using connect_pointers().
     !bus_monitor : xbus_bus_monitor_u;
-    
+
 
     -- This method writes a header for use at the top of log files.
     private write_log_header() is {
         -- Write date and time, filename etc. along with field headings
-        message(XBUS_FILE, LOW, 
-                append(append(file_logger.to_file, ".elog"), 
+        message(XBUS_FILE, LOW,
+                append(append(file_logger.to_file, ".elog"),
                        " - created ", date_time()));
         message(XBUS_FILE, LOW, "");
         message(XBUS_FILE, LOW,
@@ -52,11 +52,11 @@ extend xbus_agent_monitor_u {
                 "    ****    *****       ******* **** ***   **** ***** ******");
         message(XBUS_FILE, LOW, "");
     }; -- write_log_header()
-    
+
     -- This field is used to ensure that the log file header is not rewritten
     -- if reset is reapplied during the test.
     private !log_header_written : bool;
-    
+
     -- If this is the beginning of the test, write a file log header. The
     -- log_header_written field is used to prevent the log header being
     -- written again if rerun() is called.
@@ -66,30 +66,30 @@ extend xbus_agent_monitor_u {
             log_header_written = TRUE;
         };
     }; -- run()
-    
+
     -- This method reports the current status of the agent monitor.
     show_status() is {
         if kind != ARBITER {
-            message(LOW, "Agent monitor detected ", dec(num_transfers), 
+            message(LOW, "Agent monitor detected ", dec(num_transfers),
                     " transfers");
         };
     }; -- show_status()
-    
+
     -- This event emitted when this agent monitor detects a
     -- transfer that is relevant to it.
     event agent_trans_end;
-    
-    // Implement the in port 
-    write(new_transfer : MONITOR xbus_trans_s) is {  
-        if (new_transfer.slave_name == agent_name or 
+
+    // Implement the in port
+    write(new_transfer : MONITOR xbus_trans_s) is {
+        if (new_transfer.slave_name == agent_name or
             new_transfer.master_name == agent_name) {
             emit agent_trans_end;
-            transfer_ended_o$.write(new_transfer); 
+            transfer_ended_o$.write(new_transfer);
             num_transfers += 1;
             msg_ended(MEDIUM, "Monitoring transfer", new_transfer);
-            message(XBUS_FILE, MEDIUM, 
+            message(XBUS_FILE, MEDIUM,
                     new_transfer.log_transfer(appendf("%8d    %-11.11s ",
-                                                      sys.time, 
+                                                      sys.time,
                                                       agent_name)));
         };
     }; -- transfer_ended_i()
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_agent_monitor_h.e b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_agent_monitor_h.e
index c876931..0ac110d 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_agent_monitor_h.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_agent_monitor_h.e
@@ -1,4 +1,4 @@
-/*-------------------------------------------------------------------------  
+/*-------------------------------------------------------------------------
 File name   : xbus_agent_monitor_h.e
 Title       : Agent Monitor Declaration
 Project     : XBus UVC
@@ -7,7 +7,7 @@ Description : This file declares the agent monitor unit.
 Notes       : The agent monitor (used in masters and slaves) filters the
             : information collected by the bus monitor to isolate those
             : transfers being handled by a specific agent.
---------------------------------------------------------------------------- 
+---------------------------------------------------------------------------
 //----------------------------------------------------------------------
 //   Copyright 2008-2010 Cadence Design Systems, Inc.
 //   All Rights Reserved Worldwide
@@ -26,7 +26,7 @@ Notes       : The agent monitor (used in masters and slaves) filters the
 //   the License for the specific language governing
 //   permissions and limitations under the License.
 //----------------------------------------------------------------------
--------------------------------------------------------------------------*/ 
+-------------------------------------------------------------------------*/
 
 <'
 
@@ -43,7 +43,7 @@ unit xbus_agent_monitor_u like uvm_monitor {
     -- monitoring. This field is automatically constrained by the UVC and
     -- should not be constrained by the user.
     bus_name: xbus_bus_name_t;
-    
+
     -- This field is the logical name of the agent this agent monitor is
     -- monitoring. This field is automatically constrained by the UVC and
     -- should not be constrained by the user.
@@ -53,7 +53,7 @@ unit xbus_agent_monitor_u like uvm_monitor {
     -- UVM_SIGNAL, UVM_TLM, UVM_ACCEL, UVM_SIGNAL_SC
     abstraction_level : uvm_abstraction_level_t;
       keep soft abstraction_level == UVM_SIGNAL;
-    
+
     -- This field indicates whether this agent monitor for a MASTER, SLAVE or
     -- ARBITER. Note that arbiter monitors don't actually have any
     -- functionality. This field is automatically constrained by the UVC and
@@ -64,13 +64,13 @@ unit xbus_agent_monitor_u like uvm_monitor {
     -- automatically constrained by the UVC and should not be constrained by
     -- the user.
     has_checks : bool;
-        
+
     -- If this field is not "" then the agent monitor writes a log file of
     -- that name (with a ".elog" extension). By default, no log file is
     -- written by the agent monitor.
     log_filename : string;
         keep soft log_filename == "";
-        
+
     -- This is the logger used for creating log files. The user should not
     -- normally constrain this field.
     file_logger : message_logger is instance;
@@ -84,7 +84,7 @@ unit xbus_agent_monitor_u like uvm_monitor {
     transfer_ended_i : in interface_port of tlm_analysis of
                                           MONITOR xbus_trans_s is instance;
        keep bind (transfer_ended_i, empty);
-    
+
     write(transfer : MONITOR xbus_trans_s ) is empty;
 
     -- This method port is the scoreboard hook for the agent monitor. This
@@ -98,8 +98,8 @@ unit xbus_agent_monitor_u like uvm_monitor {
 
     -- This field counts the number of transfers monitored at this agent
     -- during the test. The user should not alter this field.
-    !num_transfers : uint; 
-    
+    !num_transfers : uint;
+
 }; -- unit xbus_agent_monitor_u
 
 '>
@@ -111,7 +111,7 @@ extend MASTER xbus_agent_monitor_u {
     -- This field is a pointer to the synchronizer. This pointer is needed for
     -- protocol checking.
     synch : xbus_synchronizer_u;
-    
+
     -- This is a pointer to the specific signals of the master. This pointer is
     -- needed for protocol checking.
     msmp : xbus_master_signal_map_u;
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_arbiter_agent.e b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_arbiter_agent.e
index 511cc09..62018e5 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_arbiter_agent.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_arbiter_agent.e
@@ -1,12 +1,12 @@
-/*------------------------------------------------------------------------- 
+/*-------------------------------------------------------------------------
 File name   : xbus_slave_agent.e
 Title       : XBus Slave Agent
 Project     : UVM XBus UVC
-Developers  :  
+Developers  :
 Created     : 2008
-Description : 
-Notes       : 
---------------------------------------------------------------------------- 
+Description :
+Notes       :
+---------------------------------------------------------------------------
 //----------------------------------------------------------------------
 //   Copyright 2008-2010 Cadence Design Systems, Inc.
 //   All Rights Reserved Worldwide
@@ -25,8 +25,8 @@ Notes       :
 //   the License for the specific language governing
 //   permissions and limitations under the License.
 //----------------------------------------------------------------------
--------------------------------------------------------------------------*/ 
- 
+-------------------------------------------------------------------------*/
+
 <'
 
 package cdn_xbus;
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_arbiter_bfm.e b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_arbiter_bfm.e
index 1a5fde6..db01198 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_arbiter_bfm.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_arbiter_bfm.e
@@ -1,11 +1,11 @@
-/*------------------------------------------------------------------------- 
+/*-------------------------------------------------------------------------
 File name   : xbus_arbiter_bfm.e
 Title       : Arbiter BFM
 Project     : XBus UVC
 Created     : 2008
 Description : This file adds arbiter functionality to the generic BFM.
 Notes       : This is a re-active sequence driver
---------------------------------------------------------------------------- 
+---------------------------------------------------------------------------
 //----------------------------------------------------------------------
 //   Copyright 2008-2010 Cadence Design Systems, Inc.
 //   All Rights Reserved Worldwide
@@ -24,7 +24,7 @@ Notes       : This is a re-active sequence driver
 //   the License for the specific language governing
 //   permissions and limitations under the License.
 //----------------------------------------------------------------------
--------------------------------------------------------------------------*/ 
+-------------------------------------------------------------------------*/
 
 <'
 
@@ -32,44 +32,44 @@ package cdn_xbus;
 
 
 extend ARBITER xbus_bfm_u {
-    
+
     // testflow main methods are expected to be found in the top portion of the
     // unit to better recognize the functional behavior of the unit
-    
+
     tf_env_setup() @tf_phase_clock is also {
         -- Make sure that all gnt signals start the test low.
         for each (msmp) in msmps {
             msmp.sig_grant$ = 0;
         };
-    }; 
-    
+    };
+
     tf_reset() @tf_phase_clock is also {
         -- drive START low during reset
         smp.sig_start$ = 0;
     };
-    
+
     tf_init_dut() @tf_phase_clock is also {
         start drive_transfers();
         // Register the thread as running until POST_TEST, non blocking
-        tf_get_domain_mgr().register_thread_by_name(me, "drive_transfers", 
+        tf_get_domain_mgr().register_thread_by_name(me, "drive_transfers",
                                                     POST_TEST, FALSE);
     };
-    
+
     -- This is a list of pointers to the master signal maps.
-    msmps : list of xbus_master_signal_map_u; 
+    msmps : list of xbus_master_signal_map_u;
 
     -- This field indicates the currently granted master.
     private !current_granted_master : MASTER xbus_agent_u;
-    
-    -- This event is emitted for each arbitration phase.    
+
+    -- This event is emitted for each arbitration phase.
     event start_asserted is rise
       (smp.sig_start$ == 1 and not synch.reset_asserted) @synch.clock_fall;
-    
+
     -- This code starts the arbitration BFM each time a new transfer starts.
     on start_asserted {
         start handle_arbitration();
     }; -- on start_asserted
-    
+
     -- This TCM handles the arbitration phase. It gets started each time the
     -- 'start' signal is asserted.
     package handle_arbitration() @tf_phase_clock is {
@@ -77,16 +77,16 @@ extend ARBITER xbus_bfm_u {
         -- Get a list of the masters requesting the bus and pass this to the
         -- sequence driver.
         driver.requests = msmps.all(.sig_request$ == 1).apply(it.master);
-            
+
         -- Ask the sequence driver for a decision on this arbitration phase.
-       
+
         var decision := driver.try_next_item();
         if decision == NULL {
             error("Arbiter sequence driver provided NULL arbitration decision");
         };
-        
+
         current_granted_master = decision.granted_master;
-        
+
         messagef(HIGH, "Abitration chose: ") {
             if current_granted_master == NULL {
                 out(" NULL (no requests pending)");
@@ -94,7 +94,7 @@ extend ARBITER xbus_bfm_u {
                 out(current_granted_master.agent_name);
             };
         };
-        
+
         -- Drive the appropriate gnt signal high (and the others low).
         for each (msmp) in msmps {
             if msmp.master == current_granted_master {
@@ -103,13 +103,13 @@ extend ARBITER xbus_bfm_u {
                 msmp.sig_grant$ = 0;
             };
         };
-        
+
         -- Wait until end of arbitration phase.
         wait cycle;
-        
+
         -- Inform the sequence driver that the arbitration phase is over.
-        emit driver.item_done; 
-         
+        emit driver.item_done;
+
         -- Between arbitration phases, drive all gnt signals low.
         for each (msmp) in msmps {
             msmp.sig_grant$ = 0;
@@ -120,14 +120,14 @@ extend ARBITER xbus_bfm_u {
     -- single transfer. This includes driving the start signal and driving
     -- a NOP transfer if necessary.
     private drive_transfer() @synch.clock_rise is {
-    
+
         -- Drive start high during Arbitration Phase.
         smp.sig_start$ = 1;
         wait cycle;
         smp.sig_start$ = 0;
-        
+
         -- Now we're at the start of the Address Phase.
-        -- Check to see if any masters have been granted the bus - 
+        -- Check to see if any masters have been granted the bus -
         -- if not, then do a NOP transfer.
         if current_granted_master == NULL {
             -- This is a NOP transfer
@@ -149,16 +149,16 @@ extend ARBITER xbus_bfm_u {
             wait @bus_monitor.transfer_end;
         }; -- if current_granted_master == NULL;
     }; -- drive_transfer()
-    
-    -- This TCM continually calls do_transfer() 
-    
-    private drive_transfers() @tf_phase_clock is {      
+
+    -- This TCM continually calls do_transfer()
+
+    private drive_transfers() @tf_phase_clock is {
         while TRUE {
             drive_transfer();
         }; -- while TRUE
     }; -- drive_transfers()
-                
-    
+
+
 }; -- extend ARBITER xbus_bfm_u {
 
 '>
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_arbiter_sequence_h.e b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_arbiter_sequence_h.e
index 15e7f79..f034a62 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_arbiter_sequence_h.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_arbiter_sequence_h.e
@@ -1,4 +1,4 @@
-/*------------------------------------------------------------------------- 
+/*-------------------------------------------------------------------------
 File name   : xbus_arbiter_sequence.e
 Title       : Sequence interface for ACTIVE arbiter agents
 Project     : XBus UVC
@@ -7,8 +7,8 @@ Description : This file provides a sequence interface for the arbiter. By
             : default, this sequence driver will take a random decision for
             : each arbitration phase. However, the user can over-ride the
             : default behaviour to control specific arbitration decisions.
-Notes       : 
---------------------------------------------------------------------------- 
+Notes       :
+---------------------------------------------------------------------------
 //----------------------------------------------------------------------
 //   Copyright 2008-2010 Cadence Design Systems, Inc.
 //   All Rights Reserved Worldwide
@@ -27,7 +27,7 @@ Notes       :
 //   the License for the specific language governing
 //   permissions and limitations under the License.
 //----------------------------------------------------------------------
--------------------------------------------------------------------------*/ 
+-------------------------------------------------------------------------*/
 
 <'
 
@@ -42,14 +42,14 @@ struct xbus_arbiter_decision_s like any_sequence_item {
     -- automatically constrained by the UVC and should not be constrained by
     -- the user.
     bus_name : xbus_bus_name_t;
-        keep bus_name == read_only(driver.bus_name);    
-   
+        keep bus_name == read_only(driver.bus_name);
+
     -- This field is used to sub-type the decision struct according to which
     -- arbiter agent it is for. This field is automatically constrained by the
     -- UVC and should not be constrained by the user.
     arbiter_name : xbus_agent_name_t;
         keep arbiter_name == read_only(driver.arbiter_name);
-    
+
     -- This field contains the list of masters that are requesting the bus.
     -- This field is automatically constrained by the UVC and should not be
     -- constrained or altered by the user.
@@ -61,9 +61,9 @@ struct xbus_arbiter_decision_s like any_sequence_item {
     -- mentioned in the requests field or NULL.
     granted_master : MASTER xbus_agent_u;
         keep read_only(requests).is_empty() => granted_master == NULL;
-        keep not read_only(requests).is_empty() => 
+        keep not read_only(requests).is_empty() =>
                                       granted_master in read_only(requests);
-    
+
 }; -- struct xbus_arbiter_decision_s
 
 
@@ -83,8 +83,8 @@ extend xbus_arbiter_sequence {
     -- automatically constrained by the UVC and should not be constrained by
     -- the user.
     bus_name : xbus_bus_name_t;
-        keep bus_name == read_only(driver.bus_name);    
-   
+        keep bus_name == read_only(driver.bus_name);
+
     -- This field holds the logical name of the arbiter. This field is
     -- automatically constrained by the UVC and should not be constrained by
     -- the user.
@@ -95,24 +95,24 @@ extend xbus_arbiter_sequence {
     -- do "do decision ...".
     !decision : xbus_arbiter_decision_s;
 
-    // Cover the sequence. 
+    // Cover the sequence.
     // Ignore the pre-defined kinds, they do not add info to the coverage
     cover ended is {
         item kind using ignore = (kind == RANDOM or
                                   kind == SIMPLE or
                                   kind == MAIN);
-    }; 
+    };
 }; -- extend xbus_arbiter_sequence
 
 
-// since arbitration should begin immediately after reset this sequence is 
+// since arbitration should begin immediately after reset this sequence is
 // an init_dut phase seq and not main_test seq
 extend MAIN INIT_DUT xbus_arbiter_sequence {
-    
+
     -- The arbiter sequence driver is a reactive sequence driver so, by
     -- default we don't want it to ever run out of sequence items.
     keep soft count == MAX_UINT;
-      
+
     body() @driver.clock is only {
         for i from 0 to MAX_UINT {
             do decision;
@@ -135,13 +135,13 @@ extend xbus_arbiter_driver_u {
     synch : xbus_synchronizer_u;
 
     // tf_phase_clock if the testflow clock and might change according to
-    // current test phase. it is recommended to bind driver.clock to this 
+    // current test phase. it is recommended to bind driver.clock to this
     // clock;
     event tf_phase_clock is only @synch.unqualified_clock_fall;
     on tf_phase_clock {
         emit clock;
     };
-    
+
     // sequences are influenced by test phases but do not influence
     // the test flow (usually they use while TRUE loops) this behavior is
     // declared by this flag
@@ -151,7 +151,7 @@ extend xbus_arbiter_driver_u {
     -- automatically constrained by the UVC and should not be constrained by
     -- the user.
     bus_name : xbus_bus_name_t;
-   
+
     -- This field holds the logical name of the arbiter. This field is
     -- automatically constrained by the UVC and should not be constrained by
     -- the user.
@@ -161,7 +161,7 @@ extend xbus_arbiter_driver_u {
     -- currently requesting the bus immediately prior to calling
     -- try_next_item().
     package !requests : list of MASTER xbus_agent_u;
-    
+
 }; -- extend xbus_arbiter_driver_u
 
 
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_basic_seq_lib.e b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_basic_seq_lib.e
index 71e3c1f..02801bf 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_basic_seq_lib.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_basic_seq_lib.e
@@ -1,11 +1,11 @@
-/*-------------------------------------------------------------------------  
+/*-------------------------------------------------------------------------
 File name   : xbus_basic_seq_lib.e
 Title       : ACTIVE master sequence lib
 Project     : XBus UVC
 Created     : 2008
 Description : This file provides basic sequences for the master.
-Notes       : 
---------------------------------------------------------------------------- 
+Notes       :
+---------------------------------------------------------------------------
 //----------------------------------------------------------------------
 //   Copyright 2008-2010 Cadence Design Systems, Inc.
 //   All Rights Reserved Worldwide
@@ -24,7 +24,7 @@ Notes       :
 //   the License for the specific language governing
 //   permissions and limitations under the License.
 //----------------------------------------------------------------------
--------------------------------------------------------------------------*/ 
+-------------------------------------------------------------------------*/
 
 <'
 
@@ -39,53 +39,53 @@ extend xbus_master_sequence_kind : [WRITE_TRANSFER,
 
 
 extend WRITE_TRANSFER xbus_master_sequence {
-    
+
     -- This field specifies the base address
     base_addr : uint(bits:16);
         keep soft base_addr == 0;
-    
+
     size : uint;
       keep size in [1, 2, 4, 8];
-    
+
     -- This field contains the payload of the frame to be written.
     data      : uint(bits:64);
-    
+
     body() @driver.clock is only {
         write(size, base_addr, data);
     }; -- body()
 };
 
 extend READ_TRANSFER xbus_master_sequence {
-    
+
     -- This field specifies the base address
     base_addr : uint(bits:16);
         keep soft base_addr in [0,0x7ff0 ];
-    
+
     size : uint;
       keep size in [1, 2, 4, 8];
-    
+
     -- This field contains the payload of the frame to be written.
     data      : uint(bits:64);
-    
+
     body() @driver.clock is only {
         data = read(size, base_addr);
     }; -- body()
 };
 
 extend WRITE_AND_READ xbus_master_sequence {
-    
+
     -- This field specifies the base address
     base_addr : uint(bits:16);
         keep soft base_addr == 0;
-    
+
     -- This field contains the payload of the frame to be written.
     data : byte;
 
     !write_transfer : WRITE_TRANSFER xbus_master_sequence;
     !read_transfer  : READ_TRANSFER xbus_master_sequence;
-    
+
     body() @driver.clock is only {
-    
+
         do write_transfer keeping {
             .base_addr == base_addr;
             .data == data;
@@ -105,12 +105,12 @@ extend SEQ_WRITES_AND_READS xbus_master_sequence {
 
     start_data : byte;
         keep soft start_data == 0;
-    
+
     !wr_seq: WRITE_AND_READ xbus_master_sequence;
-    
+
     seq_length : uint;
          keep soft seq_length in [5..15];
-    
+
     body() @driver.clock is only {
         for i from 0 to seq_length-1 {
             do wr_seq keeping {
@@ -118,11 +118,11 @@ extend SEQ_WRITES_AND_READS xbus_master_sequence {
                 .data == start_data + i;
             };
         };
-    };   
+    };
 };
 
 
 '>
 
 
- 
+
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_bfm.e b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_bfm.e
index 6d6461a..2f389f0 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_bfm.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_bfm.e
@@ -1,11 +1,11 @@
-/*-------------------------------------------------------------------------  
+/*-------------------------------------------------------------------------
 File name   : xbus_bfm.e
 Title       : BFM unit declaration and implemenentation
 Project     : XBus UVC
 Created     : 2008
 Description : This file is the declaration and implementation of the BFM unit.
-Notes       : 
---------------------------------------------------------------------------- 
+Notes       :
+---------------------------------------------------------------------------
 //----------------------------------------------------------------------
 //   Copyright 2008-2010 Cadence Design Systems, Inc.
 //   All Rights Reserved Worldwide
@@ -24,7 +24,7 @@ Notes       :
 //   the License for the specific language governing
 //   permissions and limitations under the License.
 //----------------------------------------------------------------------
--------------------------------------------------------------------------*/ 
+-------------------------------------------------------------------------*/
 
 <'
 
@@ -39,7 +39,7 @@ unit xbus_bfm_u like uvm_bfm {
     -- This field specifies whether this is a MASTER, SLAVE or ARBITER BFM?
     const kind : xbus_agent_kind_t;
 
-    
+
     // declare the unit as testflow unit.
     tf_testflow_unit;
     keep soft tf_domain == XBUS_TF;
@@ -59,7 +59,7 @@ unit xbus_bfm_u like uvm_bfm {
 
     -- This field is a pointer to the synchronizer.
     synch : xbus_synchronizer_u;
-    
+
     -- This field is a pointer to the bus signal map.
     smp : xbus_signal_map_u;
 
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_bus_collector.e b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_bus_collector.e
index 5f01859..2feca32 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_bus_collector.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_bus_collector.e
@@ -1,5 +1,5 @@
 
-/*------------------------------------------------------------------------- 
+/*-------------------------------------------------------------------------
 File name   : xbus_bus_collector.e
 Title       : Bus monitor implementation
 Project     : XBus UVC
@@ -9,8 +9,8 @@ Notes       : The bus collector collects all activity on the bus and collects
             : information on each transfer that occurs.
             : It passes the collected info, after basic processing, to the
             : monitor.
-            : The monitor performs higher level process, coverage and checks 
---------------------------------------------------------------------------- 
+            : The monitor performs higher level process, coverage and checks
+---------------------------------------------------------------------------
 //----------------------------------------------------------------------
 //   Copyright 2008-2010 Cadence Design Systems, Inc.
 //   All Rights Reserved Worldwide
@@ -29,7 +29,7 @@ Notes       : The bus collector collects all activity on the bus and collects
 //   the License for the specific language governing
 //   permissions and limitations under the License.
 //----------------------------------------------------------------------
--------------------------------------------------------------------------*/ 
+-------------------------------------------------------------------------*/
 
 <'
 package cdn_xbus;
@@ -46,7 +46,7 @@ import xbus_bus_collector_h.e;
 extend xbus_bus_collector_u {
     -- The collected transfer is built up in this field.
     package !transfer : MONITOR xbus_trans_s;
-  
+
     current_master_name : xbus_agent_name_t;
        keep soft current_master_name == NO_AGENT;
     current_slave_name  : xbus_agent_name_t;
@@ -54,12 +54,12 @@ extend xbus_bus_collector_u {
 
     -- This event is emitted by the monitor at the end of a transfer after
     -- it has finished filling in all the fields of the transfer field
-    event transfer_end; 
-    
+    event transfer_end;
+
     -- This event is the rising edge of the START signal.
     event start_rise is only
         rise(smp.sig_start$) @synch.clock_rise;
-        
+
     -- This event is the falling edge of the START signal.
     event start_fall is only
         fall(smp.sig_start$) @synch.clock_rise;
@@ -68,73 +68,73 @@ extend xbus_bus_collector_u {
     -- Arbitration Phase.
     event arbitration_phase is only
         {@synch.reset_end or @nop_cycle or @data_end; [1]} @synch.clock_rise;
-    
+
     -- This event is emitted at the rising edge of clock at the end of each
     -- Address Phase.
     event address_phase is only
         {@start_rise; [1]} @synch.clock_rise;
-    
+
     -- This event is emitted at the rising edge of clock at the end of each
     -- NOP Address Phase.
     event nop_cycle is only
         true((smp.sig_read$ == 0) and (smp.sig_write$ ==0)) @address_phase;
-    
-    
-    
+
+
+
     event read_normal_address_phase is
       true(smp.sig_read$ == 1 and !smp.sig_read.has_z()) @address_phase;
     event write_normal_address_phase is
       true(smp.sig_write$ == 1 and !smp.sig_write.has_z()) @address_phase;
-  
+
     -- This event is emitted at the rising edge of clock at the end of each
     -- non-NOP Address Phase
-    event normal_address_phase is only (@read_normal_address_phase or 
+    event normal_address_phase is only (@read_normal_address_phase or
                                         @write_normal_address_phase)  @address_phase;
-    
+
     -- This event is emitted at the rising edge of clock at the end of the
     -- first cycle of Data Phase.
     event data_start is only
         {@normal_address_phase; [1]} @synch.clock_rise;
-    
+
     -- This event is emitted at the rising edge of clock at the end of the
     -- last cycle of the Data Phase. This event signifies that a transfer
     -- (not a NOP) has completed. At this stage the transfer field contains
     -- a record of the transfer that occurred.
     event data_end is only
-        {@normal_address_phase; [..]; 
-         true((smp.sig_error$ == 1) or 
+        {@normal_address_phase; [..];
+         true((smp.sig_error$ == 1) or
               (smp.sig_bip$ == 0 and smp.sig_wait$ == 0 ))
         } @synch.clock_rise;
-    
+
     -- This event is emitted at the rising edge of clock at the end of each
     -- cycle of Data Phase.
     event data_phase is only
-        ({(@data_start and not @data_end); ~[..] * not @data_end} or 
+        ({(@data_start and not @data_end); ~[..] * not @data_end} or
          @data_end) @synch.clock_rise;
-    
+
     -- This event is emitted each time a wait state is inserted on the bus.
     event wait_state is only
         true(smp.sig_wait$ == 1) @data_phase;
-    
+
     -- This event is emitted each time a byte of data is valid on the bus.
     event data_valid is only
-        true(smp.sig_wait$ == 0) @data_phase; 
-    
+        true(smp.sig_wait$ == 0) @data_phase;
+
     -- This event is emitted each time the Data Phase is terminated by an
     -- error.
     event data_error is only
         true(smp.sig_error$ == 1) @data_phase;
-    
+
     -- This event is emitted each time a single byte transfer occurs in the
     -- Address Phase.
     event single_data is only
-        true(smp.sig_size$ == 0) @normal_address_phase;   
+        true(smp.sig_size$ == 0) @normal_address_phase;
 
     -- Collect information at the end of each arbitration phase.
     on arbitration_phase {
         monitor_arbitration_phase();
     };
-    
+
     -- This method determines which master (if any) won the Arbitration Phase.
     private monitor_arbitration_phase() is {
         for each (msmp) in msmps {
@@ -144,20 +144,20 @@ extend xbus_bus_collector_u {
             };
         };
     }; -- monitor_arbitration_phase()
-    
+
     -- Collect information at the end of each normal (i.e. not a NOP) address
     -- phase.
     on normal_address_phase {
         monitor_address_phase();
     };
-    
+
     -- This method creates a transfer instance and fills in the Address
-    -- Phase fields. This method also determines which slave should 
+    -- Phase fields. This method also determines which slave should
     -- respond to the transfer.
     private monitor_address_phase() is {
 
         -- create a new instance of a MONITOR xbus_tran_s;
-        transfer = new MONITOR xbus_trans_s with { 
+        transfer = new MONITOR xbus_trans_s with {
             it.addr = smp.sig_addr$;
             it.size = smp.get_size();
             it.read_write = smp.get_read_write();
@@ -166,13 +166,13 @@ extend xbus_bus_collector_u {
         transfer.waits.add(0);
         msg_started(HIGH, "Bus Collecting transfer", transfer);
         transfer_started_o$.write(transfer);
-    }; -- monitor_address_phase()    
-    
+    }; -- monitor_address_phase()
+
     -- Count any wait states that get inserted.
     on wait_state {
         monitor_wait_state();
     };
-    
+
     -- This method increments the wait state counter for the current data
     -- byte of the transfer. Note that we are guaranteed that the waits list
     -- in the transfer has at least one item on it because the
@@ -182,12 +182,12 @@ extend xbus_bus_collector_u {
     private monitor_wait_state() is {
         transfer.waits.push(transfer.waits.pop() +1);
     }; -- monitor_wait_state()
-    
+
     -- Collect each data byte during the transfer.
     on data_valid {
         monitor_data_byte();
     };
-    
+
     -- This method captures a single data byte of the transfer and
     -- adds it to the data field of transfer.
     private monitor_data_byte() is {
@@ -206,8 +206,8 @@ extend xbus_bus_collector_u {
             transfer.waits.add(0);
         };
     }; -- monitor_data_byte()
-    
-    
+
+
 };
 '>
 
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_bus_collector_h.e b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_bus_collector_h.e
index 7fa58a7..5cfa351 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_bus_collector_h.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_bus_collector_h.e
@@ -1,4 +1,4 @@
-/*-------------------------------------------------------------------------  
+/*-------------------------------------------------------------------------
 File name   : xbus_bus_collector_h.e
 Title       : Bus collector declaration
 Project     : XBus UVC
@@ -9,7 +9,7 @@ Notes       : The bus collector collects all activity on the bus and collects
             : It passes the collected info, after basic processing, to the
             : monitor.
             : The monitor performs higher level process, coverage and checks
---------------------------------------------------------------------------- 
+---------------------------------------------------------------------------
 //----------------------------------------------------------------------
 //   Copyright 2008-2010 Cadence Design Systems, Inc.
 //   All Rights Reserved Worldwide
@@ -28,10 +28,10 @@ Notes       : The bus collector collects all activity on the bus and collects
 //   the License for the specific language governing
 //   permissions and limitations under the License.
 //----------------------------------------------------------------------
--------------------------------------------------------------------------*/ 
+-------------------------------------------------------------------------*/
+
+
 
-  
-  
 <'
 
 package cdn_xbus;
@@ -57,13 +57,13 @@ extend MONITOR xbus_trans_s {
     -- This field is used by the monitor to collect the actual number of waits
     -- states for each byte of the transfer.
     !waits : list of uint;
-    
+
     -- This field is used by the monitor to log the position of any error. A
     -- 0 value means no error occurred.
     !error_pos_mon : uint;
 
 }; -- extend MONITOR xbus_trans_s
-            
+
 '>
 
 
@@ -75,7 +75,7 @@ extend MONITOR xbus_trans_s {
 -- This unit is the Bus Collector. The Bus Monitor monitors all activity on the
 -- bus and collects information on each transfer that occurs.
 unit xbus_bus_collector_u like uvm_collector {
-    
+
     -- This field holds the logical name of the bus containing this bus
     -- monitor. This field is automatically constrained by the UVC and should
     -- not be constrained by the user.
@@ -98,7 +98,7 @@ unit xbus_bus_collector_u like uvm_collector {
 
     -- This field is a pointer to the synchronizer.
     synch : xbus_synchronizer_u;
-    
+
     -- This field is a pointer to the bus signal map.
     smp : xbus_signal_map_u;
 
@@ -106,54 +106,54 @@ unit xbus_bus_collector_u like uvm_collector {
     msmps : list of xbus_master_signal_map_u;
 
     -- Events
-    
+
     -- This event is the rising edge of the START signal.
     event start_rise;
-        
+
     -- This event is the falling edge of the START signal.
     event start_fall;
 
     -- This event is emitted at the rising edge of clock at the end of each
     -- Arbitration Phase.
     event arbitration_phase;
-    
+
     -- This event is emitted at the rising edge of clock at the end of each
     -- Address Phase.
     event address_phase;
-    
+
     -- This event is emitted at the rising edge of clock at the end of each
     -- NOP Address Phase.
     event nop_cycle;
-    
+
     -- This event is emitted at the rising edge of clock at the end of each
     -- non-NOP Address Phase
     event normal_address_phase;
-    
+
     -- This event is emitted at the rising edge of clock at the end of the
     -- first cycle of Data Phase.
     event data_start;
-    
+
 
     -- This event is emitted at the rising edge of clock at the end of the
     -- last cycle of the Data Phase. This event signifies that a transfer
     -- (not a NOP) has completed. At this stage the transfer field contains
     -- a record of the transfer that occurred.
     event data_end;
-    
+
     -- This event is emitted at the rising edge of clock at the end of each
     -- cycle of Data Phase.
     event data_phase;
-    
+
     -- This event is emitted each time a wait state is inserted on the bus.
     event wait_state;
-    
+
     -- This event is emitted each time a byte of data is valid on the bus.
     event data_valid;
-    
+
     -- This event is emitted each time the Data Phase is terminated by an
     -- error.
     event data_error;
-    
+
     -- This event is emitted each time a single byte transfer occurs in the
     -- Address Phase.
     event single_data;
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_bus_monitor.e b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_bus_monitor.e
index ffdf30b..f2b6bf4 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_bus_monitor.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_bus_monitor.e
@@ -1,4 +1,4 @@
-/*------------------------------------------------------------------------- 
+/*-------------------------------------------------------------------------
 File name   : xbus_bus_monitor.e
 Title       : Bus monitor implementation
 Project     : XBus UVC
@@ -8,8 +8,8 @@ Notes       : The bus collector collects all activity on the bus and collects
             : information on each transfer that occurs.
             : It passes the collected info, after basic processing, to the
             : monitor.
-            : The monitor performs higher level process, coverage and checks 
---------------------------------------------------------------------------- 
+            : The monitor performs higher level process, coverage and checks
+---------------------------------------------------------------------------
 //----------------------------------------------------------------------
 //   Copyright 2008-2010 Cadence Design Systems, Inc.
 //   All Rights Reserved Worldwide
@@ -28,7 +28,7 @@ Notes       : The bus collector collects all activity on the bus and collects
 //   the License for the specific language governing
 //   permissions and limitations under the License.
 //----------------------------------------------------------------------
--------------------------------------------------------------------------*/ 
+-------------------------------------------------------------------------*/
 
 <'
 
@@ -49,10 +49,10 @@ extend MONITOR xbus_trans_s {
             result = appendf("%02x", d);
         };
     }; -- log_data_byte()
-    
+
     -- This method returns a string representation of the data, wait states
     -- and error condition of a transfer.
-    private log_data(read : bool, data : uint, waits : uint, err : bool) : 
+    private log_data(read : bool, data : uint, waits : uint, err : bool) :
                                                                     string is {
         result = appendf("%s   %-6d", log_data_byte(read,data, err), waits);
         if err {
@@ -61,7 +61,7 @@ extend MONITOR xbus_trans_s {
             result = append(result, "OK");
         };
     }; -- log_data()
-    
+
     -- This method returns a log file entry for this transfer. The first
     -- line of the entry is indented with the string specified in the
     -- 'leader' parameter. Subsequent lines are indented to line up with
@@ -72,13 +72,13 @@ extend MONITOR xbus_trans_s {
                 result = appendf("%s%04x    %-5d%-6s", leader,
                                  addr, size, read_write);
             } else {
-                result = appendf("%s\n%s", result, 
+                result = appendf("%s\n%s", result,
                                  str_pad("", str_len(leader)+19));
             };
-            result = appendf("%s%s", result, 
+            result = appendf("%s%s", result,
                              log_data(read_write == READ,
-                                      data[i-1], 
-                                      waits[i-1], 
+                                      data[i-1],
+                                      waits[i-1],
                                       i == error_pos_mon));
             if i == error_pos_mon {
                 break;
@@ -106,14 +106,14 @@ extend xbus_bus_monitor_u {
 
     -- This event is emitted by the monitor at the end of a transfer after
     -- it has finished filling in all the fields of the transfer field
-    event transfer_end;  
+    event transfer_end;
+
 
-    
     -- This method writes a header for use at the top of the bus log file.
     private write_log_header() is {
         -- Write date and time, filename etc. along with field headings
-        message(XBUS_FILE, LOW, 
-                append(append(file_logger.to_file, ".elog"), 
+        message(XBUS_FILE, LOW,
+                append(append(file_logger.to_file, ".elog"),
                        " - created ", date_time()));
         message(XBUS_FILE, LOW, "");
         message(XBUS_FILE, LOW,
@@ -127,8 +127,8 @@ extend xbus_bus_monitor_u {
 
     -- This field is used to ensure that the log file header is not rewritten
     -- if reset is reapplied during the test.
-    private !log_header_written : bool; 
-    
+    private !log_header_written : bool;
+
     -- If this is the beginning of the test, write a file log header. The
     -- log_header_written field is used to prevent the log header being
     -- written again if rerun() is called.
@@ -141,36 +141,36 @@ extend xbus_bus_monitor_u {
     }; -- run()
 
     -- Implement the in ports
-    started_write(new_transfer : MONITOR xbus_trans_s ) is also {  
+    started_write(new_transfer : MONITOR xbus_trans_s ) is also {
         transfer = new_transfer;
         msg_started(MEDIUM, "Bus Monitoring transfer", transfer);
     };
-    
-    ended_write(new_transfer : MONITOR xbus_trans_s ) is also {  
+
+    ended_write(new_transfer : MONITOR xbus_trans_s ) is also {
         num_transfers += 1;
         emit transfer_end;
         -- determine which slave is responsible for this transfer.
         transfer.slave_name = find_slave_of_addr(transfer.addr);
-        
+
         message(HIGH, "bus_monitor got transfer ", num_transfers,
                 " ", transfer);
-        
+
         msg_ended(MEDIUM, "Bus Monitoring transfer", transfer);
-        
+
         -- Ensure that each transfer is written to the log file.
         message(XBUS_FILE, MEDIUM,
-                transfer.log_transfer(appendf("%8d    %-11.11s %-11.11s ", 
+                transfer.log_transfer(appendf("%8d    %-11.11s %-11.11s ",
                     sys.time, transfer.master_name, transfer.slave_name)));
 
         transfer_ended_o$.write(transfer);
     }; -- transfer_ended_i
-    
+
     -- This method returns the current status of the bus monitor.
     show_status() is {
-        message(LOW, "Bus monitor detected ", dec(num_transfers), 
+        message(LOW, "Bus monitor detected ", dec(num_transfers),
                 " transfers");
     }; -- show_status()
-    
+
     -- This method determines which slave is responsible for this address.
     find_slave_of_addr(addr : xbus_addr_t) : xbus_agent_name_t is {
         for each (config) in slave_configs {
@@ -179,7 +179,7 @@ extend xbus_bus_monitor_u {
                 break;
             };
         };
-        
+
     };
 }; -- extend xbus_bus_monitor_u
 
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_bus_monitor_h.e b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_bus_monitor_h.e
index ea13ef0..593fdb2 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_bus_monitor_h.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_bus_monitor_h.e
@@ -1,4 +1,4 @@
-/*-------------------------------------------------------------------------  
+/*-------------------------------------------------------------------------
 File name   : xbus_bus_monitor_h.e
 Title       : Bus monitor declaration
 Project     : XBus UVC
@@ -9,7 +9,7 @@ Notes       : The bus collector collects all activity on the bus and collects
             : It passes the collected info, after basic processing, to the
             : monitor.
             : The monitor performs higher level process, coverage and checks
---------------------------------------------------------------------------- 
+---------------------------------------------------------------------------
 //----------------------------------------------------------------------
 //   Copyright 2008-2010 Cadence Design Systems, Inc.
 //   All Rights Reserved Worldwide
@@ -28,7 +28,7 @@ Notes       : The bus collector collects all activity on the bus and collects
 //   the License for the specific language governing
 //   permissions and limitations under the License.
 //----------------------------------------------------------------------
--------------------------------------------------------------------------*/ 
+-------------------------------------------------------------------------*/
 
 <'
 package cdn_xbus;
@@ -40,11 +40,11 @@ package cdn_xbus;
 ===================================
 
 <'
--- This unit is the Bus Monitor. The Bus Monitor gets the information from 
+-- This unit is the Bus Monitor. The Bus Monitor gets the information from
 -- the collector, performs coverage and checks, and export information to
 -- other components via ports.
 unit xbus_bus_monitor_u like uvm_monitor {
-    
+
     -- This field holds the abstraction level:
     -- UVM_SIGNAL, UVM_TLM, UVM_ACCEL, UVM_SIGNAL_SC
     abstraction_level : uvm_abstraction_level_t;
@@ -52,22 +52,22 @@ unit xbus_bus_monitor_u like uvm_monitor {
 
     collector : xbus_bus_collector_u is instance;
       keep collector.has_checks == value(has_checks);
-    
+
     // Belong to the XBUS_TF TestFlow domain
     tf_testflow_unit;
     keep soft tf_domain == XBUS_TF;
     event tf_phase_clock is only @synch.unqualified_clock_rise;
-    
+
     -- This field holds the logical name of the bus containing this bus
     -- monitor. This field is automatically constrained by the UVC and should
     -- not be constrained by the user.
     bus_name : xbus_bus_name_t;
        keep collector.bus_name == value(bus_name);
-    
+
     -- This field is a pointer to the synchronizer.
     synch : xbus_synchronizer_u;
        keep collector.synch == value(synch);
-    
+
     -- This is a list of pointers to the slave configuration units.
     slave_configs : list of xbus_slave_config_u;
 
@@ -90,9 +90,9 @@ unit xbus_bus_monitor_u like uvm_monitor {
         keep file_logger.to_file == log_filename;
         keep soft file_logger.format == none;
         keep soft file_logger.verbosity == FULL;
-        
-    
-    
+
+
+
     -- This field is used to count the total number of transfers monitored
     -- during the test.
     !num_transfers : uint;
@@ -108,7 +108,7 @@ unit xbus_bus_monitor_u like uvm_monitor {
                                          using prefix=ended_
                                          is instance;
        keep bind (transfer_ended_i, collector.transfer_ended_o);
-    
+
     started_write(new_transfer : MONITOR xbus_trans_s ) is {};
     ended_write(new_transfer : MONITOR xbus_trans_s ) is {};
 
@@ -117,7 +117,7 @@ unit xbus_bus_monitor_u like uvm_monitor {
     -- bus. Note that the scoreboard hook is bound to empty so that no error
     -- is issued if the hook is not in use.
     transfer_ended_o : out interface_port of tlm_analysis of
-                                          MONITOR xbus_trans_s 
+                                          MONITOR xbus_trans_s
                                           is instance;
         keep bind (transfer_ended_o, empty);
 
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_coverage.e b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_coverage.e
index 3e2e9a1..3c93b3e 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_coverage.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_coverage.e
@@ -1,12 +1,12 @@
-/*-------------------------------------------------------------------------  
+/*-------------------------------------------------------------------------
 File name   : xbus_coverage.e
 Title       : Coverage
 Project     : XBus UVC
 Created     : 2008
 Description : This file provides functional coverage in the bus and agent
             : monitors.
-Notes       : 
---------------------------------------------------------------------------- 
+Notes       :
+---------------------------------------------------------------------------
 //----------------------------------------------------------------------
 //   Copyright 2008-2010 Cadence Design Systems, Inc.
 //   All Rights Reserved Worldwide
@@ -25,7 +25,7 @@ Notes       :
 //   the License for the specific language governing
 //   permissions and limitations under the License.
 //----------------------------------------------------------------------
--------------------------------------------------------------------------*/ 
+-------------------------------------------------------------------------*/
 
 <'
 
@@ -37,7 +37,7 @@ package cdn_xbus;
 extend xbus_bus_monitor_u {
     cover transfer_end is {
         item addr : uint(bits:16) = transfer.addr;
-        item read_write :xbus_read_write_t = transfer.read_write 
+        item read_write :xbus_read_write_t = transfer.read_write
             using ignore = (read_write == NOP);
         item size : uint [1, 2, 4, 8] = transfer.size;
     };
@@ -51,7 +51,7 @@ extend xbus_agent_monitor_u {
         item name : xbus_agent_name_t = agent.agent_name
             using per_instance;
         item addr : uint(bits:16) = bus_monitor.transfer.addr;
-        item read_write :xbus_read_write_t = bus_monitor.transfer.read_write 
+        item read_write :xbus_read_write_t = bus_monitor.transfer.read_write
             using ignore = (read_write == NOP);
         item size : uint [1, 2, 4, 8] = bus_monitor.transfer.size;
     };
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_end_test.e b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_end_test.e
index feaecd7..3de0095 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_end_test.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_end_test.e
@@ -1,4 +1,4 @@
-/*-------------------------------------------------------------------------  
+/*-------------------------------------------------------------------------
 File name   : xbus_end_test.e
 Title       : End of test stuff
 Project     : XBus UVC
@@ -6,9 +6,9 @@ Created     : 2008
 Description : This file handles 'end of test'.
 Notes       : End of test handling is done using the objection mechanism.
             : Each proactive MAIN sequence (note that for XBus, only MASTER
-            : sequences are proactive) raises an objection to TEST_DONE 
+            : sequences are proactive) raises an objection to TEST_DONE
             : in ENV_SETUP phase, and drops the objection in POST_TEST phase
---------------------------------------------------------------------------- 
+---------------------------------------------------------------------------
 //----------------------------------------------------------------------
 //   Copyright 2008-2010 Cadence Design Systems, Inc.
 //   All Rights Reserved Worldwide
@@ -27,7 +27,7 @@ Notes       : End of test handling is done using the objection mechanism.
 //   the License for the specific language governing
 //   permissions and limitations under the License.
 //----------------------------------------------------------------------
-------------------------------------------------------------------------*/ 
+------------------------------------------------------------------------*/
 
 <'
 
@@ -63,7 +63,7 @@ extend MAIN POST_TEST xbus_master_sequence {
     -- This field is used to control the delay between the end of the MAIN
     -- sequence and the dropping of the objection to TEST_DONE - i.e. the
     -- time allowed for the last data to drain through the DUT. This is
-    -- measured in clock cycles. 
+    -- measured in clock cycles.
     drain_time : uint;
         keep soft drain_time == 10;
 
@@ -76,7 +76,7 @@ extend MAIN POST_TEST xbus_master_sequence {
             driver.drop_objection(TEST_DONE);
         };
     }; -- post_body()
-    
+
 }; -- extend MAIN POST_TEST xbus_master_sequence
 
 '>
@@ -104,4 +104,4 @@ extend MAIN POST_TEST xbus_master_sequence {
 
 
 
-    
+
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_env.e b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_env.e
index 071d7ce..d12406e 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_env.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_env.e
@@ -1,11 +1,11 @@
-/*-------------------------------------------------------------------------  
+/*-------------------------------------------------------------------------
 File name   : xbus_env.e
 Title       : Implementation of top level env unit for UVC
 Project     : XBus UVC
 Created     : 2008
 Description : This file adds implementation details to the env.
-Notes       : 
---------------------------------------------------------------------------- 
+Notes       :
+---------------------------------------------------------------------------
 //----------------------------------------------------------------------
 //   Copyright 2008-2010 Cadence Design Systems, Inc.
 //   All Rights Reserved Worldwide
@@ -24,7 +24,7 @@ Notes       :
 //   the License for the specific language governing
 //   permissions and limitations under the License.
 //----------------------------------------------------------------------
--------------------------------------------------------------------------*/ 
+-------------------------------------------------------------------------*/
 
 <'
 
@@ -46,16 +46,16 @@ extend xbus_env_u {
 
     -- Set up required back-pointers and other control fields in each sub-unit.
     keep soft synch.has_checks == read_only(has_checks);
-    
+
     keep bus_monitor.bus_name == read_only(bus_name);
     keep soft bus_monitor.abstraction_level == read_only(abstraction_level);
-    keep bus_monitor.synch == read_only(synch); 
-    keep bus_monitor.collector.synch == read_only(synch); 
-    keep bus_monitor.collector.smp == read_only(smp); 
+    keep bus_monitor.synch == read_only(synch);
+    keep bus_monitor.collector.synch == read_only(synch);
+    keep bus_monitor.collector.smp == read_only(smp);
     keep bus_monitor.collector.msmps == read_only(msmps);
     keep bus_monitor.slave_configs == read_only(slave_configs);
     keep soft bus_monitor.has_checks == read_only(has_checks);
-    
+
     keep for each (master) in active_masters {
         soft master.abstraction_level == read_only(abstraction_level);
         master.smp == read_only(smp);
@@ -80,7 +80,7 @@ extend xbus_env_u {
         slave.synch == read_only(synch);
         soft slave.agent_monitor.has_checks == read_only(has_checks);
     };
-    
+
     keep soft arbiter.abstraction_level == read_only(abstraction_level);
     keep arbiter.smp == read_only(smp);
     keep arbiter.synch == read_only(synch);
@@ -101,28 +101,28 @@ extend xbus_env_u {
         for each (slave) in slaves {
             slave.agent_monitor.bus_monitor = bus_monitor;
             if slave is a ACTIVE SLAVE xbus_agent_u (as) {
-                as.bfm.bus_monitor = bus_monitor;                
-                as.bfm.bus_collector = bus_monitor.collector;                
+                as.bfm.bus_monitor = bus_monitor;
+                as.bfm.bus_collector = bus_monitor.collector;
             };
         };
         arbiter.agent_monitor.bus_monitor = bus_monitor;
         if arbiter is a ACTIVE ARBITER xbus_agent_u (a) {
             a.bfm.bus_monitor = bus_monitor;
             a.bfm.bus_collector = bus_monitor.collector;
-        }; 
+        };
     }; -- connect_pointers()
 
     connect_ports() is also {
         for each (slave) in slaves {
             bus_monitor.transfer_ended_o.connect(
                 slave.agent_monitor.transfer_ended_i);
-        };        
+        };
         for each (master) in masters {
             bus_monitor.transfer_ended_o.connect(
                 master.agent_monitor.transfer_ended_i);
-        };        
+        };
     }; -- connect_ports()
-    
+
     -- The short_name() method should return the name of this UVC instance.
     short_name(): string is {
         result = append(bus_name);
@@ -132,7 +132,7 @@ extend xbus_env_u {
     short_name_style(): vt_style is {
         result = DARK_RED;
     }; -- short_name_style()
-    
+
     -- This method shows the current status of the UVC.
     show_status() is only {
         bus_monitor.show_status();
@@ -155,17 +155,17 @@ extend xbus_env_u {
     show_banner() is also {
         out("(c) Cadence 2002-2005");
         out("Bus : ", bus_name);
-        out("     ", 
-            dec(masters.count(.active_passive == ACTIVE)), 
+        out("     ",
+            dec(masters.count(.active_passive == ACTIVE)),
             " ACTIVE masters");
-        out("     ", 
-            dec(masters.count(.active_passive == PASSIVE)), 
+        out("     ",
+            dec(masters.count(.active_passive == PASSIVE)),
             " PASSIVE masters");
-        out("     ", 
-            dec(slaves.count(.active_passive == ACTIVE)), 
+        out("     ",
+            dec(slaves.count(.active_passive == ACTIVE)),
             " ACTIVE slaves");
-        out("     ", 
-            dec(slaves.count(.active_passive == PASSIVE)), 
+        out("     ",
+            dec(slaves.count(.active_passive == PASSIVE)),
             " PASSIVE slaves");
         if arbiter.active_passive == ACTIVE {
             out("     ACTIVE arbiter");
@@ -173,16 +173,16 @@ extend xbus_env_u {
             out("     PASSIVE arbiter");
         };
     }; -- show_banner()
-    
-    
-    
+
+
+
     // Configure the transaction recording
     connect_pointers() is also {
         var tr_cfg : recording_config = new;
-        
+
         tr_cfg.register_field_attributes("xbus_trans_s",
                                          {"read_write"; "addr";} );
-        
+
         tr_cfg.register_callback_attribute("xbus_slave_response_s",
                                            "read_write");
         tr_cfg.register_callback_attribute("xbus_slave_response_s",
@@ -190,7 +190,7 @@ extend xbus_env_u {
 
         assign_recording_config(tr_cfg);
     };
-    
+
 }; -- extend xbus_env_u
 
 '>
@@ -200,20 +200,20 @@ extend xbus_env_u {
 
 <'
 extend xbus_env_u {
-    
+
     // configure
     configure( ctr    : uint,
                new_params : xbus_env_config_params_s) is {
-        
+
         // Update local parameters, if required
-        // Currently - empty 
-        
+        // Currently - empty
+
         // Propagate values to agent
         for each (slave) in slaves {
              if slave.agent_name == new_params.slave_name {
-                 uvm_configure ctr slave {min_addr;     max_addr} 
+                 uvm_configure ctr slave {min_addr;     max_addr}
                                       {new_params.min_addr; new_params.max_addr};
-        
+
              };
         };
         config.params = new_params.copy();
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_env_h.e b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_env_h.e
index 6c6b5f7..bb08073 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_env_h.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_env_h.e
@@ -1,11 +1,11 @@
-/*-------------------------------------------------------------------------  
+/*-------------------------------------------------------------------------
 File name   : xbus_env_h.e
 Title       : Declaration of top level env unit for UVC
 Project     : XBus UVC
 Created     : 2008
 Description : This file declares the env unit.
-Notes       : 
---------------------------------------------------------------------------- 
+Notes       :
+---------------------------------------------------------------------------
 //----------------------------------------------------------------------
 //   Copyright 2008-2010 Cadence Design Systems, Inc.
 //   All Rights Reserved Worldwide
@@ -24,7 +24,7 @@ Notes       :
 //   the License for the specific language governing
 //   permissions and limitations under the License.
 //----------------------------------------------------------------------
-------------------------------------------------------------------------*/ 
+------------------------------------------------------------------------*/
 
 <'
 
@@ -45,12 +45,12 @@ unit xbus_env_u like uvm_env {
     -- UVM_SIGNAL, UVM_TLM, UVM_ACCEL, UVM_SIGNAL_SC
     abstraction_level : uvm_abstraction_level_t;
       keep soft abstraction_level == UVM_SIGNAL;
-    
+
     -- This field provides a screen logger for each UVC instance. By default,
     -- it's verbosity is set to NONE so that it is disabled.
     logger : message_logger is instance;
     keep soft logger.verbosity == NONE;
-    
+
 
     -- This field holds the logical name of this physical bus. This field is
     -- automatically constrained by the UVC and should not be constrained by
@@ -84,7 +84,7 @@ unit xbus_env_u like uvm_env {
     -- to being empty.
     active_master_names : list of xbus_agent_name_t;
     keep soft active_master_names.size() == 0;
-        
+
     -- This field holds a list of the logical names of all passive masters
     -- contained by the env. The user should constrain this field to create
     -- all the passive masters required as part of the configuration file. The
@@ -93,7 +93,7 @@ unit xbus_env_u like uvm_env {
     -- to being empty.
     passive_master_names : list of xbus_agent_name_t;
     keep soft passive_master_names.size() == 0;
-        
+
     -- This field holds a list of the logical names of all active slaves
     -- contained by the env. The user should constrain this field to create
     -- all the active slaves required as part of the configuration file. The
@@ -111,7 +111,7 @@ unit xbus_env_u like uvm_env {
     -- to being empty.
     passive_slave_names : list of xbus_agent_name_t;
     keep soft passive_slave_names.size() == 0;
-    
+
     -- This field is the instance of the bus monitor.
     bus_monitor : xbus_bus_monitor_u is instance;
 
@@ -179,7 +179,7 @@ unit xbus_env_u like uvm_env {
 // CONFIGURATION:
 // --------------
 
-// the macro defines xbus_env_config_u and xbus_env_config_params_s, 
+// the macro defines xbus_env_config_u and xbus_env_config_params_s,
 // and instantiates them in xbus_env_u.
 uvm_build_config env xbus_env_u xbus_env_config_u xbus_env_config_params_s;
 
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_master_agent.e b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_master_agent.e
index 103c73c..d7e332a 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_master_agent.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_master_agent.e
@@ -1,12 +1,12 @@
-/*------------------------------------------------------------------------- 
+/*-------------------------------------------------------------------------
 File name   : xbus_master_agent.e
 Title       : XBus Master Agent
 Project     : UVM XBus UVC
-Developers  :  
+Developers  :
 Created     : 2008
-Description : 
-Notes       : 
---------------------------------------------------------------------------- 
+Description :
+Notes       :
+---------------------------------------------------------------------------
 //----------------------------------------------------------------------
 //   Copyright 2008-2010 Cadence Design Systems, Inc.
 //   All Rights Reserved Worldwide
@@ -25,8 +25,8 @@ Notes       :
 //   the License for the specific language governing
 //   permissions and limitations under the License.
 //----------------------------------------------------------------------
--------------------------------------------------------------------------*/ 
- 
+-------------------------------------------------------------------------*/
+
 <'
 
 package cdn_xbus;
@@ -47,20 +47,20 @@ extend MASTER xbus_agent_u {
     keep agent_monitor is a MASTER xbus_agent_monitor_u (mam) =>
         mam.synch == read_only(synch) and
         mam.msmp == read_only(msmp);
-    
+
 }; -- extend MASTER xbus_agent_u
 
 
 
 extend ACTIVE MASTER xbus_agent_u {
-    
-    
+
+
     // testflow main methods are expected to be found in the top portion of the
     // unit to better recognize the functional behavior of the unit
     tf_reset() @tf_phase_clock is also {
         reset_dut();
     };
-    
+
     reset_dut() @synch.unqualified_clock_rise is {
         message(TESTFLOW_EX, LOW, "reset start");
         synch.sig_reset$ = 1;
@@ -68,7 +68,7 @@ extend ACTIVE MASTER xbus_agent_u {
         synch.sig_reset$ = 0;
         message(TESTFLOW_EX, LOW, "reset done");
     };
-    
+
 
     -- This is the sequence driver for an ACTIVE MASTER agent.
     driver: xbus_master_driver_u is instance;
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_master_bfm.e b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_master_bfm.e
index f759631..04fbbc4 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_master_bfm.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_master_bfm.e
@@ -1,14 +1,14 @@
-/*------------------------------------------------------------------------- 
+/*-------------------------------------------------------------------------
 File name   : xbus_master_bfm.e
 Title       : Master BFM
 Project     : XBus UVC
 Created     : 2008
 Description : This file adds master functionality to the generic BFM.
 Notes       : This is a proactive sequence driver
---------------------------------------------------------------------------- 
+---------------------------------------------------------------------------
 Copyright (c) 2008 Cadence Design Systems,Inc.
 All rights reserved worldwide
--------------------------------------------------------------------------*/ 
+-------------------------------------------------------------------------*/
 
 <'
 
@@ -17,33 +17,33 @@ package cdn_xbus;
 
 
 extend MASTER xbus_bfm_u {
-    
-    // testflow induced reset does not rerun the driver but might stop 
-    // the bfm before it emitted item_done event to the driver. Since this 
-    // causes an error, the following flag is needed to manually emit 
+
+    // testflow induced reset does not rerun the driver but might stop
+    // the bfm before it emitted item_done event to the driver. Since this
+    // causes an error, the following flag is needed to manually emit
     // item_done in these cases.
     // Note: this is old code. Now item done that was not set
     //       is handled automatically by the Testflow domain manager
    //!item_done_not_set: bool;
 
-    // testflow main methods are expected to be found in the top portion 
+    // testflow main methods are expected to be found in the top portion
     // of the unit to better recognize the functional behavior of the unit
-    
+
     // Run the main master BFM in MAIN_TEST phase.
     tf_main_test() @tf_phase_clock is also {
         message(LOW, "Master BFM started");
         start drive_transfers();
         // Register the thread as running until POST_TEST, non blocking
-         tf_get_domain_mgr().register_thread_by_name(me, "drive_transfers", 
+         tf_get_domain_mgr().register_thread_by_name(me, "drive_transfers",
                                                      POST_TEST,  FALSE);
     }; -- tf_main_test()
-    
+
     tf_reset() @tf_phase_clock is also {
         -- make sure master does not request the bus after reset
         msmp.sig_request$ = 0;
     }; -- tf_reset()
-        
-    
+
+
     -- This is a pointer to the specific signals of the master
     msmp : xbus_master_signal_map_u;
 
@@ -53,7 +53,7 @@ extend MASTER xbus_bfm_u {
         wait true (msmp.sig_grant$ == 1);
         msmp.sig_request$ = 0;
     }; -- arbitrate_for_bus()
-    
+
     -- This TCM drives the Address Phase of a transfer.
     private drive_address_phase(t : MASTER xbus_trans_s) @tf_phase_clock is {
         -- Drive the address phase signals
@@ -64,15 +64,15 @@ extend MASTER xbus_bfm_u {
         wait cycle;
         -- now stop driving the address phase signals
 
-        smp.sig_addr.put_mvl_string("32'bz");   
-        smp.sig_size.put_mvl_string("2'bz");   
-        smp.sig_read.put_mvl_string("1'bz");   
-        smp.sig_write.put_mvl_string("1'bz");   
+        smp.sig_addr.put_mvl_string("32'bz");
+        smp.sig_size.put_mvl_string("2'bz");
+        smp.sig_read.put_mvl_string("1'bz");
+        smp.sig_write.put_mvl_string("1'bz");
     }; -- drive_address_phase()
-    
-    -- This TCM handles one byte of the Data Phase of a read transfer. It 
+
+    -- This TCM handles one byte of the Data Phase of a read transfer. It
     -- returns TRUE if an error occured on this byte.
-    private read_byte(t : MASTER xbus_trans_s, i : uint) : 
+    private read_byte(t : MASTER xbus_trans_s, i : uint) :
                                      bool @tf_phase_clock is {
         wait cycle;
         sync @bus_collector.data_valid;
@@ -82,7 +82,7 @@ extend MASTER xbus_bfm_u {
 
     -- This TCM handles one byte of the Data Phase of a write transfer. It
     -- returns TRUE if an error occured on this byte.
-    private write_byte(t : MASTER xbus_trans_s, i : uint) : 
+    private write_byte(t : MASTER xbus_trans_s, i : uint) :
                                       bool @tf_phase_clock is {
         smp.sig_data$ = t.data[i];
         wait @bus_collector.data_valid;
@@ -96,35 +96,35 @@ extend MASTER xbus_bfm_u {
             if i == (t.size-1) {
                 smp.sig_bip$ = 0;
             } else {
-                smp.sig_bip$ = 1;            
+                smp.sig_bip$ = 1;
             };
             case t.read_write {
                 READ  : { err = read_byte(t, i); };
                 WRITE : { err = write_byte(t, i); };
-                default : { wait;}; 
+                default : { wait;};
             };
             if err {
-                check err_sig_unexpected that 
+                check err_sig_unexpected that
                   (not t.check_error) or (t.error_pos_master == i)
-                    else dut_error("ERR_UNEXPECTED_ERROR\n", 
+                    else dut_error("ERR_UNEXPECTED_ERROR\n",
                                    "Error signal was unexpectedly asserted");
                 break
             } else {
-                check no_err_sig 
+                check no_err_sig
                       that (not t.check_error) or (t.error_pos_master != i)
-                    else dut_error("ERR_EXPECTED_ERROR_MISSING\n", 
+                    else dut_error("ERR_EXPECTED_ERROR_MISSING\n",
                                    "Error signal assertion was expected ",
                                    "but did not occur");
             };
         };
-        smp.sig_bip.put_mvl_string("1'bz");   
-        smp.sig_data.put_mvl_string("8'bz");   
+        smp.sig_bip.put_mvl_string("1'bz");
+        smp.sig_data.put_mvl_string("8'bz");
     }; -- drive_data_phase()
-    
+
     -- This TCM drives all phases of a transfer.
     private drive_transfer(t : MASTER xbus_trans_s) @tf_phase_clock is {
         msg_started(MEDIUM, "Driving transfer", t);
-        message(FULL, "Waiting for transmit delay of ", dec(t.transmit_delay), 
+        message(FULL, "Waiting for transmit delay of ", dec(t.transmit_delay),
                       " cycles");
         wait [t.transmit_delay] * cycle;
         message(MEDIUM, "Transfer started: ", t);
@@ -142,21 +142,21 @@ extend MASTER xbus_bfm_u {
     private drive_transfers() @tf_phase_clock is {
         while TRUE {
             // Perhaps tranmission of former data item was interrupted.
-            // Here the proper emission of former item_done 
+            // Here the proper emission of former item_done
             // is checked, and emitted if necessary.
             // Note: this is old code. Now item done that was not set
             //       is handled automatically by the Testflow domain manager
             // if item_done_not_set then {
             //    emit driver.item_done;
             //    item_done_not_set = FALSE;
-            //};                
-            
+            //};
+
             var next_trans := driver.get_next_item();
             drive_transfer(next_trans);
             emit driver.item_done;
-            
-        }; 
-    }; -- drive_transfers()    
+
+        };
+    }; -- drive_transfers()
 }; -- extend MASTER xbus_bfm_u {
 
 -- in case of rerun_phase - clean the driver from previous bfm calls
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_master_sequence_h.e b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_master_sequence_h.e
index d89f9f7..297fdf5 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_master_sequence_h.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_master_sequence_h.e
@@ -1,11 +1,11 @@
-/*------------------------------------------------------------------------- 
+/*-------------------------------------------------------------------------
 File name   : xbus_master_sequence_h.e
 Title       : Sequence interface for ACTIVE master agents
 Project     : XBus UVC
 Created     : 2008
 Description : This file provides a sequence interface for the master.
-Notes       : 
---------------------------------------------------------------------------- 
+Notes       :
+---------------------------------------------------------------------------
 //----------------------------------------------------------------------
 //   Copyright 2008-2010 Cadence Design Systems, Inc.
 //   All Rights Reserved Worldwide
@@ -24,7 +24,7 @@ Notes       :
 //   the License for the specific language governing
 //   permissions and limitations under the License.
 //----------------------------------------------------------------------
--------------------------------------------------------------------------*/ 
+-------------------------------------------------------------------------*/
 
 <'
 
@@ -47,8 +47,8 @@ extend MASTER xbus_trans_s {
     -- automatically constrained by the UVC and should not be constrained by
     -- the user.
     bus_name : xbus_bus_name_t;
-        keep bus_name == read_only(driver.bus_name);    
-   
+        keep bus_name == read_only(driver.bus_name);
+
     -- This field is used to sub-type the transfer struct according to which
     -- master agent it is for. This field is automatically constrained by the
     -- UVC and should not be constrained by the user.
@@ -61,7 +61,7 @@ extend MASTER xbus_trans_s {
        keep for each in wait_states  {
            soft it == 9;
        };
-    
+
     -- If this field is TRUE, then the error behaviour of this transfer is
     -- checked against the error_pos field.
     check_error : bool;
@@ -74,20 +74,20 @@ extend MASTER xbus_trans_s {
     %error_pos_master : int;
         keep soft error_pos_master == UNDEF;
         keep error_pos_master < read_only(size);
-    
+
     -- This field controls the delay from the end of the previous transfer to
     -- requesting the bus for this transfer in clock cycles.
     %transmit_delay : uint;
         keep soft transmit_delay in [0..10];
-        
+
 }; -- extend MASTER xbus_trans_s {
-   
-        
+
+
 
 -- This struct is the generic sequence for the master agent sequence
 -- interface.
-sequence xbus_master_sequence using 
-        testflow = TRUE, 
+sequence xbus_master_sequence using
+        testflow = TRUE,
         item = MASTER xbus_trans_s,
         created_driver = xbus_master_driver_u;
 
@@ -95,7 +95,7 @@ sequence xbus_master_sequence using
 
 
 extend xbus_master_driver_u {
-    
+
     keep soft tf_domain == XBUS_TF;
 
     -- This field holds the abstraction level:
@@ -104,9 +104,9 @@ extend xbus_master_driver_u {
       keep soft abstraction_level == UVM_SIGNAL;
 
     synch : xbus_synchronizer_u;
-   
+
     // tf_phase_clock if the testflow clock and might change according to
-    // current test phase. it is recommended to bind driver.clock to this 
+    // current test phase. it is recommended to bind driver.clock to this
     // clock;
     event tf_phase_clock is only @synch.unqualified_clock_rise;
     on tf_phase_clock {
@@ -117,7 +117,7 @@ extend xbus_master_driver_u {
     -- automatically constrained by the UVC and should not be constrained by
     -- the user.
     bus_name : xbus_bus_name_t;
-   
+
     -- This field is the logical name of the master. This
     -- field is automatically constrained by the UVC and should not be
     -- constrained by the user.
@@ -132,50 +132,50 @@ extend xbus_master_sequence {
     -- automatically constrained and should not be constrained by
     -- the user.
     bus_name : xbus_bus_name_t;
-        keep bus_name == read_only(driver.bus_name);    
-   
+        keep bus_name == read_only(driver.bus_name);
+
     -- This field holds the logical name of the master. This field is
     -- automatically constrained and should not be constrained by
     -- the user.
     master_name : xbus_agent_name_t;
         keep master_name == read_only(driver.master_name);
-    
+
     -- This is a utility field for basic sequences. This allows the user to
     -- do "do trans ...".
     !trans       : MASTER xbus_trans_s;
 
-    // Cover the sequence. 
+    // Cover the sequence.
     // Ignore the pre-defined kinds, they do not add info to the coverage
     cover ended is {
         item kind using ignore = (kind == RANDOM or
                                   kind == SIMPLE or
                                   kind == MAIN);
-    }; 
+    };
 
     -- This method performs one write transfer on the bus. It can be used in
     -- sequences to make them more readable.
-    write(size : uint, 
-          addr : xbus_addr_t, 
+    write(size : uint,
+          addr : xbus_addr_t,
           data : uint(bits:64) ) @driver.clock is {
         if (size not in [1, 2, 4, 8]) {
             error("ERROR: xbus_master_driver:write() got size parameter ",
                   "not in [1, 2, 4, 8]");
         };
-        
+
         trans = new with {
             .master_name = master_name;
             .slave_name  = NO_AGENT;
             .addr        = addr;
             .read_write  = WRITE;
             .size        = size;
-            .data        = pack(packing.low, data[size*8-1:0]); 
+            .data        = pack(packing.low, data[size*8-1:0]);
         };
         driver.execute_item(trans);
     }; -- write()
 
     -- This method performs one read transfer on the bus. It can be used in
     -- sequences to make them more readable.
-    read(size : uint, 
+    read(size : uint,
          addr : xbus_addr_t )      : uint(bits:64) @driver.clock is {
         if (size not in [1, 2, 4, 8]) {
             error("ERROR: xbus_master_driver:read() got size parameter ",
@@ -190,7 +190,7 @@ extend xbus_master_sequence {
         };
         trans.data.resize(size);
         driver.execute_item(trans);
-        
+
         if trans != NULL {
             result = pack(packing.low, trans.data);
         } else {
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_port_config.e b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_port_config.e
index 9c2ba35..61dda47 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_port_config.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_port_config.e
@@ -1,12 +1,12 @@
-/*-------------------------------------------------------------------------  
+/*-------------------------------------------------------------------------
 File name   : xbus_port_config.e
 Title       : Deault binding of ports. Used in RTL
 Project     : XBus UVC
 Created     : March 2008
-Description : This file binds the signal ports to external, and default 
+Description : This file binds the signal ports to external, and default
             : signal names
-Notes       : 
---------------------------------------------------------------------------- 
+Notes       :
+---------------------------------------------------------------------------
 //----------------------------------------------------------------------
 //   Copyright 2008-2010 Cadence Design Systems, Inc.
 //   All Rights Reserved Worldwide
@@ -25,7 +25,7 @@ Notes       :
 //   the License for the specific language governing
 //   permissions and limitations under the License.
 //----------------------------------------------------------------------
--------------------------------------------------------------------------*/ 
+-------------------------------------------------------------------------*/
 
 <'
 package cdn_xbus;
@@ -50,7 +50,7 @@ extend xbus_signal_map_u {
 
 extend xbus_master_signal_map_u {
     keep  bind(sig_request, external);
-    keep  bind(sig_grant, external);  
+    keep  bind(sig_grant, external);
 };
 
 '>
@@ -71,7 +71,7 @@ extend xbus_signal_map_u {
     keep soft sig_bip.hdl_path()   == "xbus_bip";
     keep soft sig_wait.hdl_path()  == "xbus_wait";
     keep soft sig_error.hdl_path() == "xbus_error";
-    keep soft sig_data.hdl_path()  == "xbus_data";  
+    keep soft sig_data.hdl_path()  == "xbus_data";
 };
 
 
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_protocol_checker.e b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_protocol_checker.e
index ab1db99..49ba892 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_protocol_checker.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_protocol_checker.e
@@ -1,4 +1,4 @@
-/*------------------------------------------------------------------------- 
+/*-------------------------------------------------------------------------
 File name   : xbus_protocol_checker.e
 Title       : Protocol checker
 Project     : XBus UVC
@@ -6,9 +6,9 @@ Created     : 2008
 Description : This file implements the optional protocol checker.
 Notes       : The protocol checker functionality is contained in the bus
             : and agent monitors units.
---------------------------------------------------------------------------- 
+---------------------------------------------------------------------------
 //----------------------------------------------------------------------
-//   Copyright 2008-2010 Cadence Design Systems, Inc. 
+//   Copyright 2008-2010 Cadence Design Systems, Inc.
 //   All Rights Reserved Worldwide
 //
 //   Licensed under the Apache License, Version 2.0 (the
@@ -25,7 +25,7 @@ Notes       : The protocol checker functionality is contained in the bus
 //   the License for the specific language governing
 //   permissions and limitations under the License.
 //----------------------------------------------------------------------
--------------------------------------------------------------------------*/ 
+-------------------------------------------------------------------------*/
 
 <'
 
@@ -41,7 +41,7 @@ extend has_checks xbus_synchronizer_u {
 
     -- Reset must be asserted for at least 5 clocks at start of test
     -- (Spec section 2.3)
-    expect short_reset_at_start is 
+    expect short_reset_at_start is
            @session.start_of_test => {[5] * not @reset_end}
                                                     @unqualified_clock_rise
         else dut_error("ERR_SHORT_RESET_AT_TEST_START\n",
@@ -54,7 +54,7 @@ extend has_checks xbus_synchronizer_u {
            @reset_start => {[2] * not @reset_end} @unqualified_clock_rise
         else dut_error("ERR_SHORT_RESET_DURING_TEST\n",
                        "Reset was asserted for less than 3 clock cycles");
-                       
+
 }; -- extend has_checks xbus_synchronizer_u
 
 
@@ -67,77 +67,77 @@ extend has_checks xbus_bus_collector_u {
     -- Start must be asserted during Arbitration Phase
     -- (Spec sections 2.3 and 3)
     expect no_start_during_arbitration is
-       true(tf_get_domain_mgr().get_current_phase() != MAIN_TEST or 
+       true(tf_get_domain_mgr().get_current_phase() != MAIN_TEST or
             smp.sig_start$ == 1) @arbitration_phase
         else dut_error("ERR_NO_START_DURING_ARBITRATION\n",
                        "Start was not asserted during Arbitration Phase");
-   
+
     -- Start must not be asserted during Address Phase
     -- (Spec section 3)
     expect no_start_during_address is true(smp.sig_start$ == 0) @normal_address_phase
       else dut_error("ERR_START_DURING_ADDRESS_PHASE\n",
                        "Start was asserted during Address Phase");
-    
+
     -- Start must not be asserted during Data Phase
     -- (Spec section 3)
     expect no_start_during_data is true(smp.sig_start$ == 0) @data_phase
       else dut_error("ERR_START_DURING_DATA_PHASE\n",
                        "Start was asserted during Data Phase");
-                       
+
     -- Only one gnt line may be asserted at a time
     -- (Spec section 3)
-    expect multiple_gnt is 
+    expect multiple_gnt is
       true(msmps.count(.sig_grant$ == 1) <= 1) @arbitration_phase
         else dut_error("ERR_MULTIPLE_GNTS\n",
                        "Multiple gnt signals were asserted together");
-                       
+
     -- Read and Write must not be asserted together
     expect read_and_write is
       true( (smp.sig_read.get_mvl() != MVL_1) or
             (smp.sig_write.get_mvl() != MVL_1)) @normal_address_phase
         else dut_error("ERR_READ_AND_WRITE\n",
                        "Both read and write signals were asserted together");
-  
-    
+
+
     -- Address must not be X or Z during Address Phase
     -- (Spec section 4)
     expect address_xz is
       true(!smp.sig_addr.has_x() and !smp.sig_addr.has_z()) @normal_address_phase
         else dut_error("ERR_ADDR_XZ\n",
                        "Address went to X or Z during Address Phase");
-                       
+
     -- Size must not be X or Z during Address Phase
     -- (Spec section 4)
     expect size_xz is
       true(!smp.sig_size.has_x() and !smp.sig_size.has_z()) @normal_address_phase
         else dut_error("ERR_SIZE_XZ\n",
                        "Size went to X or Z during Address Phase");
-                       
+
     -- Read must not be X or Z during Address Phase
     -- (Spec section 4)
     expect read_xz is
       true(!smp.sig_read.has_x() and !smp.sig_read.has_z()) @normal_address_phase
         else dut_error("ERR_READ_XZ\n",
                        "Read went to X or Z during Address Phase");
-                       
+
     -- Write must not be X or Z during Address Phase
     -- (Spec section 4)
     expect write_xz is
       true(!smp.sig_write.has_x() and !smp.sig_write.has_z()) @normal_address_phase
         else dut_error("ERR_WRITE_XZ\n",
                        "Write went to X or Z during Address Phase");
-                       
+
     -- Bip must not be X or Z during Data Phase
     -- (Spec section 5)
     expect bip_xz is
       true(!smp.sig_bip.has_x() and !smp.sig_bip.has_z()) @data_phase
         else dut_error("ERR_BIP_XZ\n",
                        "Bip went to X or Z during Data Phase");
-                       
+
     -- Wait must not be X or Z during Data Phase
     -- (Spec section 5)
     expect wait_xz is
-      true((!smp.sig_wait.has_x() and !smp.sig_wait.has_z()) or 
+      true((!smp.sig_wait.has_x() and !smp.sig_wait.has_z()) or
            synch.reset_asserted) @data_phase
         else dut_error("ERR_WAIT_XZ\n",
                        "Wait went to X or Z during Data Phase");
@@ -145,28 +145,28 @@ extend has_checks xbus_bus_collector_u {
     -- Error must not be X or Z during Data Phase
     -- (Spec section 5)
     expect error_xz is
-      true((!smp.sig_error.has_x() and !smp.sig_error.has_z()) or 
+      true((!smp.sig_error.has_x() and !smp.sig_error.has_z()) or
            synch.reset_asserted) @data_phase
         else dut_error("ERR_ERROR_XZ\n",
                        "Error went to X or Z during Data Phase");
-                    
-    -- Data must be valid when wait is de-asserted during the data 
+
+    -- Data must be valid when wait is de-asserted during the data
     -- phase of a read.
     expect read_data_xz is
-      true((!smp.sig_data.has_x() and !smp.sig_data.has_z()) or 
+      true((!smp.sig_data.has_x() and !smp.sig_data.has_z()) or
            (smp.sig_error$ == 1) or (transfer.read_write != READ)) @data_valid
         else dut_error("ERR_READ_DATA_XZ\n",
                        "Data went to X or Z while wait was low during read");
 
     -- Data must be valid throughout the data phase of a write.
     expect write_data_xz is
-      true(synch.reset_asserted or 
-           ((!smp.sig_data.has_x() and !smp.sig_data.has_z()) or 
+      true(synch.reset_asserted or
+           ((!smp.sig_data.has_x() and !smp.sig_data.has_z()) or
             (transfer.read_write != WRITE))) @data_phase
         else dut_error("ERR_WRITE_DATA_XZ\n",
                        "Data went to X or Z during Data Phase of write");
-    
- 
+
+
 }; -- extend has_checks xbus_bus_monitor_u
 
 
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_signal_map_h.e b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_signal_map_h.e
index a81c7c5..16fc7c0 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_signal_map_h.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_signal_map_h.e
@@ -1,11 +1,11 @@
-/*-------------------------------------------------------------------------   
+/*-------------------------------------------------------------------------
 File name   : xbus_signal_map_h.e
 Title       : Declaration of signal maps
 Project     : XBus UVC
 Created     : 2008
 Description : This file declares the signal maps required for the UVC.
-Notes       : 
---------------------------------------------------------------------------- 
+Notes       :
+---------------------------------------------------------------------------
 //----------------------------------------------------------------------
 //   Copyright 2008-2010 Cadence Design Systems, Inc.
 //   All Rights Reserved Worldwide
@@ -24,7 +24,7 @@ Notes       :
 //   the License for the specific language governing
 //   permissions and limitations under the License.
 //----------------------------------------------------------------------
--------------------------------------------------------------------------*/ 
+-------------------------------------------------------------------------*/
 
 <'
 package cdn_xbus;
@@ -44,7 +44,7 @@ unit xbus_synchronizer_u like uvm_signal_map {
 
     -- This port connects the UVC to the CLOCK signal.
     sig_clock : in simple_port of bit is instance;
-    
+
     -- This port connects the UVC to the RESET signal.
     sig_reset : simple_port of bit is instance;
 
@@ -73,27 +73,27 @@ unit xbus_synchronizer_u like uvm_signal_map {
 
     -- This event is the rising edge of the bus clock, qualified by reset.
     event clock_rise is true(not reset_asserted) @unqualified_clock_rise;
-    
+
     -- This event is the falling edge of the bus clock, qualified by reset.
     event clock_fall is true(not reset_asserted) @unqualified_clock_fall;
-    
+
     -- This event gets emitted each time the reset signal changes state.
-    event reset_change is change(sig_reset$) @unqualified_clock_rise; 
+    event reset_change is change(sig_reset$) @unqualified_clock_rise;
 
     -- This event gets emitted when reset is asserted.
     event reset_start is
         true((not reset_asserted) and sig_reset$ == 1) @reset_change;
-    
+
     -- This event gets emitted when reset is de-asserted.
-    event reset_end is 
+    event reset_end is
         true(reset_asserted and sig_reset$ ==0) @reset_change;
-    
+
     -- This field is used to keep track of the current reset state. By
     -- default reset is assumed to be asserted at the start of the test.
     -- The user should not normally need to constrain this field.
     reset_asserted : bool;
         keep soft reset_asserted == TRUE;
-    
+
     -- This code ensures that reset_asserted tracks the reset signal.
     on reset_start { reset_asserted = TRUE; };
     on reset_end   { reset_asserted = FALSE; };
@@ -117,33 +117,33 @@ unit xbus_signal_map_u like uvm_signal_map {
     -- UVM_SIGNAL, UVM_TLM, UVM_ACCEL, UVM_SIGNAL_SC
     abstraction_level : uvm_abstraction_level_t;
       keep soft abstraction_level == UVM_SIGNAL;
-    
+
     -- The following ports represent all the common bus signals.
-    
+
     -- This port connects the UVC to the START signal.
     sig_start : inout simple_port of bit is instance;
-    
+
     -- This port connects the UVC to the ADDR signal.
     sig_addr : inout simple_port of xbus_addr_t is instance;
-    
+
     -- This port connects the UVC to the SIZE signal.
     sig_size : inout simple_port of uint(bits:2) is instance;
-    
+
     -- This port connects the UVC to the READ signal.
     sig_read : inout simple_port of bit is instance;
-    
+
     -- This port connects the UVC to the WRITE signal.
     sig_write : inout simple_port of bit is instance;
-    
+
     -- This port connects the UVC to the BIP signal.
     sig_bip : inout simple_port of bit is instance;
-    
+
     -- This port connects the UVC to the WAIT signal.
     sig_wait : inout simple_port of bit is instance;
-    
+
     -- This port connects the UVC to the ERROR signal.
     sig_error : inout simple_port of bit is instance;
-    
+
     -- This port connects the UVC to the DATA signal.
     sig_data : inout simple_port of byte is instance;
 
@@ -182,7 +182,7 @@ unit xbus_signal_map_u like uvm_signal_map {
 
     -- This method samples the READ and WRITE signals and returns
     -- the appropriate enumerated value. Note that it is assumed that this
-    -- method will only be called when the use of these signals is legal 
+    -- method will only be called when the use of these signals is legal
     -- (i.e. either a READ, WRITE or a NOP is in progress). Protocol checking
     -- is done elsewhere.
     package get_read_write() : xbus_read_write_t is {
@@ -190,9 +190,9 @@ unit xbus_signal_map_u like uvm_signal_map {
             ((sig_read$ == 1) and (sig_write$ ==0)) : { result = READ; };
             ((sig_read$ == 0) and (sig_write$ ==1)) : { result = WRITE; };
             ((sig_read$ == 0) and (sig_write$ ==0)) : { result = NOP; };
-            default : { 
+            default : {
                 message(FULL, "Both READ and WRITE signals were asserted simultaneously");
-               result = NOP; 
+               result = NOP;
             };
         };
     }; -- get_read_write()
@@ -200,7 +200,7 @@ unit xbus_signal_map_u like uvm_signal_map {
 }; -- unit xbus_signal_map_u
 
 '>
- 
+
 <'
 
 -- This unit is the signal map for the signals specific to a particular master.
@@ -215,18 +215,18 @@ unit xbus_master_signal_map_u like uvm_signal_map {
     -- UVM_SIGNAL, UVM_TLM, UVM_ACCEL, UVM_SIGNAL_SC
     abstraction_level : uvm_abstraction_level_t;
       keep soft abstraction_level == UVM_SIGNAL;
-    
+
     -- This field holds the name of master which this signal map belongs to.
     -- This field is automatically constrained by the UVC and should not be
     -- constrained by the user.
     master_name : xbus_agent_name_t;
-    
+
     -- This port connects the UVC to the GRANT signal for this master.
     sig_grant : inout simple_port of bit is instance;
 
     -- This port connects the UVC to the REQUEST signal for this master.
     sig_request : inout simple_port of bit is instance;
-    
+
 
 }; -- unit xbus_master_signal_map_u
 
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_slave_agent.e b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_slave_agent.e
index 0f686c8..5790f76 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_slave_agent.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_slave_agent.e
@@ -1,12 +1,12 @@
-/*------------------------------------------------------------------------- 
+/*-------------------------------------------------------------------------
 File name   : xbus_slave_agent.e
 Title       : XBus Slave Agent
 Project     : UVM XBus UVC
-Developers  :  
+Developers  :
 Created     : 2008
-Description : 
-Notes       : 
---------------------------------------------------------------------------- 
+Description :
+Notes       :
+---------------------------------------------------------------------------
 //----------------------------------------------------------------------
 //   Copyright 2008-2010 Cadence Design Systems, Inc.
 //   All Rights Reserved Worldwide
@@ -25,8 +25,8 @@ Notes       :
 //   the License for the specific language governing
 //   permissions and limitations under the License.
 //----------------------------------------------------------------------
--------------------------------------------------------------------------*/ 
- 
+-------------------------------------------------------------------------*/
+
 <'
 package cdn_xbus;
 
@@ -48,18 +48,18 @@ extend ACTIVE SLAVE xbus_agent_u {
         keep bfm.use_ram == read_only(use_ram);
         keep bfm.ram == read_only(ram);
         keep bfm.config == read_only(config);
-    
+
     -- This is a sparse RAM model used to generate read data according
     -- to past write data.
     ram : simple_ram_env_u is instance;
-    
+
     -- If this field is TRUE then write data will be written into the ram
     -- field and read data will be taken from the ram field. If this field
     -- is FALSE, then read data must be supplied by the slave sequence.
     use_ram : bool;
         keep soft use_ram == TRUE;
-    
-    
+
+
 }; -- extend ACTIVE SLAVE xbus_agent_u
 
 '>
@@ -72,8 +72,8 @@ Configuration
 extend SLAVE xbus_agent_u {
     configure(ctr : uint, new_params : xbus_slave_params) is {
         check that new_params.min_addr <= new_params.max_addr else
-          dut_error("Configuring slave ", agent_name, 
-                    " to an Illegal address space - min_addr ", 
+          dut_error("Configuring slave ", agent_name,
+                    " to an Illegal address space - min_addr ",
                     new_params.min_addr,
                    " max_addr ", new_params.max_addr);
         config.params = new_params.copy();
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_slave_bfm.e b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_slave_bfm.e
index e9cdc4f..c0ce4b4 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_slave_bfm.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_slave_bfm.e
@@ -1,11 +1,11 @@
-/*------------------------------------------------------------------------- 
+/*-------------------------------------------------------------------------
 File name   : xbus_slave_bfm.e
 Title       : Slave BFM
 Project     : XBus UVC
 Created     : 2008
 Description : This file adds slave functionality to the generic BFM.
 Notes       : This is a re-active sequence driver
---------------------------------------------------------------------------- 
+---------------------------------------------------------------------------
 //----------------------------------------------------------------------
 //   Copyright 2008-2010 Cadence Design Systems, Inc.
 //   All Rights Reserved Worldwide
@@ -24,7 +24,7 @@ Notes       : This is a re-active sequence driver
 //   the License for the specific language governing
 //   permissions and limitations under the License.
 //----------------------------------------------------------------------
--------------------------------------------------------------------------*/ 
+-------------------------------------------------------------------------*/
 
 <'
 
@@ -33,14 +33,14 @@ package cdn_xbus;
 
 
 extend SLAVE xbus_bfm_u {
-    
+
     // testflow main methods are expected to be found in the top portion of the
     // unit to better recognize the functional behavior of the unit
     // Run the main slave BFM in MAIN_TEST phase.
     tf_main_test() @tf_phase_clock is also {
         start drive_responses();
         // Register the thread as running until POST_TEST, non blocking
-        tf_get_domain_mgr().register_thread_by_name(me, "drive_responses", 
+        tf_get_domain_mgr().register_thread_by_name(me, "drive_responses",
                                                     POST_TEST, FALSE);
     }; // tf_main_test()
 
@@ -49,49 +49,49 @@ extend SLAVE xbus_bfm_u {
         smp.sig_wait.put_mvl_string("1'bz");
         smp.sig_error.put_mvl_string("1'bz");
         smp.sig_start$ = 0;
-        
+
         smp.sig_addr$ = 0;
         smp.sig_read$ = 0;
         smp.sig_write$ = 0;
-        smp.sig_data.put_mvl_string("8'bz"); 
+        smp.sig_data.put_mvl_string("8'bz");
     };
-    
+
     // This field is a pointer to the slave's configuration unit.
     // (e.g. min/max address).
     config : xbus_slave_config_u;
-        
-    // This field is a copy of the use_ram field in the SLAVE agent.   
+
+    // This field is a copy of the use_ram field in the SLAVE agent.
     use_ram : bool;
 
     // This field is a pointer to the ram field in the SLAVE agent.
     ram : simple_ram_env_u;
-    
+
     // This TCM is the main BFM loop that continually detects transfers
-    // received by this slave and responds to them as required. 
-    private drive_responses() @tf_phase_clock is { 
+    // received by this slave and responds to them as required.
+    private drive_responses() @tf_phase_clock is {
         message(LOW, "Slave BFM started");
-     
+
         while TRUE {
-           
+
             -- Wait for the start of a non-NOP Address Phase.
-            wait @bus_collector.normal_address_phase;                
+            wait @bus_collector.normal_address_phase;
             -- Is the current transfer addressed at this slave?
             if config.in_range(bus_collector.transfer.addr) {
                 driver.transfer = deep_copy(bus_collector.transfer);
                 message(MEDIUM, "Transfer detected: ", driver.transfer);
-                
+
                 var resp := driver.try_next_item();
                 if resp == NULL {
                     error("Slave sequence driver provided NULL response");
                 };
                 respond_to_transfer(resp);
                 emit driver.item_done;
-               
+
             };
         }; -- while TRUE
-        message(LOW, "Slave BFM ended");        
+        message(LOW, "Slave BFM ended");
     }; -- drive_responses()
-    
+
     -- This TCM gets called once the sequence driver has returned a transfer
     -- response item. It causes the BFM to respond with an appropriate Data
     -- Phase.
@@ -99,20 +99,20 @@ extend SLAVE xbus_bfm_u {
                                         @tf_phase_clock is {
         msg_started(MEDIUM, "Driving response", resp);
         msg_transformed(MEDIUM, "responding to", resp, bus_collector.transfer);
-        
-        
+
+
         case resp.transfer.read_write {
             WRITE   : { do_slave_write(resp); };
             READ    : { do_slave_read(resp); };
             default : { wait; error("UVC internal error"); };
         };
         msg_ended(MEDIUM, "Driving response", resp);
-        
-        
+
+
    }; -- respond_to_transfer()
-                                    
+
     -- This TCM handles the Data Phase of a write transfer.
-    private do_slave_write(resp : xbus_slave_response_s) 
+    private do_slave_write(resp : xbus_slave_response_s)
                                                 @tf_phase_clock is {
         smp.sig_error$ = 0;
         resp.transfer.data.resize(resp.transfer.size);
@@ -139,14 +139,14 @@ extend SLAVE xbus_bfm_u {
             resp.transfer.data[i] = data;
             message(HIGH, "Byte number ", dec(i), " : data = ", data);
         };
-        smp.sig_wait.put_mvl_string("1'bz");  
-        smp.sig_error.put_mvl_string("1'bz");  
+        smp.sig_wait.put_mvl_string("1'bz");
+        smp.sig_error.put_mvl_string("1'bz");
         message(MEDIUM, "Write transfer completed: ", resp.transfer);
     }; -- do_slave_write()
-    
+
     -- This TCM handles the Data Phase of a read transfer.
-    private do_slave_read(resp : xbus_slave_response_s) 
-                                                      @tf_phase_clock is { 
+    private do_slave_read(resp : xbus_slave_response_s)
+                                                      @tf_phase_clock is {
         smp.sig_error$ = 0;
         resp.transfer.data.resize(resp.transfer.size);
         for i from 0 to (resp.transfer.size-1) {
@@ -177,14 +177,14 @@ extend SLAVE xbus_bfm_u {
             wait cycle;
         };
         smp.sig_wait.put_mvl_string("1'bz");
-        smp.sig_error.put_mvl_string("1'bz");   
-        smp.sig_data.put_mvl_string("8'bz"); 
+        smp.sig_error.put_mvl_string("1'bz");
+        smp.sig_data.put_mvl_string("8'bz");
         message(MEDIUM, "Read transfer completed: ", resp.transfer);
     }; -- do_slave_read()
-    
-    
-    
-    // Calculate recoreded attributes 
+
+
+
+    // Calculate recoreded attributes
     tr_get_attribute_value(inst: any_struct, name: string): string is also {
         if inst is a xbus_slave_response_s (r) then {
             result = r.get_attribute_value(name);
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_slave_sequence_h.e b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_slave_sequence_h.e
index 01638b4..47e95b5 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_slave_sequence_h.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_slave_sequence_h.e
@@ -1,11 +1,11 @@
-/*------------------------------------------------------------------------- 
+/*-------------------------------------------------------------------------
 File name   : xbus_slave_sequence.e
 Title       : Sequence interface for ACTIVE slave agents
 Project     : XBus UVC
 Created     : 2008
 Description : This file provides a sequence interface for the slave.
-Notes       : 
---------------------------------------------------------------------------- 
+Notes       :
+---------------------------------------------------------------------------
 //----------------------------------------------------------------------
 //   Copyright 2008-2010 Cadence Design Systems, Inc.
 //   All Rights Reserved Worldwide
@@ -24,7 +24,7 @@ Notes       :
 //   the License for the specific language governing
 //   permissions and limitations under the License.
 //----------------------------------------------------------------------
--------------------------------------------------------------------------*/ 
+-------------------------------------------------------------------------*/
 
 <'
 
@@ -40,10 +40,10 @@ struct xbus_slave_response_s like any_sequence_item {
     -- automatically constrained by the UVC and should not be constrained by
     -- the user.
     bus_name : xbus_bus_name_t;
-        keep bus_name == read_only(driver.bus_name);    
-   
+        keep bus_name == read_only(driver.bus_name);
+
     -- This field is used to sub-type the slave response struct according to
-    -- which slave agent it is for. This field is automatically constrained 
+    -- which slave agent it is for. This field is automatically constrained
     -- by the UVC and should not be constrained by the user.
     slave_name : xbus_agent_name_t;
         keep slave_name == read_only(driver.slave_name);
@@ -51,9 +51,9 @@ struct xbus_slave_response_s like any_sequence_item {
     -- This field is used to build up the transfer as it is received. This
     -- field is automatically constrained by the UVC and should not be
     -- constrained by the user.
-    %transfer : MONITOR xbus_trans_s;    
+    %transfer : MONITOR xbus_trans_s;
         keep transfer == read_only(driver.transfer);
-    
+
     -- This field controls the number of wait states for each byte of the
     -- transfer.
     wait_states : list of uint;
@@ -61,27 +61,27 @@ struct xbus_slave_response_s like any_sequence_item {
         keep for each in wait_states {
             soft it in [0..4]; -- by default up to four wait states
         };
-    
+
     -- This field controls the byte position of an error. If no error is
     -- required, then it should be constrained to UNDEF.
     error_pos : int;
         keep error_pos < read_only(transfer.size);
         keep soft error_pos == UNDEF; -- by default, no errors
-    
-    
-        
-    -- Called by Structured Messages 
+
+
+
+    -- Called by Structured Messages
     get_attribute_value(name: string): string is {
-     
+
         if transfer != NULL {
             if name == "read_write"  {
                 result = append(transfer.read_write);
             };
-            
+
             if name == "addr" {
                 result = append(transfer.addr);
             };
-        };  
+        };
     };
 }; -- struct xbus_slave_response_s
 
@@ -102,8 +102,8 @@ extend xbus_slave_sequence {
     -- automatically constrained by the UVC and should not be constrained by
     -- the user.
     bus_name : xbus_bus_name_t;
-        keep bus_name == read_only(driver.bus_name);    
-   
+        keep bus_name == read_only(driver.bus_name);
+
     -- This field holds the logical name of the slave. This field is
     -- automatically constrained by the UVC and should not be constrained by
     -- the user.
@@ -114,13 +114,13 @@ extend xbus_slave_sequence {
     -- do "do response ...".
     !response: xbus_slave_response_s;
 
-    // Cover the sequence. 
+    // Cover the sequence.
     // Ignore the pre-defined kinds, they do not add info to the coverage
     cover ended is {
         item kind using ignore = (kind == RANDOM or
                                   kind == SIMPLE or
                                   kind == MAIN);
-    }; 
+    };
 }; -- extend xbus_slave_sequence
 
 
@@ -137,7 +137,7 @@ extend MAIN xbus_slave_sequence {
 
 -- Hook up the driver to the slave BFM
 extend xbus_slave_driver_u {
-    
+
     keep soft tf_domain == XBUS_TF;
 
     -- This field holds the abstraction level:
@@ -146,30 +146,30 @@ extend xbus_slave_driver_u {
       keep soft abstraction_level == UVM_SIGNAL;
 
     synch : xbus_synchronizer_u;
-    
+
     // tf_phase_clock if the testflow clock and might change according to
-    // current test phase. it is recommended to bind driver.clock to this 
+    // current test phase. it is recommended to bind driver.clock to this
     // clock;
     event tf_phase_clock is only @synch.unqualified_clock_rise;
     on tf_phase_clock {
         emit clock;
     };
-    
+
     // slave sequences are influenced by test phases but do not influence
     // the test flow (usually they use while TRUE loops) this behavior is
     // declared by this flag
     keep tf_nonblocking == TRUE;
-    
+
     -- This field holds the logical name of the physical bus. This field is
     -- automatically constrained by the UVC and should not be constrained by
     -- the user.
     bus_name : xbus_bus_name_t;
-   
+
     -- This field holds the logical name of the slave. This field is
     -- automatically constrained by the UVC and should not be constrained by
     -- the user.
     slave_name : xbus_agent_name_t;
-    
+
     -- This field is where the slave BFM puts the detected transfer the slave
     -- needs to respond to immediately prior to calling try_next_item().
     package !transfer : MONITOR xbus_trans_s;
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_top.e b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_top.e
index 225cedb..ee498de 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_top.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_top.e
@@ -1,11 +1,11 @@
-/*-------------------------------------------------------------------------  
+/*-------------------------------------------------------------------------
 File name   : xbus_top.e
 Title       : Top Level of UVC
 Project     : UVM XBus UVC
 Created     : 2008
 Description : This file imports all the files of the UVC.
-Notes       : 
---------------------------------------------------------------------------- 
+Notes       :
+---------------------------------------------------------------------------
 //----------------------------------------------------------------------
 //   Copyright 2008-2010 Cadence Design Systems, Inc.
 //   All Rights Reserved Worldwide
@@ -24,9 +24,9 @@ Notes       :
 //   the License for the specific language governing
 //   permissions and limitations under the License.
 //----------------------------------------------------------------------
--------------------------------------------------------------------------*/ 
+-------------------------------------------------------------------------*/
 
-<' 
+<'
 
 package cdn_xbus;
 
@@ -64,7 +64,7 @@ import xbus_arbiter_agent;
 import xbus_master_bfm;
 import xbus_slave_bfm;
 
-import xbus_slave_agent; 
+import xbus_slave_agent;
 import xbus_master_agent;
 import xbus_arbiter_bfm;
 import xbus_slave_agent;
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_trans_h.e b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_trans_h.e
index 7fb9848..3ed7ba9 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_trans_h.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_trans_h.e
@@ -1,4 +1,4 @@
-/*-------------------------------------------------------------------------  
+/*-------------------------------------------------------------------------
 File name   : xbus_trans_h.e
 Title       : Transfer structure
 Project     : XBus UVC
@@ -12,7 +12,7 @@ Notes       : The addr, read_write and data fields are marked as physical
             : are the fields that are physically driven to the DUT. It
             : also facilitates the use of the deep_compare_physical()
             : method, should the user need to do so.
---------------------------------------------------------------------------- 
+---------------------------------------------------------------------------
 //----------------------------------------------------------------------
 //   Copyright 2008-2010 Cadence Design Systems, Inc.
 //   All Rights Reserved Worldwide
@@ -31,7 +31,7 @@ Notes       : The addr, read_write and data fields are marked as physical
 //   the License for the specific language governing
 //   permissions and limitations under the License.
 //----------------------------------------------------------------------
--------------------------------------------------------------------------*/ 
+-------------------------------------------------------------------------*/
 
 <'
 
@@ -40,7 +40,7 @@ package cdn_xbus;
 
 
 -- This type is used to sub-type the transfer struct. By default the transfer
--- is a generic transfer, but other code can extend this type to create 
+-- is a generic transfer, but other code can extend this type to create
 -- sub-types that can have extra fields etc for special purposes (e.g.
 -- a master can create a MASTER xbus_trans_s with extra fields).
 type xbus_trans_kind_t : [GENERIC];
@@ -58,17 +58,17 @@ struct xbus_trans_s like any_sequence_item {
     -- with extra fields).
     kind : xbus_trans_kind_t;
         keep soft kind == GENERIC;
-        
+
     -- This field contains the address for the transfer.
     %addr : xbus_addr_t;
-         
+
     -- This field indicates value to be written to bus
     %size_ctrl : uint (bits : 2);
        keep size == 1 => size_ctrl == 0;
        keep size == 2 => size_ctrl == 1;
        keep size == 4 => size_ctrl == 2;
        keep size == 8 => size_ctrl == 3;
-      
+
     -- This field indicates whether this is a a read or write transfer.
     %read_write : xbus_read_write_t;
         keep read_write in [READ, WRITE];
@@ -76,43 +76,43 @@ struct xbus_trans_s like any_sequence_item {
     -- This field indicates the size of the transfer in bytes.
     size : uint [1, 2, 4, 8];
 
-    
-    -- This field is used to pass information when transctors are in 
+
+    -- This field is used to pass information when transctors are in
     -- another language
-   
+
     -- This field contains the data to be transferred as a list of bytes, the
     -- size of the list depends on the size field.
     %data[size] : list of byte;
-    
-    
+
+
     master_name : xbus_agent_name_t;
       keep soft master_name == NO_AGENT;
     slave_name  : xbus_agent_name_t;
       keep soft slave_name == NO_AGENT;
 
-    
+
     -- This method returns the transfer in a "nice" string form that gives a
     -- brief summary of the transfer.
     nice_string() : string is only {
         if read_write == WRITE {
-            result = append(read_write, 
-                        "(", 
+            result = append(read_write,
+                        "(",
                         size,
-                        ",", 
+                        ",",
                         addr,
                         ",{",
                         data,
                         "})");
         } else {
-            result = append(read_write, 
-                        "(", 
+            result = append(read_write,
+                        "(",
                         size,
-                        ",", 
+                        ",",
                         addr,
                         ")");
         };
     }; -- nice_string()
-    
+
 }; -- struct xbus_trans_s
 
 '>
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_types_h.e b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_types_h.e
index 98a27d2..5a4eafd 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_types_h.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/e/xbus_types_h.e
@@ -1,12 +1,12 @@
-/*------------------------------------------------------------------------- 
+/*-------------------------------------------------------------------------
 File name   : xbus_types_h.e
 Title       : Common type declarations
-Project     : UVM XBus UVC 
-Developers  :  
+Project     : UVM XBus UVC
+Developers  :
 Created     : 2008
 Description : This file declares common types used throughout the UVC.
-Notes       : 
---------------------------------------------------------------------------- 
+Notes       :
+---------------------------------------------------------------------------
 //----------------------------------------------------------------------
 //   Copyright 2008-2010 Cadence Design Systems, Inc.
 //   All Rights Reserved Worldwide
@@ -25,7 +25,7 @@ Notes       :
 //   the License for the specific language governing
 //   permissions and limitations under the License.
 //----------------------------------------------------------------------
--------------------------------------------------------------------------*/ 
+-------------------------------------------------------------------------*/
 
 <'
 
@@ -41,14 +41,14 @@ package cdn_xbus;
 
 
 
--- This type enumerates the logical names of each bus in the Verification 
+-- This type enumerates the logical names of each bus in the Verification
 -- Environment.
 type xbus_bus_name_t : [NO_BUS=0];
 
 
 
 -- This type enumerates the logical names of each agent (master, slave or
--- arbiter) in the Verification Environment. 
+-- arbiter) in the Verification Environment.
 type xbus_agent_name_t : [NO_AGENT=0];
 
 
@@ -85,7 +85,7 @@ unit xbus_slave_config_u like uvm_agent_config {
     -- is for. This field is automatically constrained by the UVC and should
     -- not be constrained by the user.
     slave_name : xbus_agent_name_t;
-          
+
 
 };
 
@@ -93,7 +93,7 @@ struct xbus_slave_params like uvm_config_params {
     -- This field specifies the lowest address of the range that the slave will
     -- respond to.
     min_addr : xbus_addr_t;
-   
+
     -- This field specifies the highest address of the range that the slave
     -- will respond to.
     max_addr : xbus_addr_t;
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/examples/msg_patch.e b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/examples/msg_patch.e
index 7726eab..9d64bd4 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/examples/msg_patch.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/examples/msg_patch.e
@@ -1,30 +1,30 @@
 
 Acceleration demo runs on 9.2, which does not support SDM
-  
+
 <'
 #ifdef SPECMAN_VERSION_10_2_OR_LATER {
-} 
+}
 #else {
     define <msg_patch'action> "msg_<msg_text'exp>" as {
         // do nothing
     };
 
     struct recording_config {
-         register_field_attribute(struct_name: string, 
+         register_field_attribute(struct_name: string,
                                   field_name: string) is empty;
-         register_field_attributes(struct_name: string, 
+         register_field_attributes(struct_name: string,
                                    field_names: list of string) is empty;
-        
-        register_callback_attribute(struct_name: string, 
+
+        register_callback_attribute(struct_name: string,
 
                                     attr_name: string) is empty;
-   
+
     };
 
     extend any_unit {
         tr_get_attribute_value(inst : any_struct,
                                name : string) : string is empty;
-        
+
         assign_recording_config(cfg: recording_config) is empty;
     };
 };
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/examples/test_1.e b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/examples/test_1.e
index c0f9ab9..21ac7d6 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/examples/test_1.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/examples/test_1.e
@@ -1,4 +1,4 @@
-/*------------------------------------------------------------------------- 
+/*-------------------------------------------------------------------------
 File name   : test_1.e
 Title       : XBus eVC demo - example testcase file
 Project     : XBus eVC
@@ -7,8 +7,8 @@ Description : Example testcase file for demo purposes.
             : Master0 sends 10..12 transfers
             : Master1 sends 1..5 transfers
             : The slaves respond with error for every transfer longer than 4
-Notes       : 
---------------------------------------------------------------------------- 
+Notes       :
+---------------------------------------------------------------------------
 //----------------------------------------------------------------------
 //   Copyright 2008-2010 Cadence Design Systems, Inc.
 //   All Rights Reserved Worldwide
@@ -27,7 +27,7 @@ Notes       :
 //   the License for the specific language governing
 //   permissions and limitations under the License.
 //----------------------------------------------------------------------
--------------------------------------------------------------------------*/ 
+-------------------------------------------------------------------------*/
 
 <'
 package cdn_xbus;
@@ -40,13 +40,13 @@ import xbus_e/examples/xbus_config;
 -- position 4.
 extend xbus_slave_response_s {
     keep read_only(transfer.size > 4) => error_pos == 4;
-}; 
+};
 
 -- Make sure masters expect errors as described above.
 extend MASTER xbus_trans_s {
-    
+
     keep read_only(size > 4) =>  error_pos_master == 4;
-    
+
 };
 
 
@@ -67,9 +67,9 @@ extend MASTER_1 MAIN MAIN_TEST xbus_master_sequence {
 extend xbus_bus_monitor_u {
     on transfer_end {
         message(LOW, "bus_monitor saw transfer sent from ",
-                transfer.master_name, 
-                " of length ", transfer.data.size(), 
-                transfer.error_pos_mon == 0 ? "" : " and Error raised"); 
+                transfer.master_name,
+                " of length ", transfer.data.size(),
+                transfer.error_pos_mon == 0 ? "" : " and Error raised");
     };
 };
 '>
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/examples/test_multi_reset.e b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/examples/test_multi_reset.e
index 34763b6..c70335a 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/examples/test_multi_reset.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/examples/test_multi_reset.e
@@ -1,16 +1,16 @@
-/*------------------------------------------------------------------------- 
+/*-------------------------------------------------------------------------
 File name   : test_multi_reset.e
 Title       : XBus eVC demo - example of multiple reset handling
 Project     : XBus eVC
 Created     : 2008
 Description : Example testcase file for demo purposes
 Notes       : This file demonstrates the ability of the eVC to cope with
-            : multiple resets. Master_0 perform 6 resets 
+            : multiple resets. Master_0 perform 6 resets
             :
-            : For seeing messages from the Testflow utilitiy (note - there 
+            : For seeing messages from the Testflow utilitiy (note - there
             : are many of them) issue  in Specman prompt:
             :     trace testflow
--------------------------------------------------------------------------*/ 
+-------------------------------------------------------------------------*/
 //----------------------------------------------------------------------
 //   Copyright 2008-2010 Cadence Design Systems, Inc.
 //   All Rights Reserved Worldwide
@@ -29,7 +29,7 @@ Notes       : This file demonstrates the ability of the eVC to cope with
 //   the License for the specific language governing
 //   permissions and limitations under the License.
 //----------------------------------------------------------------------
--------------------------------------------------------------------------*/ 
+-------------------------------------------------------------------------*/
 
 <'
 
@@ -45,7 +45,7 @@ extend MAIN MAIN_TEST xbus_master_sequence {
 -- Issue an extra reset half way through the test
 extend xbus_master_driver_u {
     do_extra_reset() @sys.any is {
-        if tf_get_domain_mgr().get_invocation_count(MAIN_TEST) < 6 
+        if tf_get_domain_mgr().get_invocation_count(MAIN_TEST) < 6
                                                                   then {
             var delay : uint;
             gen delay keeping {it in [1..200]};
@@ -54,7 +54,7 @@ extend xbus_master_driver_u {
             tf_get_domain_mgr().rerun_phase(RESET);
         };
     }; -- do_extra_reset()
-    
+
     tf_main_test() @tf_phase_clock is also {
         do_extra_reset();
     }; -- tf_main_test()
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/examples/test_read_write.e b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/examples/test_read_write.e
index 029c144..ad17c46 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/examples/test_read_write.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/examples/test_read_write.e
@@ -1,12 +1,12 @@
-/*------------------------------------------------------------------------- 
+/*-------------------------------------------------------------------------
 File name   : test_read_write.e
 Title       : XBus eVC demo - example testcase file
 Project     : XBus eVC
 Created     : 2008
 Description : This file demonstrates the read() and write() sequence
             : methods.
-Notes       : 
---------------------------------------------------------------------------- 
+Notes       :
+---------------------------------------------------------------------------
 //----------------------------------------------------------------------
 //   Copyright 2008-2010 Cadence Design Systems, Inc.
 //   All Rights Reserved Worldwide
@@ -25,7 +25,7 @@ Notes       :
 //   the License for the specific language governing
 //   permissions and limitations under the License.
 //----------------------------------------------------------------------
--------------------------------------------------------------------------*/ 
+-------------------------------------------------------------------------*/
 
 <'
 
@@ -39,7 +39,7 @@ extend sys {
         -- Print in hexadecimal by default
         set_config(print, radix, hex);
     };
-    
+
 }; -- extend sys
 
 -- Create a sequence for MASTER_0
@@ -48,35 +48,35 @@ extend MASTER_0 MAIN MAIN_TEST xbus_master_sequence {
     body() @driver.clock is only {
         var data : uint(bits:64);
         var i    : uint = 0;
-        
+
         data = 0x1122334455667788;
         write(8, 0x1000 + i * 64, data);
         message(LOW, "WRITE DATA = ", data);
         data = read(8, 0x1000 + i * 64);
         message(LOW, "READ DATA = ", data);
-        
+
         i = 1;
         data = 0xaabbccdd;
         write(4, 0x1000 + i * 64, data);
         message(LOW, "WRITE DATA = ", data);
         data = read(8, 0x1000 + i * 64);
         message(LOW, "READ DATA = ", data);
-        
+
         i = 2;
         data = 0x11;
         write(1, 0x1000 + i * 64, data);
         message(LOW, "WRITE DATA = ", data);
         data = read(8, 0x1000 + i * 64);
         message(LOW, "READ DATA = ", data);
-        
+
         i = 3;
         data = 0x4422886611335577;
         write(8, 0x1000 + i * 64, data);
         message(LOW, "WRITE DATA = ", data);
         data = read(8, 0x1000 + i * 64);
         message(LOW, "READ DATA = ", data);
-        
-    };   
+
+    };
 };
 
 -- Create a sequence for MASTER_1
@@ -84,15 +84,15 @@ extend MASTER_0 MAIN MAIN_TEST xbus_master_sequence {
 extend MASTER_1 MAIN MAIN_TEST xbus_master_sequence {
     !wr_seq : WRITE_TRANSFER xbus_master_sequence;
     !rd_seq : READ_TRANSFER xbus_master_sequence;
-    
+
     body() @driver.clock is only {
         var data : uint(bits:64);
         var addr : uint(bits:64);
-        
+
         for i from 0 to 3 {
             gen addr keeping {it in [0x2000..0x3000]};
             gen data;
-            
+
             do wr_seq keeping {
                 .base_addr == addr;
                 .data == data;
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/examples/test_reconfiguration.e b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/examples/test_reconfiguration.e
index 825407d..979cafc 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/examples/test_reconfiguration.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/examples/test_reconfiguration.e
@@ -1,15 +1,15 @@
-/*------------------------------------------------------------------------- 
+/*-------------------------------------------------------------------------
 File name   : test_reconfiguration.e
 Title       : XBus eVC demo - example of multiple reset handling
 Project     : XBus eVC
 Created     : 2008
 Description : Example testcase file for demo purposes
 Notes       : This file demonstrates the ability of the eVC to cope with
-            : multiple configurations. 
-            :  
+            : multiple configurations.
+            :
             : Call xbus_env configure method several times, each time
             : with different set of parameters, and check the result.
--------------------------------------------------------------------------*/ 
+-------------------------------------------------------------------------*/
 //----------------------------------------------------------------------
 //   Copyright 2008-2010 Cadence Design Systems, Inc.
 //   All Rights Reserved Worldwide
@@ -28,7 +28,7 @@ Notes       : This file demonstrates the ability of the eVC to cope with
 //   the License for the specific language governing
 //   permissions and limitations under the License.
 //----------------------------------------------------------------------
--------------------------------------------------------------------------*/ 
+-------------------------------------------------------------------------*/
 
 <'
 
@@ -45,13 +45,13 @@ extend MAIN MAIN_TEST xbus_master_sequence {
 extend xbus_env_u {
 
     tf_main_test() @tf_phase_clock is also {
-        
+
         wait [100] * cycle;
-        
+
         message(LOW, "Config MIN_ADDR of SLAVE_0 to 0x12 ",
                      "and its MAX_ADDR to 0xffe");
         //            ------------------------------------
-        uvm_configure 1 me {slave_name;  min_addr; max_addr} 
+        uvm_configure 1 me {slave_name;  min_addr; max_addr}
                 {xbus_agent_name_t'SLAVE_0; 0x12; 0xffe};
 
 
@@ -63,25 +63,25 @@ extend xbus_env_u {
           dut_error("2nd configuration failed, config.max_addr == ",
                     slaves[0].config.params.max_addr);
 
-        
+
         message(LOW, "Config MAX_ADDR of SLAVE_1 to 0xbeef");
         //            ----------------------------------------
-        uvm_configure 2 me {slave_name;  max_addr} 
+        uvm_configure 2 me {slave_name;  max_addr}
                 {xbus_agent_name_t'SLAVE_1; 0xbeef};
-       
-        
+
+
         // Check:
         check that slaves[1].config.params.max_addr == 0xbeef else
           dut_error("1st configuration failed, config.max_addr == ",
                     slaves[1].config.params.max_addr);
-         
-        
-        
+
+
+
         wait cycle;
         message(LOW, "Min address of slave0 to 0, ",
                      "Max address of slave0 to 0x7ff0");
         //           -------------------------------
-        uvm_configure 3 me {slave_name;  min_addr; max_addr} 
+        uvm_configure 3 me {slave_name;  min_addr; max_addr}
                 {xbus_agent_name_t'SLAVE_0; 0x0; 0x7fff};
 
         // Check:
@@ -91,13 +91,13 @@ extend xbus_env_u {
         check that slaves[0].config.params.max_addr == 0x7fff else
           dut_error("3rd configuration failed, config.max_addr == ",
                     slaves[0].config.params.max_addr);
-      
+
 
         wait cycle;
         message(LOW, "Min address of slave1 to 0x8000, ",
                      "Max address of slave0 to 0xffff");
         //           -------------------------------
-        uvm_configure 4 me {slave_name;  min_addr; max_addr} 
+        uvm_configure 4 me {slave_name;  min_addr; max_addr}
                 {xbus_agent_name_t'SLAVE_1; 0x8000; 0xffff};
 
         // Check:
@@ -107,12 +107,12 @@ extend xbus_env_u {
         check that slaves[1].config.params.max_addr == 0xffff else
           dut_error("4th configuration failed, config.max_addr == ",
                     slaves[1].config.params.max_addr);
-    
+
         wait [150] * cycle;
 
     }; -- tf_main_test()
 
-}; 
+};
 
 '>
 
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/examples/test_signal.e b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/examples/test_signal.e
index 3779abe..41306eb 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/examples/test_signal.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/examples/test_signal.e
@@ -1,4 +1,4 @@
-/*------------------------------------------------------------------------- 
+/*-------------------------------------------------------------------------
 File name   : test_1.e
 Title       : XBus eVC demo - example testcase file
 Project     : XBus eVC
@@ -7,8 +7,8 @@ Description : Example testcase file for demo purposes.
             : Master0 sends 10..12 transfers
             : Master1 sends 1..5 transfers
             : The slaves respond with error for every transfer longer than 4
-Notes       : 
---------------------------------------------------------------------------- 
+Notes       :
+---------------------------------------------------------------------------
 //----------------------------------------------------------------------
 //   Copyright 2008-2010 Cadence Design Systems, Inc.
 //   All Rights Reserved Worldwide
@@ -27,7 +27,7 @@ Notes       :
 //   the License for the specific language governing
 //   permissions and limitations under the License.
 //----------------------------------------------------------------------
--------------------------------------------------------------------------*/ 
+-------------------------------------------------------------------------*/
 
 <'
 package cdn_xbus;
@@ -40,13 +40,13 @@ import xbus_e/examples/xbus_arbiter_dut_rtl_config.e;
 -- position 4.
 extend xbus_slave_response_s {
     keep read_only(transfer.size > 4) => error_pos == 4;
-}; 
+};
 
 -- Make sure masters expect errors as described above.
 extend MASTER xbus_trans_s {
-    
+
     keep read_only(size > 4) =>  error_pos_master == 4;
-    
+
 };
 
 
@@ -67,9 +67,9 @@ extend MASTER_1 MAIN MAIN_TEST xbus_master_sequence {
 extend xbus_bus_monitor_u {
     on transfer_end {
         message(LOW, "bus_monitor saw transfer sent from ",
-                transfer.master_name, 
-                " of length ", transfer.data.size(), 
-                transfer.error_pos_mon == 0 ? "" : " and Error raised"); 
+                transfer.master_name,
+                " of length ", transfer.data.size(),
+                transfer.error_pos_mon == 0 ? "" : " and Error raised");
     };
 };
 '>
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/examples/test_tba.e b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/examples/test_tba.e
index de7e09c..c68c8fb 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/examples/test_tba.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/examples/test_tba.e
@@ -1,12 +1,12 @@
-/*------------------------------------------------------------------------- 
+/*-------------------------------------------------------------------------
 File name   : test_tba.e
 Title       : XBus eVC demo - example testcase file
 Project     : XBus eVC
 Created     : 2008
 Description : Example testcase file for demo purposes.
-            : 
-Notes       : 
---------------------------------------------------------------------------- 
+            :
+Notes       :
+---------------------------------------------------------------------------
 //----------------------------------------------------------------------
 //   Copyright 2008-2010 Cadence Design Systems, Inc.
 //   All Rights Reserved Worldwide
@@ -25,7 +25,7 @@ Notes       :
 //   the License for the specific language governing
 //   permissions and limitations under the License.
 //----------------------------------------------------------------------
--------------------------------------------------------------------------*/ 
+-------------------------------------------------------------------------*/
 
 <'
 package cdn_xbus;
@@ -49,7 +49,7 @@ extend MASTER_0 MAIN xbus_master_sequence {
 };
 
 extend MASTER_0 MAIN ENV_SETUP xbus_master_sequence {
-    
+
     body() @driver.clock is only {
         // Generate one transfer
         gen trans keeping {it.driver == driver; it.size == 4};
@@ -65,8 +65,8 @@ extend MASTER_0 MAIN ENV_SETUP xbus_master_sequence {
             driver.queue_item(me, deep_copy(trans));
             trans.read_write = READ;
             trans.addr = 0x0000 + 4 + i;
-            driver.queue_item(me, deep_copy(trans));             
-        };    
+            driver.queue_item(me, deep_copy(trans));
+        };
     };
 };
 
@@ -80,7 +80,7 @@ extend MASTER xbus_trans_s {
     keep for each in wait_states  {
         soft it == 0;
     };
-}; 
+};
 
 // For self checking - see what the monitor saw
 
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/examples/xbus.sv b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/examples/xbus.sv
index a73dd87..c20084e 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/examples/xbus.sv
+++ b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/examples/xbus.sv
@@ -1,5 +1,5 @@
 
-# SimVision Command Script 
+# SimVision Command Script
 #
 # Design Browser windows
 #
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/examples/xbus_arbiter_dut_signal_config.e b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/examples/xbus_arbiter_dut_signal_config.e
index 12fd7b7..7bc72e1 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/examples/xbus_arbiter_dut_signal_config.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/examples/xbus_arbiter_dut_signal_config.e
@@ -1,12 +1,12 @@
-/*------------------------------------------------------------------------- 
+/*-------------------------------------------------------------------------
 File name   : xbus_arbiter_dut_rtl_config.e
 Title       : XBus eVC example configuration file
 Project     : XBus eVC
 Created     : 2008
 Description : This file provides XBus eVC configuration that is common to
             : all test cases.
-Notes       : 
---------------------------------------------------------------------------- 
+Notes       :
+---------------------------------------------------------------------------
 //----------------------------------------------------------------------
 //   Copyright 2008-2010 Cadence Design Systems, Inc.
 //   All Rights Reserved Worldwide
@@ -25,12 +25,12 @@ Notes       :
 //   the License for the specific language governing
 //   permissions and limitations under the License.
 //----------------------------------------------------------------------
--------------------------------------------------------------------------*/ 
+-------------------------------------------------------------------------*/
 
 
 <'
 #ifdef SPECMAN_VERSION_10_2_OR_LATER {
-} 
+}
 #else {
    import msg_patch;
 };
@@ -38,14 +38,14 @@ Notes       :
 
 '>
 
-<'  
+<'
 
 -- Import the XBus eVC
 import xbus_e/e/xbus_top;
 
 import xbus_e/e/xbus_port_config;
 
--- Create a logical name for the eVC instance. 
+-- Create a logical name for the eVC instance.
 extend xbus_bus_name_t : [XBUS];
 
 -- Instantiate the eVC under sys.
@@ -56,8 +56,8 @@ extend sys {
 -- Create a logical name for each agent in the bus (including both ACTIVE and
 -- PASSIVE agents).
 
-extend xbus_agent_name_t : [MASTER_0, 
-                            SLAVE_0, 
+extend xbus_agent_name_t : [MASTER_0,
+                            SLAVE_0,
                             ARB_0];
 
 -- Instantiate the agents under the eVC instance
@@ -65,10 +65,10 @@ extend XBUS xbus_env_u {
     keep hdl_path()     == "xbus_arbiter_tb.xbus_env";
 
     keep passive_master_names == {};
-    keep active_master_names  == {MASTER_0}; 
+    keep active_master_names  == {MASTER_0};
     keep passive_slave_names  == {};
-    keep active_slave_names   == {SLAVE_0}; 
-    
+    keep active_slave_names   == {SLAVE_0};
+
     -- The arbiter agent is called ARB_0 and is ACTIVE
     keep arbiter is a ARB_0 PASSIVE ARBITER xbus_agent_u;
     -- This instance of the eVC has a protocol checker
@@ -80,7 +80,7 @@ extend XBUS xbus_env_u {
 extend XBUS xbus_synchronizer_u {
     keep sig_clock.hdl_path() == "clk";
     keep sig_reset.hdl_path() == "rst";
-    
+
     keep sig_reset.verilog_wire() == TRUE;
 };
 extend XBUS xbus_signal_map_u {
@@ -93,9 +93,9 @@ extend XBUS xbus_signal_map_u {
     keep sig_bip.hdl_path()   == "sig_bip";
     keep sig_wait.hdl_path()  == "sig_wait";
     keep sig_error.hdl_path() == "sig_error";
-    keep sig_data.hdl_path()  == "sig_data_out";  
+    keep sig_data.hdl_path()  == "sig_data_out";
+
 
-   
     keep sig_data.declared_range() == "[7:0]";
 };
 
@@ -141,7 +141,7 @@ extend sys {
     };
     init() is also {
         // Use a performance enhancement feature
-        set_config(simulation, enable_ports_unification, TRUE);   
+        set_config(simulation, enable_ports_unification, TRUE);
     };
 };
 
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/examples/xbus_arbiter_dut_tba_config.e b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/examples/xbus_arbiter_dut_tba_config.e
index 892caf5..3e7f55d 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/examples/xbus_arbiter_dut_tba_config.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/examples/xbus_arbiter_dut_tba_config.e
@@ -1,12 +1,12 @@
-/*------------------------------------------------------------------------- 
+/*-------------------------------------------------------------------------
 File name   : xbus_arbiter_dut_accel_config.e
 Title       : XBus eVC example configuration file
 Project     : XBus eVC
 Created     : 2011
 Description : This file provides XBus eVC configuration that is common to
             : all test cases.
-Notes       : 
---------------------------------------------------------------------------- 
+Notes       :
+---------------------------------------------------------------------------
 //----------------------------------------------------------------------
 //   Copyright 2008-2010 Cadence Design Systems, Inc.
 //   All Rights Reserved Worldwide
@@ -25,12 +25,12 @@ Notes       :
 //   the License for the specific language governing
 //   permissions and limitations under the License.
 //----------------------------------------------------------------------
--------------------------------------------------------------------------*/ 
+-------------------------------------------------------------------------*/
 
 
 <'
 #ifdef SPECMAN_VERSION_10_2_OR_LATER {
-} 
+}
 #else {
    import msg_patch;
 };
@@ -47,7 +47,7 @@ import xbus_e/e/xbus_accel;
 
 import xbus_e/e/xbus_port_config;
 
--- Create a logical name for the eVC instance. 
+-- Create a logical name for the eVC instance.
 extend xbus_bus_name_t : [XBUS];
 
 -- Instantiate the eVC under sys.
@@ -58,8 +58,8 @@ extend sys {
 -- Create a logical name for each agent in the bus (including both ACTIVE and
 -- PASSIVE agents).
 
-extend xbus_agent_name_t : [MASTER_0, 
-                            SLAVE_0, 
+extend xbus_agent_name_t : [MASTER_0,
+                            SLAVE_0,
                             ARB_0];
 
 -- Instantiate the agents under the eVC instance
@@ -67,10 +67,10 @@ extend XBUS xbus_env_u {
     keep hdl_path()     == "xbus_tb_top.dut";
     keep abstraction_level == UVM_ACCEL;
     keep passive_master_names == {};
-    keep active_master_names  == {MASTER_0}; 
+    keep active_master_names  == {MASTER_0};
     keep passive_slave_names  == {};
-    keep active_slave_names   == {SLAVE_0}; 
-    
+    keep active_slave_names   == {SLAVE_0};
+
     -- The arbiter agent is called ARB_0 and is ACTIVE
     keep arbiter is a ARB_0 PASSIVE ARBITER xbus_agent_u;
     -- This instance of the eVC has a protocol checker
@@ -88,12 +88,12 @@ extend XBUS xbus_signal_map_u {
     keep sig_bip.hdl_path()   == "sig_bip";
     keep sig_wait.hdl_path()  == "sig_wait";
     keep sig_error.hdl_path() == "sig_error";
-    keep sig_data.hdl_path()  == "sig_data_out";  
+    keep sig_data.hdl_path()  == "sig_data_out";
 };
 extend XBUS xbus_synchronizer_u {
     keep sig_clock.hdl_path() == "clk";
     keep sig_reset.hdl_path() == "rst";
-    
+
     keep sig_reset.verilog_wire() == TRUE;
 };
 extend MASTER_0 xbus_master_signal_map_u {
@@ -124,7 +124,7 @@ extend sys {
     };
     init() is also {
         // Use a performance enhancement feature
-        set_config(simulation, enable_ports_unification, TRUE);   
+        set_config(simulation, enable_ports_unification, TRUE);
     };
 };
 
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/examples/xbus_config.e b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/examples/xbus_config.e
index 37ef450..8022e3f 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/examples/xbus_config.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/examples/xbus_config.e
@@ -1,12 +1,12 @@
-/*------------------------------------------------------------------------- 
+/*-------------------------------------------------------------------------
 File name   : xbus_config.e
 Title       : XBus eVC example configuration file
 Project     : XBus eVC
 Created     : 2008
 Description : This file provides XBus eVC configuration that is common to
             : all test cases.
-Notes       : 
---------------------------------------------------------------------------- 
+Notes       :
+---------------------------------------------------------------------------
 //----------------------------------------------------------------------
 //   Copyright 2008-2010 Cadence Design Systems, Inc.
 //   All Rights Reserved Worldwide
@@ -25,7 +25,7 @@ Notes       :
 //   the License for the specific language governing
 //   permissions and limitations under the License.
 //----------------------------------------------------------------------
--------------------------------------------------------------------------*/ 
+-------------------------------------------------------------------------*/
 
 <'
 
@@ -34,7 +34,7 @@ import xbus_e/e/xbus_top;
 
 import xbus_e/e/xbus_port_config;
 
--- Create a logical name for the eVC instance. 
+-- Create a logical name for the eVC instance.
 extend xbus_bus_name_t : [XBUS];
 
 -- Instantiate the eVC under sys.
@@ -45,10 +45,10 @@ extend sys {
 -- Create a logical name for each agent in the bus (including both ACTIVE and
 -- PASSIVE agents).
 
-extend xbus_agent_name_t : [MASTER_0, 
-                               MASTER_1, 
-                               SLAVE_0, 
-                               SLAVE_1, 
+extend xbus_agent_name_t : [MASTER_0,
+                               MASTER_1,
+                               SLAVE_0,
+                               SLAVE_1,
                                ARB_0];
 
 -- Instantiate the agents under the eVC instance
@@ -59,7 +59,7 @@ extend XBUS xbus_env_u {
     keep active_master_names    == {MASTER_0; MASTER_1};
     keep passive_slave_names  == {};
     keep active_slave_names     == {SLAVE_0; SLAVE_1};
-    
+
     -- The arbiter agent is called ARB_0 and is ACTIVE
     keep arbiter is a ARB_0 ACTIVE ARBITER xbus_agent_u;
     -- This instance of the eVC has a protocol checker
@@ -81,7 +81,7 @@ extend XBUS xbus_signal_map_u {
     keep sig_bip.hdl_path()   == "xbus_bip";
     keep sig_wait.hdl_path()  == "xbus_wait";
     keep sig_error.hdl_path() == "xbus_error";
-    keep sig_data.hdl_path()  == "xbus_data";  
+    keep sig_data.hdl_path()  == "xbus_data";
 };
 extend XBUS MASTER_0 xbus_master_signal_map_u {
     keep sig_request.hdl_path() == "xbus_req_master_0";
@@ -121,7 +121,7 @@ extend sys {
     };
     init() is also {
         // Use a performance enhancement feature
-        set_config(simulation, enable_ports_unification, TRUE);   
+        set_config(simulation, enable_ports_unification, TRUE);
     };
 };
 
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/examples/xbus_dut_top.sv b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/examples/xbus_dut_top.sv
index b1a49e8..02789e0 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/examples/xbus_dut_top.sv
+++ b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/examples/xbus_dut_top.sv
@@ -28,10 +28,10 @@ module xbus_tb_top;
 
 
   reg rst;
-  
+
   dut_top dut(rst);
 
- 
+
 
   initial begin
     rst <= 1'b1;
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/scripts/demo_on_sim.sh b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/scripts/demo_on_sim.sh
index b3c7fc0..0af66d1 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/scripts/demo_on_sim.sh
+++ b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/scripts/demo_on_sim.sh
@@ -58,7 +58,7 @@ sn_compile.sh   $UVM_ACCEL_DIR/e/uvm_accel_pipes_direct.e -D SCEMI_PIPE_DIRECT_C
   -D UXE -D NO_IXCOM -t scemi_adapter -e scemi_adapter -l ./uvm_accel_pipes.o -shlib -exe \
   -o sn_scemi_adapter || exit 6
 
- 
+
 # compile the env with the top referencing the adapter
 if [  "$TBA" = 1 ]; then
 sn_compile.sh  -enable_DAC -shlib -exe -s scemi_adapter/sn_scemi_adapter \
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/scripts/setup.csh b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/scripts/setup.csh
index 83dc10d..b9dac29 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/scripts/setup.csh
+++ b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/scripts/setup.csh
@@ -4,12 +4,12 @@
 # Author      : Cadence Design Systems
 # Date        : January 2011
 # Description : Environment configuration script
-#               This script is divided into 2 main sections. The 
+#               This script is divided into 2 main sections. The
 #               USER CONFIGURABLE VARIABLES section contains variables
-#               that should be defined by the user. The 
-#               AUTOMATIC VARIABLE CONFIGURATION section contains 
+#               that should be defined by the user. The
+#               AUTOMATIC VARIABLE CONFIGURATION section contains
 #               variables that should be set automatically. These
-#               variables should not be changed by the user.  
+#               variables should not be changed by the user.
 ########################################################################
 ########################################################################
 # USER CONFIGURABLE VARIABLES
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/v/tb_xbus.v b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/v/tb_xbus.v
index 05045a3..d777fa6 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xbus_e/v/tb_xbus.v
+++ b/lesson000X_mluvm_svsc/uvm_examples/xbus_e/v/tb_xbus.v
@@ -2,11 +2,11 @@
 //File name   : tb_xbus.v
 //Title       : Verilog testbench for XBus eVC demo
 //Project     : XBus eVC
-//Developers  : 
+//Developers  :
 //Created     : 2001
-//Description : 
-//Notes       : 
-//--------------------------------------------------------------------------- 
+//Description :
+//Notes       :
+//---------------------------------------------------------------------------
 //----------------------------------------------------------------------
 //   Copyright 2008-2010 Cadence Design Systems, Inc.
 //   All Rights Reserved Worldwide
@@ -28,14 +28,14 @@
 //---------------------------------------------------------------------------
 
 module xbus_evc_demo;
-   
+
 
   // xbus signals by agent
   reg xbus_req_master_0;
   reg xbus_gnt_master_0;
   reg xbus_req_master_1;
   reg xbus_gnt_master_1;
-    
+
   // xbus signals
   reg xbus_clock;
   reg xbus_reset;
@@ -49,7 +49,7 @@ module xbus_evc_demo;
   reg xbus_wait;
   reg xbus_error;
 
-initial    
+initial
    begin
       xbus_reset <= 1'b1;
       xbus_clock <= 1'b1;
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xcore/demo.sh b/lesson000X_mluvm_svsc/uvm_examples/xcore/demo.sh
index cb759c4..4791913 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xcore/demo.sh
+++ b/lesson000X_mluvm_svsc/uvm_examples/xcore/demo.sh
@@ -1,7 +1,7 @@
 #!/bin/sh
 #
 # Script for running xcore demo
-# 
+#
 #   demo.sh nc[sim]|mti|vcs|xl verilog|vhdl
 # =============================================================================
 
@@ -20,7 +20,7 @@ else
 fi
 
 package_path=`sn_which.sh xcore`
-xcore_path=`sn_which.sh xcore` 
+xcore_path=`sn_which.sh xcore`
 demo_file="xcore_virtual_seq_test.e"
 vlg_hdl_files="$xcore_path/v/xcore_in_chan.v \
                 $xcore_path/v/xcore_out_chan.v \
@@ -97,17 +97,17 @@ while [ $# -gt 0 ]; do
                         shift
                         ;;
       esac
-      shift       
+      shift
 done
 
 
 do_file=$nc_do_file
 
 
- 
+
 if [ -n "$run_file" ]; then
    cat $do_file > sim_cmd.txt
-   cat $run_file >> sim_cmd.txt 
+   cat $run_file >> sim_cmd.txt
    do_file="sim_cmd.txt"
 fi
 
@@ -119,12 +119,12 @@ hdl_files="$vlg_hdl_files"
 if [ $run_mode = batch ]; then
     gui_flag=""
     echo "run"  >> ./ncsim_run.tcl
-    echo "exit" >> ./ncsim_run.tcl 
+    echo "exit" >> ./ncsim_run.tcl
 
 fi
 
 demo_file=`sn_which.sh $package_path/main_sve/tests/$demo_file`
- 
+
 
  irun \
     -input $nc_do_file \
@@ -139,4 +139,4 @@ demo_file=`sn_which.sh $package_path/main_sve/tests/$demo_file`
     -defineall SPECMAN_INCLUDED
 
 exit
- 
+
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xcore/e/xcore_checker.e b/lesson000X_mluvm_svsc/uvm_examples/xcore/e/xcore_checker.e
index 754fe91..c36eecf 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xcore/e/xcore_checker.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xcore/e/xcore_checker.e
@@ -1,15 +1,15 @@
-/*------------------------------------------------------------------------- 
+/*-------------------------------------------------------------------------
 File name   : xcore_check.e
-Title       : Checking definitions XCore 
+Title       : Checking definitions XCore
 Project     : XCore eVC
 Created     : 2008
-Description : 
-Notes       : 
---------------------------------------------------------------------------- 
+Description :
+Notes       :
+---------------------------------------------------------------------------
 Copyright (c) 2008-2010 Cadence Design Systems,Inc.
   All rights reserved worldwide.
 
--------------------------------------------------------------------------*/ 
+-------------------------------------------------------------------------*/
 
 <'
 package cdn_xcore;
@@ -21,7 +21,7 @@ import  uvm_e/e/uvm_scbd_top.e;
 import uvm_scbd/e/uvm_scbd_top.e;
 };
 '>
-   
+
 
 
 Using the UVM Scoreboard
@@ -30,7 +30,7 @@ Using the UVM Scoreboard
 unit xserial_to_xserial_scbd like uvm_scoreboard {
     scbd_port add_p   : add MONITOR xserial_frame_s;
     scbd_port match_p : match MONITOR xserial_frame_s;
-    
+
     add_p_predict(originator: MONITOR xserial_frame_s) is only {
         if (originator.payload.frame_format != DATA) {
             // Ignore, non Data
@@ -40,7 +40,7 @@ unit xserial_to_xserial_scbd like uvm_scoreboard {
             add_to_scbd(frame);
         };
     }; // add_port_predict()
-    
+
     match_p_reconstruct(originator: MONITOR xserial_frame_s) is only {
         if (originator.payload.frame_format != DATA) {
             // Ignore, non Data
@@ -54,26 +54,26 @@ unit xserial_to_xserial_scbd like uvm_scoreboard {
 '>
 
 
-   
+
    Flow Control
 
 <'
-extend has_checks xcore_monitor_u { 
-    
+extend has_checks xcore_monitor_u {
+
     -- Check the internal signal indicating fifo overflow
     expect no_overflow_signal is @ref_model_fifo_full => {
        [1..100] * cycle;
        @overflow or true(overflow_state != TRUE) } else
       dut_error("XCore did not raise the overflow signal after its ",
                 "RX fifo got full");
-    
-    -- If a frame was sent when the was fifo full - 
+
+    -- If a frame was sent when the was fifo full -
     -- check that xcore sent HALT
     expect no_halt_frame is @overflow => {
        [1..200] * cycle;
        @xcore_sent_halt} else
       dut_error("XCore did not send a HALT frame after overflow");
-    
+
 }; -- extend xcore_monitor_u
 '>
 
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xcore/e/xcore_combined_seq_lib.e b/lesson000X_mluvm_svsc/uvm_examples/xcore/e/xcore_combined_seq_lib.e
index 3f6f0b0..aedea7d 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xcore/e/xcore_combined_seq_lib.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xcore/e/xcore_combined_seq_lib.e
@@ -1,15 +1,15 @@
-/*------------------------------------------------------------------------- 
+/*-------------------------------------------------------------------------
 File name   : xcore_combined_seq_lib.e
 Title       : Sequence lib
 Project     : XCore eVC
 Created     : 2008
 Description : Sequences accessing XCore via XBus and XSerial
-Notes       : 
---------------------------------------------------------------------------- 
+Notes       :
+---------------------------------------------------------------------------
 Copyright (c) 2008-2010 Cadence Design Systems,Inc.
   All rights reserved worldwide.
 
--------------------------------------------------------------------------*/ 
+-------------------------------------------------------------------------*/
 
 <'
 package cdn_xcore;
@@ -27,11 +27,11 @@ extend xcore_combined_sequence_kind : [XCORE_XSERIAL_TO_XBUS,
 extend XCORE_XSERIAL_TO_XBUS xcore_combined_sequence {
 
    body() @driver.clock is {
-      
+
       -- Send one frame to the serial
       do XCORE_SEND_FRAME xserial_sequence;
 
-      -- Bus read the frame 
+      -- Bus read the frame
       do XCORE_XBUS_READ regs_sequence;
    }; -- body() @driver....
 
@@ -42,23 +42,23 @@ extend XCORE_XSERIAL_TO_XBUS xcore_combined_sequence {
 extend XCORE_XSERIAL_TO_XBUS_LOOPBACK xcore_combined_sequence {
 
    body() @driver.clock is {
-      
+
       -- Send one frame to the serial
       do XCORE_SEND_FRAME xserial_sequence;
 
-      -- Bus reads the frame and writes it back 
+      -- Bus reads the frame and writes it back
       do XCORE_XBUS_READ_WRITE regs_sequence;
    }; -- body() @driver....
 };
 
 
--- Send 2 frames to the XCore. If no reads are issued, 
+-- Send 2 frames to the XCore. If no reads are issued,
 -- the two frames will fill the RX fifo
 extend XCORE_FILL_RX_FIFO xcore_combined_sequence {
-   
+
    keep xserial_sequence.kind == XCORE_SEND_FRAME;
 
-   body() @driver.clock is {  
+   body() @driver.clock is {
       -- Send 2 frames to the XCore device to fill its fifo
       for i from 0 to 1 {
          do xserial_sequence;
@@ -67,21 +67,21 @@ extend XCORE_FILL_RX_FIFO xcore_combined_sequence {
 }; -- extend XCORE_FILL_RX_FIFO
 
 
--- Send 2 frames to the XCore. If no reads are issued, 
+-- Send 2 frames to the XCore. If no reads are issued,
 -- the two frames will fill the RX fifo.
 -- Then, read the frames
 extend XCORE_FILL_RX_FIFO_AND_READ_IT xcore_combined_sequence {
-   
+
    keep xserial_sequence.kind == XCORE_SEND_FRAME;
    keep regs_sequence.kind == XCORE_XBUS_READ;
 
-   body() @driver.clock is {  
+   body() @driver.clock is {
       -- Send 2 frames to the XCore device to fill its fifo
       for i from 0 to 1 {
          do xserial_sequence;
       }; -- for i from 0 to...
 
-      
+
       -- Read the frames from the XCore
       for i from 0 to 1 {
          do regs_sequence;
@@ -91,4 +91,4 @@ extend XCORE_FILL_RX_FIFO_AND_READ_IT xcore_combined_sequence {
 
 }; -- extend XCORE_FILL_RX_FIFO_AND_READ_IT
 '>
-  
+
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xcore/e/xcore_combined_sequence_h.e b/lesson000X_mluvm_svsc/uvm_examples/xcore/e/xcore_combined_sequence_h.e
index ad6c8ce..960226e 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xcore/e/xcore_combined_sequence_h.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xcore/e/xcore_combined_sequence_h.e
@@ -1,20 +1,20 @@
-/*------------------------------------------------------------------------- 
+/*-------------------------------------------------------------------------
 File name   : xcore_combined_sequence_h.e
 Title       : Sequence definition
 Project     : XCore eVC
 Created     : 2008
 Description : Sequences accessing XCore via XBus and XSerial
-Notes       : 
---------------------------------------------------------------------------- 
+Notes       :
+---------------------------------------------------------------------------
 Copyright (c) 2008-2010 Cadence Design Systems,Inc.
   All rights reserved worldwide.
 
--------------------------------------------------------------------------*/ 
+-------------------------------------------------------------------------*/
 
 <'
 package cdn_xcore;
 '>
-   
+
 <'
 sequence xcore_combined_sequence using testflow = TRUE, created_driver = xcore_virtual_driver;
 
@@ -24,31 +24,31 @@ extend xcore_combined_sequence {
     !regs_sequence    : vr_ad_sequence;
     !xserial_sequence : xserial_sequence;
     !xbus_sequence    : xbus_master_sequence;
-    
+
     keep regs_sequence.driver == driver.xcore_regs_driver;
     keep xserial_sequence.driver == driver.xserial_driver;
     keep xbus_sequence.driver == driver.xbus_driver;
-    
 
-    // Cover the sequence. 
+
+    // Cover the sequence.
     // Ignore the pre-defined kinds, they do not add info to the coverage
     cover ended is {
         item kind using ignore = (kind == RANDOM or
                                   kind == MAIN);
-    }; 
-  
+    };
+
 }; -- extend xcore...
 
 
 extend MAIN xcore_combined_sequence {
-   
+
    -- If this field is TRUE (the default), then an objection to TEST_DONE
    -- is raised for the duration of the MAIN sequence. If this field is FALSE
    -- then the MAIN sequence does not contribute to the determination of
    -- end-of-test.
    prevent_test_done : bool;
       keep soft prevent_test_done == FALSE;
-   
+
 
 };
 
@@ -67,15 +67,15 @@ extend MAIN POST_TEST xcore_combined_sequence {
         message(TESTFLOW_EX, LOW, "MAIN POST_TEST sequence finished");
         driver.drop_objection(TEST_DONE);
     }; -- post_body()
-    
-    
+
+
 }; -- extend virtual_...
 
 extend xcore_virtual_driver {
    !xcore_regs_driver    : vr_ad_sequence_driver;
    !xserial_driver       : xserial_driver_u;
    !xbus_driver          : xbus_master_driver_u;
-   
+
    event clock is only @sys.any;
 
    get_sub_drivers(): list of any_sequence_driver is {
@@ -86,4 +86,4 @@ extend xcore_virtual_driver {
 
 '>
 
-    
+
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xcore/e/xcore_compile_base.e b/lesson000X_mluvm_svsc/uvm_examples/xcore/e/xcore_compile_base.e
index ac2c4fd..1fd23be 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xcore/e/xcore_compile_base.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xcore/e/xcore_compile_base.e
@@ -1,16 +1,16 @@
-/*------------------------------------------------------------------------- 
+/*-------------------------------------------------------------------------
 File name   : xcore_compile_base.e
 Title       : Compile base of XCore eVC
 Project     : XCore eVC
 Created     : 2008
-Description : This file imports the files that are to be compiled before 
+Description : This file imports the files that are to be compiled before
             : everything
-Notes       : 
---------------------------------------------------------------------------- 
+Notes       :
+---------------------------------------------------------------------------
 Copyright (c) 2008-2010 Cadence Design Systems,Inc.All rights reserved worldwide.
 Please refer to the terms and conditions in $IPCM_HOME
 
--------------------------------------------------------------------------*/ 
+-------------------------------------------------------------------------*/
 
 <'
 
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xcore/e/xcore_config.e b/lesson000X_mluvm_svsc/uvm_examples/xcore/e/xcore_config.e
index 77cb010..ec45d0a 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xcore/e/xcore_config.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xcore/e/xcore_config.e
@@ -1,15 +1,15 @@
-/*------------------------------------------------------------------------- 
+/*-------------------------------------------------------------------------
 File name   : xcore_config.e
 Title       : XCore configuration
 Project     : XCore eVC
 Created     : 2008
 Description : This file configures the top level unit of the eVC
-Notes       : 
---------------------------------------------------------------------------- 
+Notes       :
+---------------------------------------------------------------------------
 Copyright (c) 2008-2010 Cadence Design Systems,Inc.
   All rights reserved worldwide.
 
--------------------------------------------------------------------------*/ 
+-------------------------------------------------------------------------*/
 
 <'
 
@@ -22,17 +22,17 @@ extend xcore_virtual_driver {
 
 
 extend sys {
-   
-    
+
+
     connect_pointers() is also {
-        
-        // Reset of the DUT is performed by the xbus Master, so the other 
-        // domains - xserial and xcore - should not proceed beyond RESET 
-        // before the xbus is done with all initial phases (INIT_LINK is 
+
+        // Reset of the DUT is performed by the xbus Master, so the other
+        // domains - xserial and xcore - should not proceed beyond RESET
+        // before the xbus is done with all initial phases (INIT_LINK is
         // the last phase before MAIN_TEST)
         tf_add_dependency(XSERIAL_TF, RESET, XBUS_TF, INIT_LINK);
         tf_add_dependency(XCORE_TF,   RESET, XBUS_TF, INIT_LINK);
-        
+
         // Define dependencies: The three domains should synchronize on
         //  MAIN_TEST and POST_TEST
         //  - do not start main test scenario before all are out of reset,
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xcore/e/xcore_cover.e b/lesson000X_mluvm_svsc/uvm_examples/xcore/e/xcore_cover.e
index 60bd159..7b3fab1 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xcore/e/xcore_cover.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xcore/e/xcore_cover.e
@@ -1,21 +1,21 @@
-/*------------------------------------------------------------------------- 
+/*-------------------------------------------------------------------------
 File name   : xcore_cover.e
 Title       : DUT coverage
 Project     : XCore eVC
 Created     : 2008
 Description : This file implements coverage of the major functions of
-            : of the XCore core. 
-            : Covering the actual HDL signals and also the state of the 
+            : of the XCore core.
+            : Covering the actual HDL signals and also the state of the
             : reference model.
 Notes       : This file could also contain coverage of HDL nodes. In this
             : case, the signals to be covered would need to be specified
             : as part of the API for the eVC along with checks to ensure
             : that they are correctly constrained.
---------------------------------------------------------------------------- 
+---------------------------------------------------------------------------
 Copyright (c) 2008-2010 Cadence Design Systems,Inc.
   All rights reserved worldwide.
 
--------------------------------------------------------------------------*/ 
+-------------------------------------------------------------------------*/
 
 <'
 
@@ -23,18 +23,18 @@ package cdn_xcore;
 
 '>
 
-   
+
 
    Coverage definitions of the XBus
-      
-   
+
+
 <'
 extend has_coverage xcore_monitor_u {
 
     cover tx_frame_written is {
-       item name using per_instance; 
-       
-       item data : byte =  cur_xbus_transfer.data[0] using 
+       item name using per_instance;
+
+       item data : byte =  cur_xbus_transfer.data[0] using
           radix = HEX,
           ranges = {
             range([0]);
@@ -42,36 +42,36 @@ extend has_coverage xcore_monitor_u {
             range([0xFF]);
           };
 
-    }; -- cover  tx_frame_written  
+    }; -- cover  tx_frame_written
 
 
     cover rx_frame_read is {
-        item name using per_instance; 
-       
-        item data : byte =  cur_xbus_transfer.data[0] using 
+        item name using per_instance;
+
+        item data : byte =  cur_xbus_transfer.data[0] using
           radix = HEX,
           ranges = {
             range([0]);
             range([1..0xFE]);
             range([0xFF]);
           };
-    }; -- cover rx_frame_read 
-  
-}; -- extend has_coverage xcore_monitor_u 
+    }; -- cover rx_frame_read
+
+}; -- extend has_coverage xcore_monitor_u
 '>
 
-   
+
    Coverage of XCore internals
-   
+
    RX FIFO
-   
+
 
 <'
 extend has_coverage xcore_monitor_u {
-    
-    
+
+
     -- Fifo state when XSerial agent transmits to XCore
-    cover rx_frame_started is {      
+    cover rx_frame_started is {
        item name using per_instance;
 
        -- XCore status when XSerial sends frames to it
@@ -87,39 +87,39 @@ extend has_coverage xcore_monitor_u {
        using
           ignore = (sig_flow == FALSE) ,
          at_least = 5;
-    }; -- cover overflow 
+    }; -- cover overflow
+
 
-    
     cover fifo_overflow_sequence is {
        item name using per_instance;
-       item full_of_sequence : bool = TRUE 
+       item full_of_sequence : bool = TRUE
          using
           ignore = (full_of_sequence == FALSE),
            at_least = 5;
     }; -- cover fifo_overflow_sequence
 
-    
-    
+
+
 }; -- extend has_coverage xcore_monitor_u
 
 '>
-   
-   
+
+
    Modify existing coverage definitions according to XCore
 
-   
+
    XSerial:
 
-   
+
 <'
 extend MONITOR xserial_frame_s {
     cover tx_frame_done using also text = "eVC agent sending frames to XCore";
     cover rx_frame_done using also text = "XCore sending frames to eVC agent";
 
-    
+
     cover tx_frame_done   is also {
-        
-        item data 
+
+        item data
          using also
            ranges = {
              range([0]);
@@ -127,21 +127,21 @@ extend MONITOR xserial_frame_s {
              range([0xFF]);
            }; --
 
-       item inter_frame_delay 
+       item inter_frame_delay
          using also
            ranges = {
              range([1]);
              range([2..100]);
              range([101..1000]);
            };
-        
+
         item frame_message using also ignore = frame_message == UNDEFINED;
         item frame_format using also ignore = frame_format == UNDEFINED;
     }; -- cover tx_frame_...
 
     cover rx_frame_done is also {
 
-        item data 
+        item data
          using also
            ranges = {
              range([0]);
@@ -149,7 +149,7 @@ extend MONITOR xserial_frame_s {
              range([0xFF]);
            }; --
 
-       item inter_frame_delay 
+       item inter_frame_delay
          using also
            ranges = {
              range([1]);
@@ -159,14 +159,14 @@ extend MONITOR xserial_frame_s {
         item frame_message using also ignore = frame_message == UNDEFINED;
     }; -- cover rx_frame_...
 
-    
+
  }; --
 
 '>
-  
-   
+
+
    XBus:
-   
+
 <'
 extend xbus_bus_monitor_u {
     cover transfer_end is also {
@@ -183,54 +183,54 @@ extend xbus_agent_monitor_u {
 
 extend xcore_monitor_u {
    post_generate() is also {
-      covers.set_cover("xbus_agent_monitor_u.agent_trans_end(name==NO_AGENT)", 
+      covers.set_cover("xbus_agent_monitor_u.agent_trans_end(name==NO_AGENT)",
        FALSE);
 
    }; -- post_generate() is also
 
-}; -- extend xcore_monitor_u 
+}; -- extend xcore_monitor_u
 
 '>
-   
-   
-   
-   
+
+
+
+
    Registers:
 
-   
+
 <'
 extend vr_ad_reg {
-        
+
     cover reg_access (kind == XCORE_TX_MODE) is also {
-       item direction 
-         using also 
+       item direction
+         using also
            ignore = (direction == READ);
     }; -- cover reg_acces...
 
     cover reg_access (kind == XCORE_RX_DATA) is also {
-       item direction 
-         using also 
+       item direction
+         using also
            ignore = (direction == WRITE);
     }; -- cover reg_acces...
- 
+
     cover reg_access (kind == XCORE_RX_MODE) is also {
-       item direction 
-         using also 
+       item direction
+         using also
            ignore = (direction == WRITE);
     }; -- cover reg_acces...
- 
+
 }; -- extend vr_ad_reg
 
 
 
 '>
-   
+
 
    Interactions
 
-   
+
    XCore receives HALT message right-before/during/right-after transmit
-   
+
 <'
 extend xcore_monitor_u {
      halt_frame_started : time;
@@ -241,27 +241,27 @@ extend xcore_monitor_u {
 
     event halt_after_tx_program is {
        -- Log time RX began
-       @rx_frame_started exec {halt_frame_started = sys.time}; 
+       @rx_frame_started exec {halt_frame_started = sys.time};
        [..];
        -- RX frame should be HALT message frame
-       @rx_frame_ended and 
-           true (cur_rx_frame.payload is a 
+       @rx_frame_ended and
+           true (cur_rx_frame.payload is a
                             MESSAGE xserial_frame_payload_s (MP) and
                  MP.frame_message == HALT);
-       
+
        [..];
-       
+
        -- Save delay from end of HALT frame to end of programming the XCor
-       @tx_frame_written 
-         exec {time_from_halt_to_program = sys.time - halt_frame_started}; 
-    }; 
-    
-    
+       @tx_frame_written
+         exec {time_from_halt_to_program = sys.time - halt_frame_started};
+    };
+
+
     when has_coverage xcore_monitor_u {
         cover halt_after_tx_program is {
-            item time_from_halt_to_program 
-              using 
-              text = 
+            item time_from_halt_to_program
+              using
+              text =
               "Time from sending HALT to XCore, to time programmed it to TX",
               ignore = time_from_halt_to_program == MAX_UINT,
               ranges = {
@@ -271,9 +271,9 @@ extend xcore_monitor_u {
             };
         };
     };
-   
+
  }; -- extend has_coverage xcore_monitor_u
- 
+
 '>
 
 
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xcore/e/xcore_env.e b/lesson000X_mluvm_svsc/uvm_examples/xcore/e/xcore_env.e
index b30375a..3fefa45 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xcore/e/xcore_env.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xcore/e/xcore_env.e
@@ -1,15 +1,15 @@
-/*------------------------------------------------------------------------- 
+/*-------------------------------------------------------------------------
 File name   : xcore_env.e
 Title       : XCore environment
 Project     : XCore eVC
 Created     : 2008
 Description : This file contains the top level unit of the eVC
-Notes       : 
---------------------------------------------------------------------------- 
+Notes       :
+---------------------------------------------------------------------------
 Copyright (c) 2008-2010 Cadence Design Systems,Inc.
   All rights reserved worldwide.
 
--------------------------------------------------------------------------*/ 
+-------------------------------------------------------------------------*/
 
 <'
 
@@ -27,7 +27,7 @@ unit xcore_env_u like uvm_env {
     keep soft tf_domain == XCORE_TF;
     event tf_phase_clock is only @xbus_evc.synch.clock_rise;
 
-    -- This field provides a screen logger for each eVC instance. 
+    -- This field provides a screen logger for each eVC instance.
     -- By default the verbosity is NONE, ie - disabled.
     logger : message_logger is instance;
 
@@ -45,17 +45,17 @@ unit xcore_env_u like uvm_env {
     -- This field specifies whether to collect coverage
     has_coverage : bool;
         keep soft has_coverage == TRUE;
-        
-    -- Pointers to the interface eVCs. These eVCs are to be instantiated in 
+
+    -- Pointers to the interface eVCs. These eVCs are to be instantiated in
     -- the SVE, the simulation & verification environment.
     -- The external eVCs are instantiated in the SVE and not in the eVC.
-   
+
     -- The XBus eVC to which this XCore is connected
     !xbus_evc           : xbus_env_u;
-       
+
     -- The XSerial eVC to which this XCore is connected
     !xserial_evc        : xserial_env_u;
-   
+
     -- The XBus agent representing the XCore
     !xbus_agent : PASSIVE SLAVE xbus_agent_u;
 
@@ -66,7 +66,7 @@ unit xcore_env_u like uvm_env {
         keep monitor.name == read_only(name);
         keep monitor.has_checks == read_only(has_checks);
         keep monitor.has_coverage == read_only(has_coverage);
-     
+
     -- Shadow registers
     reg_file : XCORE vr_ad_reg_file;
        keep soft reg_file.size == 0x100;
@@ -75,40 +75,40 @@ unit xcore_env_u like uvm_env {
     bus_to_serial_scbd : xserial_to_xserial_scbd is instance;
     serial_to_bus_scbd : xserial_to_xserial_scbd is instance;
 
-    
+
     connect_ports() is also {
-        -- Using the UVM Scoreboard 
+        -- Using the UVM Scoreboard
         // eVC xserial agent sending to device
         monitor.xserial_rx_frame_ended_o.connect(serial_to_bus_scbd.add_p);
-        
+
         // device sending to xesrial agent
         monitor.xserial_tx_frame_ended_o.connect(bus_to_serial_scbd.match_p);
-    
+
         do_bind(monitor.tx_frame_written_o, bus_to_serial_scbd.add_p);
         do_bind(monitor.rx_frame_read_o, serial_to_bus_scbd.match_p);
-        
+
         bus_to_serial_scbd.name = append("bus_to_serial_scbd");
         serial_to_bus_scbd.name = append("serial_to_bus_scbd");
     };
 
     -- This port must be bound to the reset signal of the XCore module.
-    sig_reset :  in simple_port of bit is instance;   
+    sig_reset :  in simple_port of bit is instance;
 
     -- This event is emitted at the deassertion of the first reset
-    event reset_deassert is cycle @monitor.reset_deassert;    
+    event reset_deassert is cycle @monitor.reset_deassert;
 
     -- Updating memory map:
 
     -- This event emitted on reset_deassert -
-    -- after reset XCore base_address has a valid value, hence 
+    -- after reset XCore base_address has a valid value, hence
     -- the memory map can be updated accordingly
-    -- Upon this event, the upper layer, which holds the memory map, 
+    -- Upon this event, the upper layer, which holds the memory map,
     -- should update it
     event update_memory_map;
 
     wait_for_first_reset : bool;
        keep wait_for_first_reset == TRUE;
-    
+
     on reset_deassert {
         reg_file.reset();
         if wait_for_first_reset then {
@@ -117,14 +117,14 @@ unit xcore_env_u like uvm_env {
         };
     };
 
-    
+
     -- Connect to interface eVCs
-    
+
     connect_pointers() is also {
         monitor.reg_file = reg_file;
         reg_file.as_a(XCORE vr_ad_reg_file).monitor =  monitor;
 
-        monitor.xbus_agent_monitor = xbus_agent.agent_monitor;  
+        monitor.xbus_agent_monitor = xbus_agent.agent_monitor;
         monitor.xserial_rx_monitor = xserial_evc.agent.
                                 as_a(has_rx_path xserial_agent_u).rx_monitor;
         monitor.xserial_tx_monitor = xserial_evc.agent.
@@ -132,7 +132,7 @@ unit xcore_env_u like uvm_env {
 
     }; -- connect_pointers
 
-        
+
     -- The short_name() method should return the name of this eVC instance.
     short_name(): string is {
         result = append(name);
@@ -148,12 +148,12 @@ unit xcore_env_u like uvm_env {
         out("(c) Cadence 2004-2006");
         out("XCore eVC instance: ", name);
     }; -- show_banner()
-    
+
     -- Implement the show_status() method
     show_status() is only {
         out("XCore eVC instance: ", name);
     }; -- show_status()
-  
+
 
 }; -- unit xcore_env_u
 
@@ -163,7 +163,7 @@ unit xcore_env_u like uvm_env {
 <'
 extend xcore_monitor_u {
 
-    -- This field allows the monitor to be sub-typed on the name 
+    -- This field allows the monitor to be sub-typed on the name
     -- of the XCore eVC
     name : xcore_env_name_t;
 }; -- extend xcore_monitor_u
@@ -176,7 +176,7 @@ extend xcore_monitor_u {
 // CONFIGURATION:
 // --------------
 
-// the macro defines xcore_env_config_u and xcore_env_config_params_s, 
+// the macro defines xcore_env_config_u and xcore_env_config_params_s,
 // and instantiates them in xbus_env_u.
 uvm_build_config env xcore_env_u xcore_env_config_u xcore_env_config_params_s;
 
@@ -188,31 +188,31 @@ extend xcore_env_u {
                new_params : xcore_env_config_params_s) is {
 
         -- Propagate config info to sub-components.
-        -- Note how each field is not necessary mapped to a single value of 
+        -- Note how each field is not necessary mapped to a single value of
         -- the lower layer. NORMAL mode in XCore, for example, can cause either
         -- SLOW or NORMAL in the XSerial.
         if new_params.mode == NORMAL then {
             if new_params.max_speed < 500 then {
-                uvm_configure ctr xserial_evc  {mode} 
+                uvm_configure ctr xserial_evc  {mode}
                   {xserial_mode_t'SLOW};
-                
+
             } else {
-                uvm_configure ctr xserial_evc  {mode} 
+                uvm_configure ctr xserial_evc  {mode}
                   {xserial_mode_t'NORMAL};
             };
         } else {
-            uvm_configure ctr xserial_evc  {mode} 
+            uvm_configure ctr xserial_evc  {mode}
               {xserial_mode_t'FAST};
         };
 
-        // update 
-        config.params = new_params.copy();        
+        // update
+        config.params = new_params.copy();
     }; -- configure
 
-}; -- extend xcore_env_u 
+}; -- extend xcore_env_u
 
 
-// This unit and its fields are only for the sake of demonstrating the 
+// This unit and its fields are only for the sake of demonstrating the
 // configuration and reconfiguration process. They have no effect on the test.
 extend xcore_env_config_params_s {
     mode      : xcore_mode_t;
@@ -223,26 +223,26 @@ extend xcore_env_config_params_s {
 
 
    Objection to TEST_DONE:
-   
-   After all sequences drop their objection to TEST_DONE, there is a need 
-   to allow the test to continue for some amount of time, to give the XCore 
-   time to respond to the last sequence. 
-   
-   The postpone_end_of_test() has to be called from the top most unit, the 
+
+   After all sequences drop their objection to TEST_DONE, there is a need
+   to allow the test to continue for some amount of time, to give the XCore
+   time to respond to the last sequence.
+
+   The postpone_end_of_test() has to be called from the top most unit, the
    unit holding all drivers under it.
-   
+
 <'
 extend xcore_env_u {
-   
+
     -- The XCore uses the XBus clock for general purposes
     event xbus_clock is @xbus_evc.synch.clock_rise;
-   
+
     drain_time : uint;
         keep soft drain_time == 200;
 
     in_drain_time : bool;
         keep in_drain_time == FALSE;
-     
+
     postpone_end_of_test() @xbus_clock is {
        if not in_drain_time {
           in_drain_time = TRUE;
@@ -250,8 +250,8 @@ extend xcore_env_u {
           wait [drain_time] * cycle;
           drop_objection(TEST_DONE);
        }; -- if not in_drain_time
-       
+
     }; -- postpone_end_of_test
-   
+
  }; -- extend xcore_env_u
 '>
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xcore/e/xcore_monitor.e b/lesson000X_mluvm_svsc/uvm_examples/xcore/e/xcore_monitor.e
index e5f73da..2bcba90 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xcore/e/xcore_monitor.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xcore/e/xcore_monitor.e
@@ -1,21 +1,21 @@
-/*------------------------------------------------------------------------- 
+/*-------------------------------------------------------------------------
 File name   : xcore_monitor.e
 Title       : Monitor for XCore eVC
 Project     : XCore eVC
 Created     : 2008
 Description : This file sets up the monitor infrastructure for the eVC
-Notes       : 
---------------------------------------------------------------------------- 
+Notes       :
+---------------------------------------------------------------------------
 Copyright (c) 2008-2010 Cadence Design Systems,Inc.
   All rights reserved worldwide.
 
--------------------------------------------------------------------------*/ 
+-------------------------------------------------------------------------*/
 
 <'
 
 package cdn_xcore;
 
-unit xcore_monitor_u like uvm_monitor {    
+unit xcore_monitor_u like uvm_monitor {
     -- This field specifies whether to perform data and protocol checks
     has_checks : bool;
 
@@ -26,14 +26,14 @@ unit xcore_monitor_u like uvm_monitor {
     !xserial_rx_monitor  : xserial_monitor_u;
     !xserial_tx_monitor  : xserial_monitor_u;
 
-   
+
     -- Shadow registers
     !reg_file : XCORE vr_ad_reg_file;
-    
+
     -- Info from the XSerial monitor:
     !cur_tx_frame : MONITOR xserial_frame_s;
     !cur_rx_frame : MONITOR xserial_frame_s;
-   
+
     -- This event is emited when an RX frame (sent to DUT) is seen on line
     event rx_frame_started;
 
@@ -50,38 +50,38 @@ unit xcore_monitor_u like uvm_monitor {
     -- Start of frames
     xserial_tx_frame_started_ei : in event_port is instance;
     xserial_rx_frame_started_ei : in event_port is instance;
-    
+
 
     connect_ports() is also {
-        do_bind(xserial_tx_frame_started_ei, 
+        do_bind(xserial_tx_frame_started_ei,
                 xserial_rx_monitor.frame_started_eo);
-        do_bind(xserial_rx_frame_started_ei, 
+        do_bind(xserial_rx_frame_started_ei,
                 xserial_tx_monitor.frame_started_eo);
     };
-    
+
     -- End of frames
     -- In ports - getting frames from i/f monitor
     xserial_tx_frame_ended_i : in interface_port of tlm_analysis of
-                                           MONITOR xserial_frame_s 
+                                           MONITOR xserial_frame_s
                                            using prefix=tx_ is instance;
     xserial_rx_frame_ended_i : in interface_port of tlm_analysis of
-                                           MONITOR xserial_frame_s 
+                                           MONITOR xserial_frame_s
                                            using prefix=rx_ is instance;
-    
+
     xserial_tx_frame_ended_o : out interface_port of tlm_analysis of
                                            MONITOR xserial_frame_s is instance;
     xserial_rx_frame_ended_o : out interface_port of tlm_analysis of
                                            MONITOR xserial_frame_s is instance;
-    
+
     -- Out ports - passing frames to upper level/s
     -- These are xserial-frames written to the device (for it to transmit),
-    -- and xserial-frames read from the device, after it received them from the 
+    -- and xserial-frames read from the device, after it received them from the
     -- eVC agent
     tx_frame_written_o : out interface_port of tlm_analysis of
                                            MONITOR xserial_frame_s is instance;
     rx_frame_read_o    : out interface_port of tlm_analysis of
                                            MONITOR xserial_frame_s is instance;
-    
+
     -- By default - bind to empty. To be bound later
     keep bind(tx_frame_written_o, empty);
     keep bind(rx_frame_read_o, empty);
@@ -97,7 +97,7 @@ unit xcore_monitor_u like uvm_monitor {
         xserial_rx_frame_ended_o$.write(frame);
         emit rx_frame_ended;
     };
-  
+
     connect_ports() is also {
         xserial_rx_monitor.frame_ended_o.connect(
                 xserial_tx_frame_ended_i);
@@ -105,16 +105,16 @@ unit xcore_monitor_u like uvm_monitor {
                 xserial_rx_frame_ended_i);
     };
 
-    
+
     -- Info from the XBus monitor:
-   
+
     !cur_xbus_transfer : MONITOR xbus_trans_s;
 
     -- An in TLM port for getting XBus transfers
     xbus_transfer_ended : in  interface_port of tlm_analysis of
-                                          MONITOR xbus_trans_s 
+                                          MONITOR xbus_trans_s
                                           using prefix=xbus_ is instance;
-    
+
     // Implement the in port
     xbus_write(transfer : MONITOR xbus_trans_s ) is {
         cur_xbus_transfer = transfer;
@@ -124,44 +124,44 @@ unit xcore_monitor_u like uvm_monitor {
         do_bind(xbus_transfer_ended,
                 xbus_agent_monitor.transfer_ended_o);
     };
-    
+
 
     event reset_deassert;
 
     -- This is sampled from the base_addr signal (as specified in the
-    -- sig_base_addr field in the env) at the deassertion of reset and 
-    -- gives the XBus base address the XCore module is configured to 
+    -- sig_base_addr field in the env) at the deassertion of reset and
+    -- gives the XBus base address the XCore module is configured to
     -- respond to.
     !base_address : uint(bits:16);
 
-    -- This port must be bound to the base_addr signal of the XCore module. 
+    -- This port must be bound to the base_addr signal of the XCore module.
     -- The eVC samples this signal at the de-assertion of reset to determine
     -- what addresses the XCore module will respond to.
     sig_base_addr :  in simple_port of bit is instance;
 
     -- This port must be bound to the reset signal of the XCore module.
-    sig_reset : in simple_port of bit is instance;   
+    sig_reset : in simple_port of bit is instance;
 
     -- This port must be bound to the flow signal of the XCore module.
-    sig_flow : in simple_port of bit is instance;   
+    sig_flow : in simple_port of bit is instance;
 
     -- This port must be bound to the halt_int signalof the XCore module.
-    sig_halt_int : in simple_port of bit is instance;    
+    sig_halt_int : in simple_port of bit is instance;
+
 
-   
     -- This port must be bound to the item_count signal of the XCore module.
-    sig_item_count : in simple_port of bit is instance;     
+    sig_item_count : in simple_port of bit is instance;
 
 };
 
 extend xcore_monitor_u {
-    
+
 
     -- This event is emitted at the deassertion of reset.
     event reset_deassert is only fall(sig_reset$) @sim;
-   
 
-    -- As reset is deasserted, sample the base_address from the HDL.    
+
+    -- As reset is deasserted, sample the base_address from the HDL.
     on reset_deassert {
         base_address = (sig_base_addr$).as_a(uint(bits:16)) * 0x100;
     };
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xcore/e/xcore_port_config.e b/lesson000X_mluvm_svsc/uvm_examples/xcore/e/xcore_port_config.e
index ad6f682..9501755 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xcore/e/xcore_port_config.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xcore/e/xcore_port_config.e
@@ -1,24 +1,24 @@
-/*------------------------------------------------------------------------- 
+/*-------------------------------------------------------------------------
 File name   : xcore_port_config.e
-Title       : Deault binding of ports. Used in RTL abstraction level 
+Title       : Deault binding of ports. Used in RTL abstraction level
 Project     : XCore eVC
-Developers  : 
+Developers  :
 Created     : 2008
 Description : This file binds the signal ports to external
-Notes       : 
---------------------------------------------------------------------------- 
+Notes       :
+---------------------------------------------------------------------------
 Copyright (c) 2008-2010 Cadence Design Systems,Inc.
   All rights reserved worldwide.
 
--------------------------------------------------------------------------*/ 
+-------------------------------------------------------------------------*/
+
 
-  
 <'
 package cdn_xcore;
 
 extend xcore_env_u  {
     keep bind(sig_reset, external);
-    keep soft sig_reset.hdl_path()            == "xbus_reset"; 
+    keep soft sig_reset.hdl_path()            == "xbus_reset";
 };
 
 extend xcore_monitor_u {
@@ -28,12 +28,12 @@ extend xcore_monitor_u {
     keep bind(sig_halt_int, external);
     keep bind(sig_item_count, external);
 
-    keep soft sig_reset.hdl_path()            == "xbus_reset"; 
-    keep soft sig_base_addr.hdl_path()  == "base_addr";  
-    keep soft sig_flow.hdl_path()       == "flow"; 
-    keep soft sig_halt_int.hdl_path()   == "in_chan_inst/flow_halt_int";  
-    keep soft sig_item_count.hdl_path() == "in_chan_inst/item_count";  
-}; 
+    keep soft sig_reset.hdl_path()            == "xbus_reset";
+    keep soft sig_base_addr.hdl_path()  == "base_addr";
+    keep soft sig_flow.hdl_path()       == "flow";
+    keep soft sig_halt_int.hdl_path()   == "in_chan_inst/flow_halt_int";
+    keep soft sig_item_count.hdl_path() == "in_chan_inst/item_count";
+};
 '>
 
 Configuration of xbus ports:
@@ -45,15 +45,15 @@ extend xbus_synchronizer_u {
 };
 
 extend xbus_signal_map_u {
-    keep soft sig_start.hdl_path() == "xbus_start"; 
-    keep soft sig_addr.hdl_path()  == "xbus_addr"; 
-    keep soft sig_size.hdl_path()  == "xbus_size"; 
+    keep soft sig_start.hdl_path() == "xbus_start";
+    keep soft sig_addr.hdl_path()  == "xbus_addr";
+    keep soft sig_size.hdl_path()  == "xbus_size";
     keep soft sig_read.hdl_path()  == "xbus_read";
-    keep soft sig_write.hdl_path() == "xbus_write"; 
-    keep soft sig_bip.hdl_path()   == "xbus_bip"; 
-    keep soft sig_wait.hdl_path()  == "xbus_wait"; 
-    keep soft sig_error.hdl_path() == "xbus_error"; 
-    keep soft sig_data.hdl_path()  == "xbus_data"; 
+    keep soft sig_write.hdl_path() == "xbus_write";
+    keep soft sig_bip.hdl_path()   == "xbus_bip";
+    keep soft sig_wait.hdl_path()  == "xbus_wait";
+    keep soft sig_error.hdl_path() == "xbus_error";
+    keep soft sig_data.hdl_path()  == "xbus_data";
 };
 
 extend xbus_master_signal_map_u {
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xcore/e/xcore_ref_model.e b/lesson000X_mluvm_svsc/uvm_examples/xcore/e/xcore_ref_model.e
index 5c0bb0d..9002e9f 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xcore/e/xcore_ref_model.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xcore/e/xcore_ref_model.e
@@ -1,15 +1,15 @@
-/*------------------------------------------------------------------------- 
+/*-------------------------------------------------------------------------
 File name   : xcore_ref_model.e
 Title       : Reference model for XCore HDL
 Project     : XCore eVC
 Created     : 2008
 Description : This file implements a 'reference model' of the XCore HDL.
-Notes       : 
---------------------------------------------------------------------------- 
+Notes       :
+---------------------------------------------------------------------------
 Copyright (c) 2008-2010 Cadence Design Systems,Inc.
   All rights reserved worldwide.
 
--------------------------------------------------------------------------*/ 
+-------------------------------------------------------------------------*/
 
 <'
 
@@ -17,11 +17,11 @@ package cdn_xcore;
 
 define XCORE_RX_FIFO_DEPTH 2;
 
--- Reference model behaviour 
+-- Reference model behaviour
 extend xcore_monitor_u {
-   
+
     -- Fields updated during the run, keeping DUT current status
-   
+
     -- This field keeps track of whether it is safe to write to the TX_DATA
     -- register.
     !tx_write_safe : bool;
@@ -29,72 +29,72 @@ extend xcore_monitor_u {
     -- This field keeps track of whether it is safe to read from the RX_DATA
     -- register.
     !rx_read_safe : bool;
-    
-        
-    -- This field is used to build up the transmitted frame which is 
-    -- expected to be transmitted by the XCore as a result of a WRITE 
-    -- transaction. 
+
+
+    -- This field is used to build up the transmitted frame which is
+    -- expected to be transmitted by the XCore as a result of a WRITE
+    -- transaction.
     !tx_frame : MONITOR xserial_frame_s;
-    
+
     -- This field is used to build up the received frame which is read
     -- from the bus in a READ transaction
     !rx_frame : MONITOR xserial_frame_s;
-    
-    -- This field is used to monitor the number of items in the 
+
+    -- This field is used to monitor the number of items in the
     -- XCore RX fifo
     !items_in_rx_fifo: uint;
 
     -- This field is used to keep RX fifo overfow status
     overflow_state : bool;
-    
+
     -- Implementation of the in port, called by the XBus monitor
     xbus_write(transfer : MONITOR xbus_trans_s ) is also {
         if legal_access(transfer) {
-            update_reg_file(transfer); 
+            update_reg_file(transfer);
         };
     };
-    
-    
+
+
     -- These events are for post tranfer activities
     event tx_frame_written;
     event rx_frame_read;
 
-    
+
     -- On end of frame - pass info to upper level/s (including the scoreboard)
     on tx_frame_written {
-        tx_frame_written_o$.write(tx_frame);  
+        tx_frame_written_o$.write(tx_frame);
     };
     on rx_frame_read {
-        rx_frame_read_o$.write(rx_frame);  
+        rx_frame_read_o$.write(rx_frame);
     };
- 
+
     -- This method initialises the reference model (e.g. after reset).
     init_model() is {
         tx_write_safe = FALSE;
-        rx_read_safe = FALSE;    
+        rx_read_safe = FALSE;
         items_in_rx_fifo = 0;
         overflow_state = FALSE;
     }; -- init_model()
-    
+
     run() is also {
         init_model();
     }; -- run()
-    
-    -- This method takes an XBus transfer and returns TRUE if this 
+
+    -- This method takes an XBus transfer and returns TRUE if this
     -- transfer would result in this XCore producing a bus error.
     legal_access(t :  xbus_trans_s) : bool is {
         result = TRUE;
-        
+
         if (t.as_a(MONITOR xbus_trans_s).error_pos_mon != 0) {
-            result = FALSE;            
+            result = FALSE;
         };
         var offset : int = t.addr - base_address;
         if offset in [0..0xff] {
             if (t.size != 1) or
                (offset not in [0..3]) or
-               ((offset == 0) and (t.read_write == WRITE) and 
+               ((offset == 0) and (t.read_write == WRITE) and
                    (not tx_write_safe)) or
-               ((offset == 2) and (t.read_write == READ) and 
+               ((offset == 2) and (t.read_write == READ) and
                    (not rx_read_safe)) or
                ((offset in [2, 3]) and (t.read_write == WRITE)) {
                 result = FALSE;
@@ -102,19 +102,19 @@ extend xcore_monitor_u {
         };
     }; -- error_expected()
 
-   
+
 
     -- Update the register file after each XBus transfer
-    
+
     update_reg_file( transfer: MONITOR xbus_trans_s ) is {
           if transfer.read_write == WRITE then {
-              reg_file.update(transfer.addr - base_address, 
+              reg_file.update(transfer.addr - base_address,
                         %{transfer.data},{});
           } else {
             compute reg_file.compare_and_update(transfer.addr - base_address,
                                                 %{transfer.data});
         };
-    }; 
+    };
 
 }; -- extend xcore_monitor_u
 
@@ -123,10 +123,10 @@ extend xcore_monitor_u {
 
 Create frames from registers accesses.
 
-Writing TX frame, to Xcore TX fifo - 
-      READ TX_DATA_REG until reading 0, 
+Writing TX frame, to Xcore TX fifo -
+      READ TX_DATA_REG until reading 0,
       WRITE to TX_DATA_REG the data to transmit
-Reading RX frame from Xcore RX fifo   
+Reading RX frame from Xcore RX fifo
 
 
 <'
@@ -147,7 +147,7 @@ extend XCORE_TX_MODE vr_ad_reg {
     post_access(d : vr_ad_rw_t) is {
         var monitor := static_info.access_path.as_a(XCORE vr_ad_reg_file).monitor;
         if d == WRITE {
-            -- Start building the frame which is expected to be transmited 
+            -- Start building the frame which is expected to be transmited
             -- as a result of this register access
             monitor.tx_frame = new with {
                 .start_bit = 0;
@@ -164,18 +164,18 @@ extend XCORE_TX_MODE vr_ad_reg {
             } else {
                 monitor.tx_frame.payload.frame_format = UNDEFINED;
             };
-            msg_started(MEDIUM, 
+            msg_started(MEDIUM,
                         "Building TX frame from regs accesses",
                         monitor.tx_frame);
         };
-        
+
     };
 };
 
 extend XCORE_TX_DATA vr_ad_reg {
     post_access(d : vr_ad_rw_t) is {
         var monitor := static_info.access_path.as_a(XCORE vr_ad_reg_file).monitor;
-    
+
         if d == READ {
             if (data & 0b00000001) == 0 {
                 monitor.tx_write_safe = TRUE;
@@ -183,22 +183,22 @@ extend XCORE_TX_DATA vr_ad_reg {
         } else {
             monitor.tx_write_safe = FALSE;
             monitor.tx_frame.parity = monitor.tx_frame.calc_parity();
-           
+
             if monitor.tx_frame.payload is a DATA
               xserial_frame_payload_s (d_p) {
                 d_p.data = data;
             };
-            
-            if monitor.tx_frame.payload is a MESSAGE 
+
+            if monitor.tx_frame.payload is a MESSAGE
               xserial_frame_payload_s (d_m) {
                 if d_m.frame_message in [HALT, RESUME] {
                     d_m.frame_message = IDLE;
                 };
             };
-            msg_ended(MEDIUM, 
+            msg_ended(MEDIUM,
                       "Building TX frame from regs accesses",
                       monitor.tx_frame);
-            
+
             emit monitor.tx_frame_written;
         };
     };
@@ -211,7 +211,7 @@ extend XCORE_RX_MODE vr_ad_reg {
         var monitor := static_info.access_path.as_a(XCORE vr_ad_reg_file).monitor;
         if valid_frame == 1 {
             monitor.rx_read_safe = TRUE;
-            -- Start building the frame which is expected to be transmited 
+            -- Start building the frame which is expected to be transmited
             -- as a result of this register access
             monitor.rx_frame = new with {
                 .bad_parity = par_err;
@@ -222,13 +222,13 @@ extend XCORE_RX_MODE vr_ad_reg {
                 .destination = dest;
                 .physical_frame_format = frame_kind;
             };
-           
+
             if frame_kind in all_values(xserial_frame_format_t).apply(it.as_a(uint)) {
                 monitor.rx_frame.payload.frame_format = frame_kind.as_a(xserial_frame_format_t);
             } else {
                 monitor.rx_frame.payload.frame_format = UNDEFINED;
             };
-            msg_started(MEDIUM, 
+            msg_started(MEDIUM,
                         "Building RX frame from regs accesses",
                         monitor.rx_frame);
         };
@@ -238,20 +238,20 @@ extend XCORE_RX_MODE vr_ad_reg {
 extend XCORE_RX_DATA vr_ad_reg {
     post_access(d : vr_ad_rw_t) is {
         var monitor := static_info.access_path.as_a(XCORE vr_ad_reg_file).monitor;
-      
+
         monitor.rx_read_safe = FALSE;
-         
+
         if monitor.rx_frame.payload is a DATA
           xserial_frame_payload_s (d_p) {
             d_p.data = data;
         };
-        
+
         monitor.rx_frame.parity =  monitor.rx_frame.calc_parity();
         if monitor.rx_frame.bad_parity then {
             monitor.rx_frame.status.add(BAD_PARITY);
         };
-        
-        msg_ended(MEDIUM, 
+
+        msg_ended(MEDIUM,
                   "Building RX frame from regs accesses",
                   monitor.rx_frame);
         emit monitor.rx_frame_read;
@@ -261,13 +261,13 @@ extend XCORE_RX_DATA vr_ad_reg {
 
 
    Flow Control mechanism
-   
-   
+
+
 <'
-extend xcore_monitor_u { 
-    
+extend xcore_monitor_u {
+
     event fifo_event;
-    
+
     -- This event is emited when XCore indicates RX fifo overflow
     event overflow;
 
@@ -292,19 +292,19 @@ extend xcore_monitor_u {
         if (items_in_rx_fifo < XCORE_RX_FIFO_DEPTH) then {
             overflow_state = FALSE;
         };
-    }; 
-    
+    };
+
     on rx_frame_ended {
        if cur_rx_frame.payload is a DATA xserial_frame_payload_s  then {
           items_in_rx_fifo += 1;
-       }; 
+       };
        if items_in_rx_fifo == 2 then {
            emit ref_model_fifo_full;
            overflow_state = TRUE;
        }; -- if items_in_rx_...
     }; -- on rx_frame_end...
-    
-    on tx_frame_ended { 
+
+    on tx_frame_ended {
        if cur_tx_frame.payload is a MESSAGE xserial_frame_payload_s (MP) {
           if MP.frame_message == HALT then {
              emit xcore_sent_halt;
@@ -315,7 +315,7 @@ extend xcore_monitor_u {
        }; -- if cur_tx_frame...
     }; -- on tx_frame_end...
 
-    on rx_frame_ended { 
+    on rx_frame_ended {
        if cur_rx_frame.payload is a MESSAGE xserial_frame_payload_s (MP) {
           if MP.frame_message == HALT then {
              emit xcore_got_halt;
@@ -333,14 +333,14 @@ extend xcore_monitor_u {
        [1..120] * cycle;
        @xcore_sent_halt;
     }; -- event fifo_over...
-    
-}; 
+
+};
 
 
-extend xcore_monitor_u { 
-    
+extend xcore_monitor_u {
+
     event fifo_event is only rise(sig_flow$) @sim;
-    
+
     -- This event is emited when XCore indicates RX fifo overflow
     event overflow is only rise(sig_halt_int$) @fifo_event;
 };
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xcore/e/xcore_registers.e b/lesson000X_mluvm_svsc/uvm_examples/xcore/e/xcore_registers.e
index 7e4be3b..1916c78 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xcore/e/xcore_registers.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xcore/e/xcore_registers.e
@@ -1,15 +1,15 @@
-/*------------------------------------------------------------------------- 
+/*-------------------------------------------------------------------------
 File name   : xcore_registers.e
 Title       : Registers of the XCore
 Project     : XCore eVC
 Created     : 2008
 Description : This file defines the XCore registers
-Notes       : 
---------------------------------------------------------------------------- 
+Notes       :
+---------------------------------------------------------------------------
 Copyright (c) 2008-2010 Cadence Design Systems,Inc.
   All rights reserved worldwide.
 
--------------------------------------------------------------------------*/ 
+-------------------------------------------------------------------------*/
 
 <'
 
@@ -23,9 +23,9 @@ extend vr_ad_reg_file_kind : [XCORE];
 
 -- DUT Shadow Register definitions
 --
---       NAME              REGFILE   ADDR 
---       -------           -------   ---- 
-reg_def  XCORE_TX_DATA  XCORE  8'h00 { 
+--       NAME              REGFILE   ADDR
+--       -------           -------   ----
+reg_def  XCORE_TX_DATA  XCORE  8'h00 {
    -- Custom Fields
    reg_fld data       : uint(bits:8) : RW : 0 : cov;
 
@@ -35,7 +35,7 @@ reg_def  XCORE_TX_DATA  XCORE  8'h00 {
     };
 };
 
-reg_def    XCORE_TX_MODE  XCORE  8'h01 { 
+reg_def    XCORE_TX_MODE  XCORE  8'h01 {
    -- Custom Fields
     reg_fld resv       : uint(bits:4) : RW : 0 ;
     reg_fld frame_kind : uint(bits:2) : RW : 0 ;
@@ -47,7 +47,7 @@ reg_def    XCORE_TX_MODE  XCORE  8'h01 {
     };
 };
 
-reg_def    XCORE_RX_DATA  XCORE  8'h02 { 
+reg_def    XCORE_RX_DATA  XCORE  8'h02 {
    -- Custom Fields
    reg_fld data        : uint(bits:8) : RW : 0 : cov;
 
@@ -57,7 +57,7 @@ reg_def    XCORE_RX_DATA  XCORE  8'h02 {
     };
 };
 
-reg_def    XCORE_RX_MODE  XCORE  8'h03 { 
+reg_def    XCORE_RX_MODE  XCORE  8'h03 {
    -- Custom Fields
     reg_fld resv       : uint(bits:2) : RW : 0 ;
     reg_fld valid_frame: uint(bits:1) : RW : 0 : cov;
@@ -86,7 +86,7 @@ extend xbus_master_driver_u {
                 };
             };
             if op_item.direction == WRITE {
-                sequence.write(reg_op.reg.get_size(),reg_op.address, 
+                sequence.write(reg_op.reg.get_size(),reg_op.address,
                     reg_op.reg.read_reg_val());
             } else {
                 result = pack(packing.low,sequence.read(reg_op.reg.get_size(),
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xcore/e/xcore_registers_basic_seq_lib.e b/lesson000X_mluvm_svsc/uvm_examples/xcore/e/xcore_registers_basic_seq_lib.e
index 171036a..8547f63 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xcore/e/xcore_registers_basic_seq_lib.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xcore/e/xcore_registers_basic_seq_lib.e
@@ -1,15 +1,15 @@
-/*------------------------------------------------------------------------- 
+/*-------------------------------------------------------------------------
 File name   : xcore_registers_basic_seq_lib.e
 Title       : Registers sequence lib
 Project     : XCore eVC
 Created     : 2008
 Description : Defines sequences for programming the XCore via its registers
-Notes       : 
---------------------------------------------------------------------------- 
+Notes       :
+---------------------------------------------------------------------------
 Copyright (c) 2008-2010 Cadence Design Systems,Inc.
   All rights reserved worldwide.
 
--------------------------------------------------------------------------*/ 
+-------------------------------------------------------------------------*/
 
 <'
 
@@ -27,28 +27,28 @@ extend vr_ad_sequence_kind : [XCORE_XBUS_WRITE,
 
 extend vr_ad_sequence_driver {
     event device_reset_done;
-}; 
+};
 
 extend vr_ad_sequence {
-    // Cover the sequence. 
-    // Ignore the pre-defined kinds, they do not add information to 
+    // Cover the sequence.
+    // Ignore the pre-defined kinds, they do not add information to
     // the coverage
     cover ended is {
         item kind using ignore = (kind == RANDOM or
                                   kind == SIMPLE or
                                   kind == MAIN);
-    }; 
+    };
 
 };
 
 extend MAIN vr_ad_sequence {
-  
+
    -- If this field is TRUE, then an objection to TEST_DONE
    -- is raised for the duration of the MAIN sequence. If this field is FALSE
    -- then the MAIN sequence does not contribute to the determination of
    -- end-of-test.
    keep soft prevent_test_done == FALSE;
-   
+
    -- Raise an objection to TEST_DONE whenever a MAIN sequence is started.
    pre_body() @sys.any is first {
        // The vr_ad does not participate in the testflow, in this eVC,
@@ -61,7 +61,7 @@ extend MAIN vr_ad_sequence {
          driver.raise_objection(TEST_DONE);
       };
    }; -- pre_body()
-         
+
    -- Drop the objection to TEST_DONE after the MAIN sequence ends.
    post_body() @sys.any is also {
       message(LOW, "MAIN sequence finished");
@@ -69,16 +69,16 @@ extend MAIN vr_ad_sequence {
          driver.drop_objection(TEST_DONE);
       };
    }; -- post_body()
-   
+
 }; -- extend MAIN ...
 
 
--- The XCORE_XBUS_WRITE sequence writes a frame to the XCore. 
+-- The XCORE_XBUS_WRITE sequence writes a frame to the XCore.
 -- It polls the XCore to ensure that it is ready before writing the
 -- frame data.
-  
+
 extend XCORE_XBUS_WRITE vr_ad_sequence {
-     
+
    -- By defualt - take the first reg_file
    keep soft static_item == driver.addr_map.reg_file_list[0];
 
@@ -86,18 +86,18 @@ extend XCORE_XBUS_WRITE vr_ad_sequence {
     -- This field specifies the frame format of the frame to be written.
     frame_format : xserial_frame_format_t;
         keep soft frame_format == DATA;
-    
+
     -- This field controls the physical representation of the frame_format
     -- field.
     private frame_format_physical : uint(bits:2);
         keep frame_format_physical == read_only(frame_format).as_a(uint);
-    
+
     -- This field controls the destination of the frame to be written.
     destination : uint(bits:2);
-    
+
     -- This field contains the payload of the frame to be written.
     data : byte;
-   
+
    !tx_data : XCORE_TX_DATA vr_ad_reg;
    !tx_mode : XCORE_TX_MODE vr_ad_reg ;
 
@@ -107,13 +107,13 @@ extend XCORE_XBUS_WRITE vr_ad_sequence {
 
             read_reg tx_data;
         } until pack(packing.low, tx_data) == 0;
-      
+
       write_reg tx_mode {.dest == destination;
                          .frame_kind == frame_format_physical;
                          .resv == 0};
 
       write_reg tx_data {.data == data};
-      
+
     }; -- body()
 
 }; -- extend XCORE_XBUS_WRITE vr_ad_sequence
@@ -127,10 +127,10 @@ extend XCORE_XBUS_READ vr_ad_sequence {
 
     -- This field is used to store the payload of the received frame.
     !data : byte;
-    
+
     -- This field is used to store the frame format of the received frame.
     !frame_format : xserial_frame_format_t;
-    
+
     -- This field is used to store the destination of the received frame.
     !destination : uint(bits:2);
 
@@ -143,7 +143,7 @@ extend XCORE_XBUS_READ vr_ad_sequence {
    !rx_data : XCORE_RX_DATA vr_ad_reg;
    !rx_mode : XCORE_RX_MODE vr_ad_reg ;
 
-   body() @driver.clock is only {      
+   body() @driver.clock is only {
 
       repeat {
          read_reg rx_mode;
@@ -157,7 +157,7 @@ extend XCORE_XBUS_READ vr_ad_sequence {
 
    };
 
-}; -- extend XCORE_XBUS_READ vr_ad_sequence 
+}; -- extend XCORE_XBUS_READ vr_ad_sequence
 
 
 
@@ -169,25 +169,25 @@ extend XCORE_XBUS_READ_WRITE vr_ad_sequence {
 
     -- This field specifies the base address of the XCore device the frame is
     -- read from.
-    
+
     -- This field specifies the base address of the XCore device the frame is
     -- written to.
 
    -- This field is provide to facilitate "do xcore_read".
    !xcore_read : XCORE_XBUS_READ vr_ad_sequence ;
-   
+
    -- This field is provide to facilitate "do xcore_write".
    !xcore_write : XCORE_XBUS_WRITE vr_ad_sequence;
-    
+
    read_reg_file : vr_ad_reg_file;
        keep soft read_reg_file  == driver.addr_map.reg_file_list[0];
    write_reg_file : vr_ad_reg_file;
        keep soft write_reg_file == driver.addr_map.reg_file_list[0];
 
-   
+
    body() @driver.clock is only {
-       
-       do xcore_read keeping { 
+
+       do xcore_read keeping {
           .static_item == read_reg_file ;
        }; -- body() @driver....
 
@@ -199,10 +199,10 @@ extend XCORE_XBUS_READ_WRITE vr_ad_sequence {
                .static_item  == write_reg_file;
             };
         };
-        
+
    }; -- body()
-    
-}; -- extend XCORE_XBUS_READ_WRITE vr_ad_sequence 
+
+}; -- extend XCORE_XBUS_READ_WRITE vr_ad_sequence
 
 '>
 
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xcore/e/xcore_top.e b/lesson000X_mluvm_svsc/uvm_examples/xcore/e/xcore_top.e
index 360b268..a0c82e5 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xcore/e/xcore_top.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xcore/e/xcore_top.e
@@ -1,15 +1,15 @@
-/*------------------------------------------------------------------------- 
+/*-------------------------------------------------------------------------
 File name   : xcore_top.e
 Title       : Top level of XCore eVC
 Project     : XCore eVC
 Created     : 2008
 Description : This file imports all files in the eVC
-Notes       : 
---------------------------------------------------------------------------- 
+Notes       :
+---------------------------------------------------------------------------
 Copyright (c) 2008-2010 Cadence Design Systems,Inc.All rights reserved worldwide.
 Please refer to the terms and conditions in $IPCM_HOME
 
--------------------------------------------------------------------------*/ 
+-------------------------------------------------------------------------*/
 
 <'
 
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xcore/e/xcore_xbus_config.e b/lesson000X_mluvm_svsc/uvm_examples/xcore/e/xcore_xbus_config.e
index 725a08c..4df4160 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xcore/e/xcore_xbus_config.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xcore/e/xcore_xbus_config.e
@@ -1,14 +1,14 @@
-/*------------------------------------------------------------------------- 
+/*-------------------------------------------------------------------------
 File name   : xcore_xbus_config.e
 Title       : XSerial eVC configuration
 Project     : Xcore eVC
 Created     : 2008
 Description : Configures XBus eVC for testing Xcore
-Notes       : 
---------------------------------------------------------------------------- 
+Notes       :
+---------------------------------------------------------------------------
 Copyright (c) 2008-2010 Cadence Design Systems,Inc.
   All rights reserved worldwide.
--------------------------------------------------------------------------*/ 
+-------------------------------------------------------------------------*/
 
 <'
 
@@ -16,18 +16,18 @@ package cdn_xcore;
 
 extend xbus_bus_name_t   : [XCORE_XBUS];
 extend xbus_agent_name_t : [XCORE_XBUS_AGENT];
-  
+
 '>
 
-   
-   
+
+
    Configurate the XBus eVC
-   
+
    Using soft constraints, so can be overwritten in the SVE
-   
+
 <'
 
-extend xbus_signal_map_u {    
+extend xbus_signal_map_u {
     keep sig_data.verilog_wire() == TRUE;
     keep sig_data.declared_range() == "[7:0]";
 };
@@ -44,31 +44,31 @@ extend xbus_env_u {
     keep soft passive_master_names == {};
     keep soft active_slave_names   == {};
     keep soft passive_slave_names  == {XCORE_XBUS_AGENT };
-    keep soft arbiter is a 
+    keep soft arbiter is a
               XCORE_XBUS_AGENT ACTIVE ARBITER xbus_agent_u;
-    
+
     keep soft has_checks == TRUE;
-    
+
     keep soft bus_monitor.log_filename == "XCORE_XBUS";
-    keep soft active_masters[0].agent_monitor.log_filename == 
+    keep soft active_masters[0].agent_monitor.log_filename ==
               "XCORE_XBUS_MASTER";
-    keep soft passive_slaves[0].agent_monitor.log_filename == 
+    keep soft passive_slaves[0].agent_monitor.log_filename ==
                                 "XCORE_XBUS_SLAVE";
 
- 
+
  }; --
 
 extend xcore_monitor_u {
-    -- As reset is deasserted, sample the base_address from the HDL.    
+    -- As reset is deasserted, sample the base_address from the HDL.
     on reset_deassert {
         base_address = (sig_base_addr$).as_a(uint(bits:16)) * 0x100;
-        
+
         var new_min_addr := base_address + 0x0000;
         var new_max_addr := base_address + 0x00ff;
         uvm_configure 1 get_enclosing_unit(xcore_env_u).xbus_evc
-              {slave_name;  min_addr; max_addr} 
+              {slave_name;  min_addr; max_addr}
           {xbus_agent_name_t'XCORE_XBUS_AGENT; new_min_addr; new_max_addr};
     };
 };
 '>
-   
+
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xcore/e/xcore_xbus_master_basic_seq_lib.e b/lesson000X_mluvm_svsc/uvm_examples/xcore/e/xcore_xbus_master_basic_seq_lib.e
index de59cb4..cef4b69 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xcore/e/xcore_xbus_master_basic_seq_lib.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xcore/e/xcore_xbus_master_basic_seq_lib.e
@@ -1,16 +1,16 @@
-/*------------------------------------------------------------------------- 
+/*-------------------------------------------------------------------------
 File name   : xcore_xbus_master_basic_seq_lib.e
 Title       : XBus sequence lib
 Project     : XCore eVC
 Created     : 2008
 Description : Defines XBus sequences for reading/writing to XCore
             : based on the seuqcnes define in the xbus eVC
-Notes       : 
---------------------------------------------------------------------------- 
+Notes       :
+---------------------------------------------------------------------------
 Copyright (c) 2008-2010 Cadence Design Systems,Inc.All rights reserved worldwide.
 Please refer to the terms and conditions in $IPCM_HOME
 
--------------------------------------------------------------------------*/ 
+-------------------------------------------------------------------------*/
 
 <'
 
@@ -19,9 +19,9 @@ package cdn_xcore;
 '>
 
 
-<'   
-extend xbus_master_sequence_kind : [XCORE_WRITE_FRAME, 
-                                       XCORE_READ_FRAME, 
+<'
+extend xbus_master_sequence_kind : [XCORE_WRITE_FRAME,
+                                       XCORE_READ_FRAME,
                                        XCORE_READ_WRITE_FRAME];
 
 
@@ -37,18 +37,18 @@ extend XCORE_WRITE_FRAME xbus_master_sequence {
     -- This field specifies the frame format of the frame to be written.
     frame_format : xserial_frame_format_t;
         keep soft frame_format == DATA;
-    
+
     -- This field controls the physical representation of the frame_format
     -- field.
     private frame_format_physical : uint(bits:2);
         keep frame_format_physical == read_only(frame_format).as_a(uint);
-    
+
     -- This field controls the destination of the frame to be written.
     destination : uint(bits:2);
-    
+
     -- This field contains the payload of the frame to be written.
     data : byte;
-    
+
     body() @driver.clock is only {
 
 
@@ -56,38 +56,38 @@ extend XCORE_WRITE_FRAME xbus_master_sequence {
        repeat {
            poll = read(1, base_addr+0);
         } until poll[0:0] == 0;
-       write(1, base_addr+1, pack(packing.low, destination, 
+       write(1, base_addr+1, pack(packing.low, destination,
                                    frame_format_physical));
        write(1, base_addr+0, data);
-       
+
     }; -- body()
-    
+
 }; -- extend XCORE_WRITE_FRAME xbus_master_sequence
 
 
--- The XCORE_READ_FRAME sequence reads a frame from an instance of the 
--- XCore. It will poll the XCore to ensure that there is valid data ready 
+-- The XCORE_READ_FRAME sequence reads a frame from an instance of the
+-- XCore. It will poll the XCore to ensure that there is valid data ready
 -- before reading the frame data.
 extend XCORE_READ_FRAME xbus_master_sequence {
 
     -- This field specifies the XCore base address
     base_addr : uint(bits:16);
         keep soft base_addr == 0;
-    
+
     -- This field is used to store the payload of the received frame.
     !data : byte;
-    
+
     -- This field is used to store the frame format of the received frame.
     !frame_format : xserial_frame_format_t;
-    
+
     -- This field is used to store the destination of the received frame.
     !destination : uint(bits:2);
-    
+
     -- This field is used to store the error flag of the received frame.
     !error_flag : bool;
-    
+
     body() @driver.clock is only {
-        
+
        var poll : byte; -- the result of polling the XCore
        repeat {
           poll = read(1, base_addr+3);
@@ -101,34 +101,34 @@ extend XCORE_READ_FRAME xbus_master_sequence {
        };
        error_flag = poll[4:4].as_a(bool);
        data = read(1, base_addr+2);
-       
+
     }; -- body()
-    
+
 }; -- extend XCORE_READ_FRAME xbus_master_sequence
 
 
--- The XCORE_READ_WRITE_FRAME sequence reads a frame from an instance 
--- of the XCore and writes it immediately back to an instance of the XCore. 
+-- The XCORE_READ_WRITE_FRAME sequence reads a frame from an instance
+-- of the XCore and writes it immediately back to an instance of the XCore.
 -- If a frame is received with an error, it is discarded.
 extend XCORE_READ_WRITE_FRAME xbus_master_sequence {
 
-    -- This field specifies the base address of the XCore device the frame 
+    -- This field specifies the base address of the XCore device the frame
     -- is read from.
     rx_base_addr : uint(bits:16);
         keep soft rx_base_addr == 0;
-    
-    -- This field specifies the base address of the XCore device the frame 
+
+    -- This field specifies the base address of the XCore device the frame
     -- is written to.
     tx_base_addr : uint(bits:16);
         keep soft tx_base_addr == 0;
-    
+
 
     -- This field is provide to facilitate "do xcore_read".
     !xcore_read : XCORE_READ_FRAME xbus_master_sequence;
-    
+
     -- This field is provide to facilitate "do xcore_write".
     !xcore_write : XCORE_WRITE_FRAME xbus_master_sequence;
-    
+
     body() @driver.clock is only {
 
         do xcore_read keeping { .base_addr == rx_base_addr };
@@ -140,9 +140,9 @@ extend XCORE_READ_WRITE_FRAME xbus_master_sequence {
                 .data         == xcore_read.data;
             };
         };
-        
+
     }; -- body()
-    
+
 }; -- extend XCORE_READ_WRITE_FRAME xbus_master_sequence
 
 
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xcore/e/xcore_xserial_basic_seq_lib.e b/lesson000X_mluvm_svsc/uvm_examples/xcore/e/xcore_xserial_basic_seq_lib.e
index 2111515..4480e24 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xcore/e/xcore_xserial_basic_seq_lib.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xcore/e/xcore_xserial_basic_seq_lib.e
@@ -1,16 +1,16 @@
-/*------------------------------------------------------------------------- 
-File name   : xcore_xserial_basic_seq_lib.e 
+/*-------------------------------------------------------------------------
+File name   : xcore_xserial_basic_seq_lib.e
 Title       : XSerial sequence lib
 Project     : XCore eVC
 Created     : 2008
 Description : Defines XSerial sequences for sending to XCore
             : based on the seuqcnes define in the xserial eVC
-Notes       : 
---------------------------------------------------------------------------- 
+Notes       :
+---------------------------------------------------------------------------
 Copyright (c) 2008-2010 Cadence Design Systems,Inc.All rights reserved worldwide.
 Please refer to the terms and conditions in $IPCM_HOME
 
--------------------------------------------------------------------------*/ 
+-------------------------------------------------------------------------*/
 
 <'
 
@@ -32,6 +32,6 @@ extend XCORE_SEND_FRAME xserial_sequence {
 }; -- extend XCORE...
 
 '>
-   
+
 
 
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xcore/e/xcore_xserial_config.e b/lesson000X_mluvm_svsc/uvm_examples/xcore/e/xcore_xserial_config.e
index b5664ca..6b2b511 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xcore/e/xcore_xserial_config.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xcore/e/xcore_xserial_config.e
@@ -1,15 +1,15 @@
-/*------------------------------------------------------------------------- 
+/*-------------------------------------------------------------------------
 File name   : xcore_xserial_config.e
 Title       : XSerial eVC configuration
 Project     : Xcore eVC
 Created     : 2008
 Description : Configures XSerial eVC for the XCore
-Notes       : 
---------------------------------------------------------------------------- 
+Notes       :
+---------------------------------------------------------------------------
 Copyright (c) 2008-2010 Cadence Design Systems,Inc.All rights reserved worldwide.
 Please refer to the terms and conditions in $IPCM_HOME
 
--------------------------------------------------------------------------*/ 
+-------------------------------------------------------------------------*/
 
 <'
 
@@ -23,22 +23,22 @@ extend xserial_env_u {
 };
 
 '>
-   
-   
+
+
    Configurate the XSerial eVC
-   
+
    Using soft constraints, so can be overwritten in the SVE
 
-   
+
 <'
 
 
 extend XCORE_XSERIAL xserial_agent_u {
     keep soft tx_clock_period == 20 ns;
-    
+
     keep soft tx_log_filename == "XCORE_XSERIAL_TX";
     keep soft rx_log_filename == "XCORE_XSERIAL_RX";
-}; 
+};
 
 
 extend xserial_agent_u {
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xcore/main_sve/main_sve_config.e b/lesson000X_mluvm_svsc/uvm_examples/xcore/main_sve/main_sve_config.e
index 10b0db3..79bc3ba 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xcore/main_sve/main_sve_config.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xcore/main_sve/main_sve_config.e
@@ -6,11 +6,11 @@ Title        : XCore eVC demo - configuration
 Project      : XCore eVC
 Created On   : March 2004
 Description  : This file demonstrates integration of the insantiations of
-             : the XBus, XSerial and XCore eVCs to form a deliverable 
+             : the XBus, XSerial and XCore eVCs to form a deliverable
              : testbench env for the XCore module.
              :
              : This configuration is for the sample device
-Notes        : 
+Notes        :
 ----------------------------------------------------------------------------
 >>>>>>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
 ----------------------------------------------------------------------------
@@ -35,15 +35,15 @@ extend xcore_env_name_t : [XCORE_SVE];
 
 extend sys {
     xcore_sve : xcore_sve_u is instance;
-}; 
+};
 '>
-   
+
    Instantiate all environment components:
                 eVCs, memory, drivers
 
 <'
 unit xcore_sve_u like uvm_env {
-   
+
     keep hdl_path()           == "xcore_tb";
 
     xcore_evc : PASSIVE XCORE_SVE xcore_env_u is instance;
@@ -55,12 +55,12 @@ unit xcore_sve_u like uvm_env {
 
 
     -- The instance of the XSerial eVC
-    xserial_evc : XCORE_XSERIAL has_tx_path has_rx_path 
+    xserial_evc : XCORE_XSERIAL has_tx_path has_rx_path
                                                   xserial_env_u is instance;
-    
+
 
     -- Registers address map
-    xcore_addr_map : vr_ad_map;  
+    xcore_addr_map : vr_ad_map;
 
 
     -- The virtual sequence driver, controlling all the drivers
@@ -69,42 +69,42 @@ unit xcore_sve_u like uvm_env {
     reg_driver: vr_ad_sequence_driver is instance;
       keep reg_driver.addr_map == value(xcore_addr_map);
       keep reg_driver.default_bfm_sd == xbus_evc.active_masters[0].driver;
-   
-   
+
+
     -- Connect the pointers, connect eVCs to each other
-    
+
     connect_pointers() is also {
         xcore_evc.xbus_evc = xbus_evc;
         xcore_evc.xserial_evc = xserial_evc;
         xcore_evc.xbus_agent = xbus_evc.passive_slaves[0];
-        
+
         virtual_seq_driver.xcore_regs_driver = reg_driver;
         virtual_seq_driver.xserial_driver = xserial_evc.agent.
           as_a(ACTIVE has_tx_path xserial_agent_u).tx_driver;
         virtual_seq_driver.xbus_driver = xbus_evc.active_masters[0].driver;
 
     }; -- connect_pointers()
-    
+
 }; -- unit xcore_sve_u
 
 '>
-  
-   
+
+
    XCore registers file and address map
 
    When the XCore eVC informs that all data is valid - add the XCore registers
    file to the memory map.
 
 <'
-extend xcore_sve_u {   
+extend xcore_sve_u {
     event update_memory_map is @xcore_evc.update_memory_map;
-    
+
     on update_memory_map {
         -- Add the XCore registers to the address map
         xcore_addr_map.add_with_offset(xcore_evc.monitor.base_address,
                                        xcore_evc.reg_file);
-    }; 
-}; 
+    };
+};
 
 
 
@@ -114,50 +114,50 @@ extend xcore_sve_u {
     post_generate() is also {
         -- Give all registers in the shadow registers their reset value
         xcore_addr_map.reset();
-    }; 
-    
+    };
+
     get_addr_map() : vr_ad_map is {
         result = xcore_addr_map;
     };
-    
+
     event device_reset_done is @xcore_evc.reset_deassert;
-    
+
     // The vr_ad does not participate in the testflow, in this eVC,
     // so we have to add the synhcronization with reest.
     // If vr_ad uses the testflow, no need for this synch
     on device_reset_done {
         emit reg_driver.device_reset_done;
-    }; 
+    };
 
-}; -- extend xcore_sve_u 
+}; -- extend xcore_sve_u
 '>
-   
+
    Objection to TEST_DONE:
-   
-   After all sequences drop their objection to TEST_DONE, there is a need 
-   to allow the test to continue for some amount of time, to give the XCore 
-   time to repsond to the last sequence. 
+
+   After all sequences drop their objection to TEST_DONE, there is a need
+   to allow the test to continue for some amount of time, to give the XCore
+   time to repsond to the last sequence.
 
 <'
 extend xcore_sve_u {
     all_objections_dropped(kind : objection_kind) is also {
        if kind == TEST_DONE then {
           start xcore_evc.postpone_end_of_test();
-       }; 
-    };     
- }; 
+       };
+    };
+ };
 '>
 
 
   Controlling the sequences:
 
-  In this environment, most of the scenarios are to be created by the virtual 
+  In this environment, most of the scenarios are to be created by the virtual
   sequnce driver, which controls the BFM drivers.
 
 <'
 extend MAIN xbus_master_sequence {
     keep soft count == 0;
-}; 
+};
 
 extend MAIN xserial_sequence {
     keep soft count == 0;
@@ -166,7 +166,7 @@ extend MAIN xserial_sequence {
 
 extend MAIN vr_ad_sequence {
     keep soft count == 0;
-}; 
+};
 
 '>
 
@@ -176,9 +176,9 @@ Configuration of Specman
 extend sys {
     init() is also {
         // Use a performance enhancement feature
-        set_config(simulation, enable_ports_unification, TRUE); 
+        set_config(simulation, enable_ports_unification, TRUE);
     };
-    
+
     run() is also {
         // Ignore the messages from the vr_ad
         specman("set message -remove @vr_ad*");
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xcore/main_sve/main_sve_patches.e b/lesson000X_mluvm_svsc/uvm_examples/xcore/main_sve/main_sve_patches.e
index c210007..f5d387f 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xcore/main_sve/main_sve_patches.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xcore/main_sve/main_sve_patches.e
@@ -18,7 +18,7 @@ Inc.All rights reserved worldwide.
 Revision History :
 ----------------------------------------------------------------------------
 
-  
+
   No patches required for this version
 
 <'
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xcore/main_sve/tests/setup_test.e b/lesson000X_mluvm_svsc/uvm_examples/xcore/main_sve/tests/setup_test.e
index 68a1422..b30aaf7 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xcore/main_sve/tests/setup_test.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xcore/main_sve/tests/setup_test.e
@@ -5,8 +5,8 @@ File name    : setup_test.e
 Title        : XCore eVC demo - example test setup file
 Project      : XCore
 Created On   : 2008
-Description  : 
-Notes        :  
+Description  :
+Notes        :
 ----------------------------------------------------------------------------
 >>>>>>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
 ----------------------------------------------------------------------------
@@ -28,20 +28,20 @@ extend sys {
 
 
 extend MAIN MAIN_TEST xbus_master_sequence {
-   
-    keep soft sequence.kind in [XCORE_WRITE_FRAME, 
-                               XCORE_READ_FRAME, 
+
+    keep soft sequence.kind in [XCORE_WRITE_FRAME,
+                               XCORE_READ_FRAME,
                                XCORE_READ_WRITE_FRAME];
 
-    
-}; 
+
+};
 
 
 extend MAIN vr_ad_sequence {
-    keep soft sequence.kind == XCORE_XBUS_READ_WRITE;    
-}; 
+    keep soft sequence.kind == XCORE_XBUS_READ_WRITE;
+};
 
 '>
-   
-   
-   
+
+
+
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xcore/main_sve/tests/xcore_error_rx_frames_test.e b/lesson000X_mluvm_svsc/uvm_examples/xcore/main_sve/tests/xcore_error_rx_frames_test.e
index c2fd145..2c9852c 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xcore/main_sve/tests/xcore_error_rx_frames_test.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xcore/main_sve/tests/xcore_error_rx_frames_test.e
@@ -7,7 +7,7 @@ Project      : XCore eVC
 Created On   : 2008
 Description  : Send some frames to the XCore on the XSerial.
              : ~30% of them have bad parity
-Notes        :  
+Notes        :
 
 ----------------------------------------------------------------------------
 >>>>>>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
@@ -29,31 +29,31 @@ extend MAIN MAIN_TEST xserial_sequence {
 
     -- Test must not stop before the serial sequence finishes
     keep prevent_test_done == TRUE;
-}; 
+};
 
 -- Read all the sent frames
 extend MAIN vr_ad_sequence {
     keep sequence.kind == XCORE_XBUS_READ_WRITE;
 
      keep count == 10;
-    
+
     -- The sequence polls the registers to read 10 frames.
-    -- Since there can be less than 10 frames in the test (depends on the 
+    -- Since there can be less than 10 frames in the test (depends on the
     -- xserial_sequence), this sequence must not object to end of test.
-    -- It keeps reading the registers until either read 10 frames, or the 
+    -- It keeps reading the registers until either read 10 frames, or the
     -- test ended. Which ever comes first.
     keep prevent_test_done == FALSE;
 };
 
 -- Each frame has a 30% probability to have parity error
-extend  xserial_frame_s {  
+extend  xserial_frame_s {
     keep bad_parity.reset_soft();
-    
+
     keep soft bad_parity == select {
         30 : TRUE;
         70 : FALSE;
     };
-    
+
 };
 
 extend xserial_frame_payload_s {
@@ -65,16 +65,16 @@ extend MAIN MAIN_TEST xcore_combined_sequence {
     keep count == 0;
 };
 '>
-   
+
 <'
 extend sys {
     bad_counter : uint;
     good_counter : uint;
     keep bad_counter == 0;
     keep good_counter == 0;
-    
+
     check() is also {
-        message(LOW, "frames with bad parity: ", bad_counter, 
+        message(LOW, "frames with bad parity: ", bad_counter,
                 "\nframes with good parity: ",   good_counter  );
     };
 };
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xcore/main_sve/tests/xcore_fill_rx_fifo_test.e b/lesson000X_mluvm_svsc/uvm_examples/xcore/main_sve/tests/xcore_fill_rx_fifo_test.e
index 83c9f7a..4bb72dc 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xcore/main_sve/tests/xcore_fill_rx_fifo_test.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xcore/main_sve/tests/xcore_fill_rx_fifo_test.e
@@ -8,7 +8,7 @@ Created On   : 2008
 Description  : XSerial agent sends frames.
              : XCore is expected to transmit HALT frame after 2 frames.
              : XBus agent reads the frames after both are sent.
-Notes        :  
+Notes        :
 
 ----------------------------------------------------------------------------
 >>>>>>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
@@ -30,7 +30,7 @@ extend MAIN MAIN_TEST xcore_combined_sequence {
 
    keep prevent_test_done == TRUE;
 
-}; 
+};
 
 
 extend XCORE_XSERIAL MAIN MAIN_TEST xserial_sequence {
@@ -38,7 +38,7 @@ extend XCORE_XSERIAL MAIN MAIN_TEST xserial_sequence {
 };
 
 
-extend MAIN vr_ad_sequence { 
+extend MAIN vr_ad_sequence {
    keep count == 0;
 };
 
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xcore/main_sve/tests/xcore_halt_test.e b/lesson000X_mluvm_svsc/uvm_examples/xcore/main_sve/tests/xcore_halt_test.e
index bbb692a..41b6e67 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xcore/main_sve/tests/xcore_halt_test.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xcore/main_sve/tests/xcore_halt_test.e
@@ -5,13 +5,13 @@ File name    : xcore_halt_test.e
 Title        : XCore eVC demo - example testcase file
 Project      : XCore eVC
 Created On   : 2008
-Description  : 
-Notes        : Behaviour of XCore (TX or not TX) depends on when the HALT 
+Description  :
+Notes        : Behaviour of XCore (TX or not TX) depends on when the HALT
              : frame arrives. The test does not check XCore's behaivour.
              : Check should be part of the eVC
              : It demonstrates setting effect of a check, using it name -
-             : set_check_by_name("has_protocol_checker xserial_monitor_u", 
-             :                   "exp_send_while_not_ready", 
+             : set_check_by_name("has_protocol_checker xserial_monitor_u",
+             :                   "exp_send_while_not_ready",
              :                   WARNING);
 ----------------------------------------------------------------------------
 >>>>>>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
@@ -23,30 +23,30 @@ Copyright (c) 2008-2010 Cadence Design Systems,Inc.
 <'
 
 import xcore/main_sve/main_sve_config;
-import xcore/main_sve/tests/setup_test; 
+import xcore/main_sve/tests/setup_test;
 
 
 
-extend xserial_sequence_kind : [XCORE_SEND_HALT, 
+extend xserial_sequence_kind : [XCORE_SEND_HALT,
                                 XCORE_SEND_RESUME,
                                 XSERIAL_SEND_HALT,
                                 XSERIAL_SEND_RESUME];
 
 extend XSERIAL_SEND_HALT xserial_sequence {
-    
+
     keep frame.payload is a MESSAGE xserial_frame_payload_s (MP) and
       (MP.frame_message == HALT);
     keep frame.payload is a MESSAGE xserial_frame_payload_s;
-    
+
     body() @driver.clock is {
         do frame;
-    }; 
+    };
 };
 
 
 extend XCORE_SEND_HALT xserial_sequence {
     !send_halt_frame : XSERIAL_SEND_HALT xserial_sequence;
-    
+
     body() @driver.clock is only {
         do send_halt_frame;
     }; -- body() @driver....
@@ -61,7 +61,7 @@ extend XSERIAL_SEND_RESUME xserial_sequence {
 
     body() @driver.clock is {
         do frame;
-    }; 
+    };
 };
 
 
@@ -79,13 +79,13 @@ extend XCORE_SEND_RESUME xserial_sequence {
 extend MAIN MAIN_TEST xcore_combined_sequence {
    !program_xcore_to_tx : XCORE_XBUS_WRITE vr_ad_sequence;
        keep program_xcore_to_tx.driver == driver.xcore_regs_driver;
-   
+
    !send_halt_frame     : XCORE_SEND_HALT xserial_sequence;
        keep send_halt_frame.driver == driver.xserial_driver;
 
    !send_resume_frame   : XCORE_SEND_RESUME xserial_sequence;
        keep send_resume_frame.driver == driver.xserial_driver;
-       
+
    tx_frames_before : uint;
        keep soft tx_frames_before in [4..10];
 
@@ -99,20 +99,20 @@ extend MAIN MAIN_TEST xcore_combined_sequence {
        keep soft inter_tx_delay in [10..100];
 
     keep prevent_test_done;
-    
+
    body() @driver.clock is only {
- 
+
       wait [100] * cycle;
-      
+
        -- Write TX frames, for the XCore to transmit
        for i from 0 to tx_frames_before - 1 {
            do program_xcore_to_tx;
-       }; 
-       
+       };
+
        -- Send a HALT frame. There should be some TX frames in the fifo
-       do send_halt_frame; 
+       do send_halt_frame;
 
-       -- Continue to write TX frames, and release the XCore by 
+       -- Continue to write TX frames, and release the XCore by
        -- sending a RESUME frame
        all of {
            {
@@ -124,8 +124,8 @@ extend MAIN MAIN_TEST xcore_combined_sequence {
            };
            {
                wait [wait_before_resume] * cycle;
-               do send_resume_frame; 
-           }; 
+               do send_resume_frame;
+           };
 
       }; -- all of
 
@@ -137,17 +137,17 @@ extend MAIN MAIN_TEST xcore_combined_sequence {
 
 
 '>
-   
+
 <'
 extend sys {
     // With some seeds, this test uncover a bug in the design
     setup() is also {
-        set_check_by_name("has_protocol_checker xserial_monitor_u", 
-                          "exp_send_while_not_ready", 
+        set_check_by_name("has_protocol_checker xserial_monitor_u",
+                          "exp_send_while_not_ready",
                           WARNING);
-    }; 
+    };
 
- }; 
+ };
 
 '>
-  
+
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xcore/main_sve/tests/xcore_lpbk_test.e b/lesson000X_mluvm_svsc/uvm_examples/xcore/main_sve/tests/xcore_lpbk_test.e
index b758a01..c822357 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xcore/main_sve/tests/xcore_lpbk_test.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xcore/main_sve/tests/xcore_lpbk_test.e
@@ -6,12 +6,12 @@ Title        : XCore eVC demo - example testcase file
 Project      : XCore eVC
 Created On   : 2008
 Description  : Repeat 5 times:
-             :   XSerial agent sends 1 XSerial frame to the XCore, 
-             :   XBus Master reads the frame from the XCore 
+             :   XSerial agent sends 1 XSerial frame to the XCore,
+             :   XBus Master reads the frame from the XCore
              :   XBus Master write to the XCore, programs it to transmit
              :   a frame
              :   XCore expected to transmit a frame on the XSerial.
-Notes        :  
+Notes        :
 
 ----------------------------------------------------------------------------
 >>>>>>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
@@ -32,7 +32,7 @@ extend XCORE_XSERIAL MAIN MAIN_TEST xserial_sequence {
    keep count == 5;
    keep sequence.kind == XCORE_SEND_FRAME;
 
-     
+
 };
 
 
@@ -44,7 +44,7 @@ extend MAIN vr_ad_sequence {
    keep count == 5;
    keep sequence.kind == XCORE_XBUS_READ_WRITE;
 
-    
+
    keep prevent_test_done == TRUE;
 
 };
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xcore/main_sve/tests/xcore_phases_test.e b/lesson000X_mluvm_svsc/uvm_examples/xcore/main_sve/tests/xcore_phases_test.e
index ec232cb..88927d2 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xcore/main_sve/tests/xcore_phases_test.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xcore/main_sve/tests/xcore_phases_test.e
@@ -5,10 +5,10 @@ File name    : xcore_phases_test.e
 Title        : Testflow Demonstrated
 Project      : XCore eVC
 Created On   : 2008
-Description  : 
-             : Dummy activities, demoing how the components go from phase 
+Description  :
+             : Dummy activities, demoing how the components go from phase
              : to phase, and wait when required - xserial and xcore depend
-             : on xbus's reset,  the three domain synch on MAIN_TEST and 
+             : on xbus's reset,  the three domain synch on MAIN_TEST and
              : POST_TEST
 ----------------------------------------------------------------------------
 >>>>>>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
@@ -47,10 +47,10 @@ extend MASTER xbus_agent_u {
     };
     tf_post_test() @tf_phase_clock is also {
         wait [100] * cycle;
-    };   
+    };
 };
 
-       
+
 extend MAIN RESET xcore_combined_sequence {
     body() @driver.clock is also {
         wait [50] * cycle;
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xcore/main_sve/tests/xcore_reconfiguration.e b/lesson000X_mluvm_svsc/uvm_examples/xcore/main_sve/tests/xcore_reconfiguration.e
index 1b34aa8..5643448 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xcore/main_sve/tests/xcore_reconfiguration.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xcore/main_sve/tests/xcore_reconfiguration.e
@@ -10,7 +10,7 @@ Description  : Test scneario:
              : This file demonstrates the ability of the eVC to cope with
              : multiple configurations. Each time it should propagate
              : config info to sub-components
-             :  
+             :
              : Call xbus_env configure method several times, each time
              : with different set of parameters, and check the result.
 ----------------------------------------------------------------------------
@@ -28,102 +28,102 @@ import setup_test;
 
 -- Main scenario:
 -- configure the xcore env several times during the run
--- since the env participates here in defining test scenario - add it to 
+-- since the env participates here in defining test scenario - add it to
 -- the testflow
 extend xcore_env_u  {
-    
+
     tf_main_test() @tf_phase_clock is also {
         // Start tet scneraio
         start reconfig_during_the_run();
-        
+
         // Register the thread as running only in MAIN_TEST, blocking.
         // The domain will not proceed to next phase, before this TCM is over.
-        tf_get_domain_mgr().register_thread_by_name(me, "reconfig_during_the_run", 
+        tf_get_domain_mgr().register_thread_by_name(me, "reconfig_during_the_run",
                                                     MAIN_TEST, TRUE);
-  
+
     };
-    
+
     reconfig_during_the_run() @tf_phase_clock is {
-        
+
         wait [10] * cycle;
         message(LOW, "Config XCORE mode to NORMAL, Speed to 100");
         //            ----------------------------------------
         uvm_configure 1 me {mode; max_speed} {xcore_mode_t'NORMAL; 100};
-               
+
         // Check:
         check that config.params.mode == NORMAL else
           dut_error("2nd configuration failed, ",
                     "config.params.mode == ",
-                    config.params.mode);    
+                    config.params.mode);
         check that config.params.max_speed == 100 else
           dut_error("2nd configuration failed, ",
                     "config.params.max_speed == ",
-                    config.params.max_speed);    
-       
+                    config.params.max_speed);
+
         check that xserial_evc.config.params.mode == SLOW else
           dut_error("2nd configuration failed, ",
                     "xserial_evc.config.params.mode == ",
-                    xserial_evc.config.params.mode);    
+                    xserial_evc.config.params.mode);
         // -------------------------------------------------------
         wait [10] * cycle;
         message(LOW, "Config XCORE mode to NORMAL, Speed to 1000");
         //            ----------------------------------------
         uvm_configure 1 me {mode; max_speed} {xcore_mode_t'NORMAL; 1000};
-                   
+
         // Check:
         check that config.params.mode == NORMAL else
           dut_error("2nd configuration failed, ",
                     "config.params.mode == ",
-                    config.params.mode);    
+                    config.params.mode);
         check that config.params.max_speed == 1000 else
           dut_error("2nd configuration failed, ",
                     "config.params.max_speed == ",
-                    config.params.max_speed);    
-       
+                    config.params.max_speed);
+
         check that xserial_evc.config.params.mode == NORMAL else
           dut_error("2nd configuration failed, ",
                     "xserial_evc.config.params.mode == ",
-                    xserial_evc.config.params.mode);    
+                    xserial_evc.config.params.mode);
         // -------------------------------------------------------
         wait [10] * cycle;
         message(LOW, "Config XCORE mode to FULL_SPEED");
         //            ----------------------------------------
         uvm_configure 1 me {mode} {xcore_mode_t'FULL_SPEED };
-               
+
         // Check:
         check that config.params.mode == FULL_SPEED else
           dut_error("2nd configuration failed, ",
                     "config.params.mode == ",
-                    config.params.mode);    
+                    config.params.mode);
         check that config.params.max_speed == 1000 else
           dut_error("2nd configuration failed, ",
                     "config.params.max_speed == ",
-                    config.params.max_speed);    
-       
+                    config.params.max_speed);
+
         check that xserial_evc.config.params.mode == FAST else
           dut_error("2nd configuration failed, ",
                     "xserial_evc.config.params.mode == ",
-                    xserial_evc.config.params.mode);    
+                    xserial_evc.config.params.mode);
         // -------------------------------------------------------
         wait [10] * cycle;
         message(LOW, "Config XCORE mode to FULL_SPEED, Speed to 37");
         //            ----------------------------------------
         uvm_configure 1 me {mode; max_speed} {xcore_mode_t'FULL_SPEED; 37};
-               
+
         // Check:
         check that config.params.mode == FULL_SPEED else
           dut_error("2nd configuration failed, ",
                     "config.params.mode == ",
-                    config.params.mode);    
+                    config.params.mode);
         check that config.params.max_speed == 37 else
           dut_error("2nd configuration failed, ",
                     "config.params.max_speed == ",
-                    config.params.max_speed);    
-       
+                    config.params.max_speed);
+
         check that xserial_evc.config.params.mode == FAST else
           dut_error("2nd configuration failed, ",
                     "xserial_evc.config.params.mode == ",
-                    xserial_evc.config.params.mode);    
+                    xserial_evc.config.params.mode);
         // -------------------------------------------------------
 
         // TCM is over - unregister, so domain may proceed to next phase
@@ -144,7 +144,7 @@ extend XCORE_XSERIAL MAIN MAIN_TEST xserial_sequence {
    keep count == 3;
    keep sequence.kind == XCORE_SEND_FRAME;
 
-     
+
 };
 
 extend xbus_agent_u {
@@ -160,7 +160,7 @@ extend MAIN vr_ad_sequence {
    -- Reflect all 3 input frames back to the output
    keep count == 3;
    keep sequence.kind == XCORE_XBUS_READ_WRITE;
-    
+
    keep prevent_test_done == TRUE;
 
 };
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xcore/main_sve/tests/xcore_rerun_test.e b/lesson000X_mluvm_svsc/uvm_examples/xcore/main_sve/tests/xcore_rerun_test.e
index 718fe4f..1dd7afb 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xcore/main_sve/tests/xcore_rerun_test.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xcore/main_sve/tests/xcore_rerun_test.e
@@ -13,8 +13,8 @@ Description  : Reset scneario:
              : XSerial components should wait until xbus is out of reset.
              :
              : Repeat 3 times:
-             :   XSerial agent sends 1 XSerial frame to the XCore, 
-             :   XBus Master reads the frame from the XCore 
+             :   XSerial agent sends 1 XSerial frame to the XCore,
+             :   XBus Master reads the frame from the XCore
              :   XBus Master write to the XCore, programs it to transmit
              :   a frame
              :   XCore expected to transmit a frame on the XSerial.
@@ -24,7 +24,7 @@ Description  : Reset scneario:
              : Verbosity of logger is set to FULL, to see all TESTFLOW
              : related messages coming from the eVCs.
              :
-             : For seeing messages of the utility itself, set the verbosity 
+             : For seeing messages of the utility itself, set the verbosity
              : of the tag TESTFLOW to FULL.
              :
 ----------------------------------------------------------------------------
@@ -46,7 +46,7 @@ extend XCORE_XSERIAL MAIN MAIN_TEST xserial_sequence {
    keep count == 3;
    keep sequence.kind == XCORE_SEND_FRAME;
 
-     
+
 };
 
 extend xbus_agent_u {
@@ -62,7 +62,7 @@ extend MAIN vr_ad_sequence {
    -- Reflect all 3 input frames back to the output
    keep count == 3;
    keep sequence.kind == XCORE_XBUS_READ_WRITE;
-    
+
    keep prevent_test_done == TRUE;
 
 };
@@ -70,17 +70,17 @@ extend MAIN vr_ad_sequence {
 
 extend MAIN INIT_LINK xbus_master_sequence {
     body() @driver.clock is also {
-        // Do nothing, just to see how the others wait for me to 
+        // Do nothing, just to see how the others wait for me to
         // get to MAIN_TEST
         wait [100] * cycle;
-        if driver.tf_get_domain_mgr().get_invocation_count(INIT_LINK) < 2 
+        if driver.tf_get_domain_mgr().get_invocation_count(INIT_LINK) < 2
                                                                   then {
             wait [80];
             message(TESTFLOW_EX, LOW, "Calling rerun_phase(RESET)");
             driver.tf_get_domain_mgr().rerun_phase(RESET);
         };
-        
-    };    
+
+    };
 
 };
 
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xcore/main_sve/tests/xcore_send_idle_frames_test.e b/lesson000X_mluvm_svsc/uvm_examples/xcore/main_sve/tests/xcore_send_idle_frames_test.e
index 6ad07ef..9df53b0 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xcore/main_sve/tests/xcore_send_idle_frames_test.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xcore/main_sve/tests/xcore_send_idle_frames_test.e
@@ -7,10 +7,10 @@ Project      : XCore eVC
 Created On   : 2008
 Description  : Send 5 frames on XSserial, not all DATA. XBus reads and
              : writes back all the DATA frames.
-Notes        : This test uncover a bug in the XCore. 
+Notes        : This test uncover a bug in the XCore.
              : It demonstrates setting effect of a check, using it name -
-             :         set_check_by_name("xserial_scoreboard_u", 
-             :             "scbd_empty", 
+             :         set_check_by_name("xserial_scoreboard_u",
+             :             "scbd_empty",
              :             WARNING);
 ----------------------------------------------------------------------------
 >>>>>>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
@@ -31,7 +31,7 @@ extend XCORE_XSERIAL MAIN MAIN_TEST xserial_sequence {
    keep count == 5;
    keep sequence.kind == XCORE_SEND_FRAME;
 
-   keep prevent_test_done == TRUE; 
+   keep prevent_test_done == TRUE;
 };
 
 
@@ -45,13 +45,13 @@ extend xserial_frame_payload_s {
     keep soft frame_format == select {
         50 : DATA;
         50 : MESSAGE;
-    }; 
-}; 
+    };
+};
 
 -- Only IDLE messages
 extend MESSAGE xserial_frame_payload_s {
   keep frame_message == IDLE;
-}; 
+};
 
 -- Program the XCore to read the frames
 extend MAIN vr_ad_sequence {
@@ -64,8 +64,8 @@ extend MAIN vr_ad_sequence {
 
    -- Not all frames are expected to be reflected (not all are DATA),
    -- so this sequence should not stop the test
-   keep prevent_test_done == FALSE; 
-   
+   keep prevent_test_done == FALSE;
+
 };
 
 -- No virtaul sequence in this test, scneraio created by BFM sequences
@@ -77,5 +77,5 @@ extend MAIN MAIN_TEST xcore_combined_sequence {
 
 '>
 
-   
-   
+
+
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xcore/main_sve/tests/xcore_tx_frames_basic_test.e b/lesson000X_mluvm_svsc/uvm_examples/xcore/main_sve/tests/xcore_tx_frames_basic_test.e
index 5a3a927..11e1047 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xcore/main_sve/tests/xcore_tx_frames_basic_test.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xcore/main_sve/tests/xcore_tx_frames_basic_test.e
@@ -5,9 +5,9 @@ File name    : xcore_tx_frames_basic_test.e
 Title        : XCore eVC demo - example testcase file
 Project      : XCore eVC
 Created On   : 2008
-Description  : XBus writes several frames to the XCore, to be transmited 
-             : on the XSerial 
-Notes        :  
+Description  : XBus writes several frames to the XCore, to be transmited
+             : on the XSerial
+Notes        :
 
 ----------------------------------------------------------------------------
 >>>>>>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
@@ -28,7 +28,7 @@ extend MAIN vr_ad_sequence {
    keep sequence.kind == XCORE_XBUS_WRITE;
 
      keep prevent_test_done == TRUE;
-}; 
+};
 
 
 -- No virtaul sequence in this test, scneraio created by BFM sequences
@@ -37,4 +37,4 @@ extend MAIN xcore_combined_sequence {
 };
 
 '>
-   
+
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xcore/main_sve/tests/xcore_virtual_seq_doing_items_test.e b/lesson000X_mluvm_svsc/uvm_examples/xcore/main_sve/tests/xcore_virtual_seq_doing_items_test.e
index 79ab4cf..80f0d98 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xcore/main_sve/tests/xcore_virtual_seq_doing_items_test.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xcore/main_sve/tests/xcore_virtual_seq_doing_items_test.e
@@ -5,14 +5,14 @@ File name    : xcore_virtual_seq_doing_items_test.e
 Title        : XCore eVC test - virtual Seq Doing Items
 Project      : XCore eVC
 Created On   : 2008
-Description  : Demostrate the ability of a virtual sequence to send 
+Description  : Demostrate the ability of a virtual sequence to send
              : items (of other sequences)
-             : 
-Notes        : When doing items from the virtual sequence, one has to 
+             :
+Notes        : When doing items from the virtual sequence, one has to
              : know the details of the i/f protocol. This is simple in
              : the case of the XSerial - just generate a legal packet.
              : It is more complicated for the XBus, because the XBus
-             : protocol requires accessing specific addresses in 
+             : protocol requires accessing specific addresses in
              : specific conditions. No sense for implementing this
              : protocol in the virtual sequence, so it does XBus predefined
              : sequences
@@ -31,24 +31,24 @@ import xcore/main_sve/main_sve_config;
 extend MAIN MAIN_TEST xcore_combined_sequence {
     !xbus_read_frame_seq :  XCORE_READ_FRAME xbus_master_sequence;
     !xserial_frame :  TX xserial_frame_s;
-    
-    
+
+
     body() @driver.clock is only {
-    
+
         for i from 0 to 3 {
             // Doing an item:
             do xserial_frame on driver.xserial_driver;
-            
+
             // Doing a sequence:
             do xbus_read_frame_seq keeping {.driver == driver.xbus_driver};
         };
-        // Note - the item can also be sent using deliver_item. 
+        // Note - the item can also be sent using deliver_item.
         gen xserial_frame keeping {.driver == driver.xserial_driver};
         driver.xserial_driver.wait_for_grant(me);
         driver.xserial_driver.deliver_item(xserial_frame);
-        
+
         do xbus_read_frame_seq keeping {.driver == driver.xbus_driver};
-    }; 
+    };
 
 };
 
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xcore/main_sve/tests/xcore_virtual_seq_test.e b/lesson000X_mluvm_svsc/uvm_examples/xcore/main_sve/tests/xcore_virtual_seq_test.e
index 7a88156..7d86bc3 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xcore/main_sve/tests/xcore_virtual_seq_test.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xcore/main_sve/tests/xcore_virtual_seq_test.e
@@ -5,14 +5,14 @@ File name    : xcore_virtual_seq_test.e
 Title        : XCore eVC demo - example testcase file
 Project      : XCore eVC
 Created On   : 2008
-Description  : XSerial agent sends several XSerial frames to the XCore. 
+Description  : XSerial agent sends several XSerial frames to the XCore.
              : Xbus Master reads all the frames.
-             : After the last frame, the XBus master writes 
-             : the frame to the XCore (whci should transmit it) 
+             : After the last frame, the XBus master writes
+             : the frame to the XCore (whci should transmit it)
              :
-             : Test implemented using virtual sequences activating 
+             : Test implemented using virtual sequences activating
              : vr_ad and xserial sequences.
-Notes        :  
+Notes        :
 
 ----------------------------------------------------------------------------
 >>>>>>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
@@ -29,21 +29,21 @@ import xcore/main_sve/main_sve_config;
 
 
 extend MAIN MAIN_TEST xcore_combined_sequence {
-    !xserial_to_xbus          : XCORE_XSERIAL_TO_XBUS 
+    !xserial_to_xbus          : XCORE_XSERIAL_TO_XBUS
                                                xcore_combined_sequence;
-    !xserial_to_xbus_loopback : XCORE_XSERIAL_TO_XBUS_LOOPBACK 
+    !xserial_to_xbus_loopback : XCORE_XSERIAL_TO_XBUS_LOOPBACK
                                                xcore_combined_sequence;
-     
+
 
     body() @driver.clock is only {
         do xserial_to_xbus;
         do xserial_to_xbus;
         do xserial_to_xbus;
-        
+
         wait [300] * cycle;
 
         do xserial_to_xbus_loopback;
-    }; 
+    };
 
 };
 
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xcore/main_sve/tests/xcore_xbus_seq_test.e b/lesson000X_mluvm_svsc/uvm_examples/xcore/main_sve/tests/xcore_xbus_seq_test.e
index 53883db..219a6b8 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xcore/main_sve/tests/xcore_xbus_seq_test.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xcore/main_sve/tests/xcore_xbus_seq_test.e
@@ -7,14 +7,14 @@ Project      : XCore eVC
 Created On   : 2008
 Purpose      : Demonstrate usage of the XBus sequences in the XCore eVC
 Description  : Repeat 7..10 times:
-             :   XSerial agent sends 1 XSerial frame to the XCore, 
-             :   XBus Master reads the frame from the XCore 
-             :   XBus Master write to the XCore, programs it to transmit 
+             :   XSerial agent sends 1 XSerial frame to the XCore,
+             :   XBus Master reads the frame from the XCore
+             :   XBus Master write to the XCore, programs it to transmit
              :   a frame
              :   XCore expected to transmit a frame on the XSerial.
              : Access on the XBus is done using the xbus_master_sequences
              : (not using the registers sequnece).
-Notes        :  
+Notes        :
 
 ----------------------------------------------------------------------------
 >>>>>>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
@@ -23,7 +23,7 @@ Copyright (c) 2008-2010 Cadence Design Systems,Inc.
   All rights reserved worldwide
 
 ----------------------------------------------------------------------------
-   
+
 <'
 
 import xcore/main_sve/main_sve_config;
@@ -44,22 +44,22 @@ extend MAIN MAIN_TEST xbus_master_sequence  {
     -- Reflect all input frames back to the output.
     keep sequence.kind in [XCORE_READ_WRITE_FRAME];
 
-    -- Should reflect back all received frames. Expected number of 
+    -- Should reflect back all received frames. Expected number of
     -- frames is <= 10
     keep count == 10;
-   
-   -- Cannot know how many frames are to be read, this sequence should not 
+
+   -- Cannot know how many frames are to be read, this sequence should not
    -- object to test_done
    keep prevent_test_done == FALSE;
 
 };
 
 
--- In this test, accesses are done using the xbus sequence, not the 
+-- In this test, accesses are done using the xbus sequence, not the
 -- virtual sequecne
 extend MAIN xcore_combined_sequence {
    keep count == 0;
-}; 
+};
 
 '>
 
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xcore/v/tb_xcore.v b/lesson000X_mluvm_svsc/uvm_examples/xcore/v/tb_xcore.v
index 5f12813..8e56322 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xcore/v/tb_xcore.v
+++ b/lesson000X_mluvm_svsc/uvm_examples/xcore/v/tb_xcore.v
@@ -1,12 +1,12 @@
-//--------------------------------------------------------------------------- 
+//---------------------------------------------------------------------------
 //File name   : tb_xcore.v
 //Title       : Verilog testbench for XCore demo
 //Project     : XCore eVC
 //Developers  : Richard Vialls, Black Cat Electronics Ltd
 //Created     : 22-May-2002
-//Description : 
-//Notes       : 
-//--------------------------------------------------------------------------- 
+//Description :
+//Notes       :
+//---------------------------------------------------------------------------
 //Copyright (c) 2002-2010 Cadence Design Systems,Inc.All rights reserved worldwide
 //(Acquired from Verisity Design,Inc.,2005).
 //Please refer to the terms and conditions in $IPCM_HOME
@@ -15,8 +15,8 @@
 `timescale 1ns/1ns
 module xcore_tb;
 
-     
-   
+
+
    // XBus signals
    reg xbus_clock;
    reg xbus_reset;
@@ -30,7 +30,7 @@ module xcore_tb;
    wire xbus_wait;
    wire xbus_error;
    reg xbus_grant;
-   reg xbus_request; 
+   reg xbus_request;
 
    // XSerial signals
    reg xserial_tx_clock;
@@ -40,26 +40,26 @@ module xcore_tb;
 
    // XCore signals
    reg [15:8] base_addr;
-   
-   
+
+
    always
       #5 xbus_clock = ~xbus_clock;
-   
-   
+
+
    always
       #10 xserial_tx_clock  = ~xserial_tx_clock;
-   
-   
+
+
    initial
       begin
-         xbus_clock = 1'b1;    
+         xbus_clock = 1'b1;
          xserial_tx_clock = 1'b1;
          xbus_reset = 1'b1;
          base_addr[15:8] = 8'b00000000;
-         #100 xbus_reset = 1'b0; 
+         #100 xbus_reset = 1'b0;
       end
-   
-   
+
+
    xcore xcore(.base_addr(base_addr),
                .xbus_clock(xbus_clock),
                .xbus_reset(xbus_reset),
@@ -78,6 +78,6 @@ module xcore_tb;
                .xserial_rx_data(xserial_rx_data),
                .xserial_tx_clock(xserial_tx_clock),
                .xserial_tx_data(xserial_tx_data));
-   
+
 endmodule // xcore_tb
 
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xcore/v/xcore_in_chan.v b/lesson000X_mluvm_svsc/uvm_examples/xcore/v/xcore_in_chan.v
index 36f9af3..057f78c 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xcore/v/xcore_in_chan.v
+++ b/lesson000X_mluvm_svsc/uvm_examples/xcore/v/xcore_in_chan.v
@@ -1,4 +1,4 @@
-/*--------------------------------------------------------------------------- 
+/*---------------------------------------------------------------------------
 File name   : xcore_in_chan.v
 Title       : XCore input channel
 Project     : XCore SystemVerilog Methodology
@@ -16,7 +16,7 @@ Description : This block provides an XSerial receiver and input FIFO for
             :
             : Central to the design is the fact that the xserial_rx_clock
             : has no relation to the xbus_clock. This means that clock
-            : domain crossing must be correctly implemented so as to 
+            : domain crossing must be correctly implemented so as to
             : avoid metastability. This can be easily achieved because the
             : rate at which frames arrive is significantly slower than the
             : speed of the XBus clock. As each frame arrives, it is latched
@@ -45,7 +45,7 @@ module xcore_in_chan(xbus_clock,
                      flow_ack,
                      xserial_rx_clock,
                      xserial_rx_data);
-   
+
    input    xbus_clock;
    input    xbus_reset;
    output [12:0] frame;
@@ -55,11 +55,11 @@ module xcore_in_chan(xbus_clock,
    output   flow_req;
    output   flow_halt;
    input    flow_ack;
-   
+
    // xserial signals
    input    xserial_rx_clock;
    input    xserial_rx_data;
-   
+
    wire     xbus_clock;
    wire     xbus_reset;
    wire [12:0] frame;
@@ -69,13 +69,13 @@ module xcore_in_chan(xbus_clock,
    wire        flow_req;
    wire        flow_halt;
    wire        flow_ack;
-   
+
    // xserial signals
    wire        xserial_rx_clock;
    wire        xserial_rx_data;
-   
-   
-   
+
+
+
    reg [3:0]   collect_count;
    reg [12:0]  collector;
    reg         collector_valid;
@@ -86,9 +86,9 @@ module xcore_in_chan(xbus_clock,
    reg         rx_frame_valid_cc;
    reg         rx_frame_valid_ccc;
    wire        xbus_frame_valid;
-   
-   
-   
+
+
+
    reg [12:0]  fifo [0:3];
    reg         write_fifo;
    reg [1:0]   write_ptr;
@@ -97,14 +97,14 @@ module xcore_in_chan(xbus_clock,
    reg         flow_req_int;
    reg         flow_halt_int;
 
-`ifdef XCORE_SIM   
+`ifdef XCORE_SIM
 
 // cover FIFO overflow indication
  cover_fifo_overflow : cover property (@(posedge xbus_clock) (write_fifo == 1'b1 |-> ##1 item_count < 3'b100 ));
 
-//Transaction creation for rx_frame   
+//Transaction creation for rx_frame
   trview_rx_frame: cover property (@(posedge xbus_clock) ( ((collect_count == 4'b0000 && xserial_rx_data == 1'b0) ##[1:$] $rose(collector_valid))));
- 
+
 
 //coverage for frame_kind : data, message ( halt ,  resume , idle)
 //message frame
@@ -120,7 +120,7 @@ module xcore_in_chan(xbus_clock,
   cover_rx_mode_data_frame : cover property (@(posedge xbus_clock) (xbus_frame_valid && rx_frame[12] == 1'b0  && rx_frame[3:2] == 2'b00));
 
 `endif
-   
+
    // This process counts the incoming bits from the XSerial RX port
    always @(posedge xserial_rx_clock)
       begin
@@ -143,9 +143,9 @@ module xcore_in_chan(xbus_clock,
                   end // else: !if(collect_count == 4'b0000)
             end // else: !if(xbus_reset == 1'b1)
       end // always@ (posedge xserial_rx_clock)
-  
 
-   
+
+
    // This process collects the incoming frame
    always@(posedge xserial_rx_clock)
       begin
@@ -155,8 +155,8 @@ module xcore_in_chan(xbus_clock,
                collector[12] <= xserial_rx_data;
             end // if (collect_count != 4'b0000)
       end // always@ (posedge xserial_rx_clock)
-   
-   
+
+
    // This process calculates parity on the incoming frame (which should be
    // even).
    always@(posedge xserial_rx_clock)
@@ -170,9 +170,9 @@ module xcore_in_chan(xbus_clock,
                parity <= parity ^ xserial_rx_data;
             end // else: !if(collect_count == 4'b1101)
       end // always@ (posedge xserial_rx_clock)
-   
-   
-   // This process determines when collector contains a valid frame. 
+
+
+   // This process determines when collector contains a valid frame.
    always@(posedge xserial_rx_clock)
       begin
          if (xbus_reset == 1'b1)
@@ -191,8 +191,8 @@ module xcore_in_chan(xbus_clock,
                   end // else: !if(collect_count == 4'b0001)
             end // else: !if(collector_reset == 1'b1)
       end // always@ (posedge xserial_rx_clock)
-   
-    
+
+
    // This process clocks the collected frame into the frame signal. Note that
    // the 13 bits that are latched are the 12 bit payload plus 1 bit that
    // indicates whether the incoming frame had a parity error (1) or not (0).
@@ -203,8 +203,8 @@ module xcore_in_chan(xbus_clock,
                rx_frame <= {parity,collector[11:0]};
             end // if (collector_valid == 1'b1)
       end // always@ (posedge xserial_rx_clock)
-   
-   
+
+
    // This process signals to the XBus clock domain when the frame signal
    // contains a valid frame. Each valid frame is signalled by a change of
    // state of the rx_frame_valid signal.
@@ -222,8 +222,8 @@ module xcore_in_chan(xbus_clock,
                   end // if (collector_valid == 1'b1)
             end // else: !if(xbus_reset == 1'b1)
       end // always@ (posedge xserial_rx_clock)
-   
-   
+
+
    // This process double clocks the rx_frame_valid signal into the XBus clock
    // domain. An version with an additional clock cycle delay is also produced
    // to assist in detecting changes in this signal.
@@ -242,13 +242,13 @@ module xcore_in_chan(xbus_clock,
                rx_frame_valid_ccc <= rx_frame_valid_cc;
             end // else: !if(xbus_reset == 1'b1)
       end // always@ (posedge xbus_clock)
-   
-           
-   
+
+
+
    // This signal is high whenever there is a change on rx_frame_valid_cc
    assign xbus_frame_valid = rx_frame_valid_cc ^ rx_frame_valid_ccc;
-   
-   
+
+
    // This process handles received HALT and RESUME messages and drives the
    // halted signal to the TX path.
    always@(posedge xbus_clock)
@@ -258,17 +258,17 @@ module xcore_in_chan(xbus_clock,
                halted <= 1'b0;
             end // if (xbus_reset == 1'b1)
          else
-            begin                                       
-              if((xbus_frame_valid == 1'b1) 
+            begin
+              if((xbus_frame_valid == 1'b1)
                  && (rx_frame[12] == 1'b0)  // Not bad parity
                  && (rx_frame[4:2] == 3'b101)) // HALT MESSAGE frame
-                 
+
                   begin
                      halted <= 1'b1;
                   end // if ((xbus_frame_valid == 1'b1) && (rx_frame == 13'b0000000000101))
                else
                   begin
-                    if( (xbus_frame_valid == 1'b1) 
+                    if( (xbus_frame_valid == 1'b1)
                         &&  (rx_frame[12] == 1'b0)  // Not bad parity
                         && (rx_frame[4:2] == 3'b001)) // RESUME MESSAGE frame
                       begin
@@ -277,9 +277,9 @@ module xcore_in_chan(xbus_clock,
                   end // else: !if((xbus_frame_valid == 1'b1) && (rx_frame == 13'b0000000000101))
             end // else: !if(xbus_reset == 1'b1)
       end // always@ (posedge xbus_clock)
-   
-                  
-   
+
+
+
    // This process determines when a non-message frame has been received and
    // needs to be written to the FIFO.
    always@(xbus_frame_valid or rx_frame)
@@ -293,9 +293,9 @@ module xcore_in_chan(xbus_clock,
                write_fifo <= 1'b0;
             end // else: !if((xbus_frame_valid == 1'b1) && (rx_frame[3:2] != 2'b01))
       end // always@ (xbus_fram_valid or rx_frame)
-   
-   
-   // This process handles the write side of the FIFO. 
+
+
+   // This process handles the write side of the FIFO.
    always@(posedge xbus_clock)
       begin
          if (xbus_reset == 1'b1)
@@ -311,12 +311,12 @@ module xcore_in_chan(xbus_clock,
                   end // if (write_fifo == 1'b1)
             end // else: !if(xbus_reset == 1'b1)
       end // always@ (posedge xbus_clock)
-   
-                     
-   
+
+
+
    // The output of this block is the next item in the FIFO
    assign  frame = fifo[read_ptr];
-   
+
    // This process handles the read pointer for the FIFO
    always@(posedge xbus_clock)
       begin
@@ -332,11 +332,11 @@ module xcore_in_chan(xbus_clock,
                   end // if (read_fifo == 1'b1)
             end // else: !if(xbus_reset == 1'b1)
       end // always@ (posedge xbus_clock)
-   
-   
-   
-  
- 
+
+
+
+
+
    // This process keeps track of how many items are currently in the FIFO.
    always@(posedge xbus_clock)
       begin
@@ -359,9 +359,9 @@ module xcore_in_chan(xbus_clock,
                   end // else: !if((write_fifo == 1'b1) && (read_fifo == 1'b0))
             end // else: !if(xbus_reset == 1'b1)
       end // always@ (posedge xbus_clock)
-   
-   
-   
+
+
+
    // This process determines whether the FIFO has valid data in it or not.
    always@(item_count)
       begin
@@ -374,9 +374,9 @@ module xcore_in_chan(xbus_clock,
                frame_valid <= 1'b1;
             end // else: !if(item_count == 4'b0000)
       end // always@ (item_count)
-   
-         
-    
+
+
+
    // This process determines when there is a possibility that the
    // FIFO could overflow and generates requests for flow control messages
    // to prevent this. Note that after a flow control HALT message is sent,
@@ -442,7 +442,7 @@ module xcore_in_chan(xbus_clock,
                   end // else: !if((write_fifo == 1'b1) && (read_fifo == 1'b0) && (item_count == 3'b001))
             end // else: !if(xbus_reset == 1'b1)
       end // always@ (posedge xbus_clock)
-   
+
    assign flow_req = flow_req_int;
    assign flow_halt = flow_halt_int;
 endmodule // xcore_in_chan
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xcore/v/xcore_no_ovl.v b/lesson000X_mluvm_svsc/uvm_examples/xcore/v/xcore_no_ovl.v
index 63297cb..5ae2518 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xcore/v/xcore_no_ovl.v
+++ b/lesson000X_mluvm_svsc/uvm_examples/xcore/v/xcore_no_ovl.v
@@ -1,4 +1,4 @@
-//--------------------------------------------------------------------------- 
+//---------------------------------------------------------------------------
 //File name   : xcore.v
 //Title       : Verilog block providing an XBus to XSerial gateway
 //Project     : XCore eVC
@@ -18,56 +18,56 @@
 //            : reads and writes are zero wait state.
 //            :
 //            : The four registers are:
-//            : 
+//            :
 //            : XSerial TX data register (offset 0)
 //            :    Writing a byte to this register causes that byte to be
 //            :    transmitted on the XSerial port. It is illegal to write
 //            :    to this register without first reading from it and getting
 //            :    bit 0 = 0. Attempting to do this results in a bus error.
-//            :    Reading this register returns a flag in bit 0 (all other 
-//            :    bits return 0). If the flag is 1, then the port is busy and 
-//            :    a further byte cannot yet be sent. If the flag is 0, then 
-//            :    the port is not busy and it is safe to write to this 
+//            :    Reading this register returns a flag in bit 0 (all other
+//            :    bits return 0). If the flag is 1, then the port is busy and
+//            :    a further byte cannot yet be sent. If the flag is 0, then
+//            :    the port is not busy and it is safe to write to this
 //            :    register.
-//            : 
+//            :
 //            : XSerial TX mode register (offset 1)
-//            :    Bits 0-1 of this register form the Destination address of 
+//            :    Bits 0-1 of this register form the Destination address of
 //            :    subsequently transmitted frames.
-//            :    Bits 2-3 of this register form the frame_kind of 
+//            :    Bits 2-3 of this register form the frame_kind of
 //            :    subsequently transmitted frames.
-//            :    Bits 4-7 are unused and return 0 on reads. They should 
+//            :    Bits 4-7 are unused and return 0 on reads. They should
 //            :    always be written as 0 for future compatibility
 //            :    This register can be written to and read from.
 //            :
 //            : XSerial RX data register (offset 2)
-//            :    If bit 5 of register 3 is 1, then reading this register 
-//            :    returns the least significant 8 bits of the frame payload. 
-//            :    It is illegal to read this register without first reading 
-//            :    the RX mode register and getting bit 5 = 1. Attempting to 
+//            :    If bit 5 of register 3 is 1, then reading this register
+//            :    returns the least significant 8 bits of the frame payload.
+//            :    It is illegal to read this register without first reading
+//            :    the RX mode register and getting bit 5 = 1. Attempting to
 //            :    do this results in a bus error.
 //            :    Reading this register causes the information in both this
-//            :    register and in register 3 to be discarded and also causes 
+//            :    register and in register 3 to be discarded and also causes
 //            :    bit 5 of register 3 to be cleared to 0. When the next frame
-//            :    is received, both registers will be updated with the new 
-//            :    frame information and bit 5 of register 3 will be set to 1 
+//            :    is received, both registers will be updated with the new
+//            :    frame information and bit 5 of register 3 will be set to 1
 //            :    again.
 //            :    Writing to this register causes a bus error.
 //            :
 //            : XSerial RX mode register (offset 3)
-//            :    Bits 0-1 of this register form the Destination address of 
+//            :    Bits 0-1 of this register form the Destination address of
 //            :    the most recently received frame.
 //            :    Bits 2-3 of this register form the Frame_kind of the most
 //            :    recently received frame.
-//            :    Bit 4 of this register is 1 if the most recently received 
+//            :    Bit 4 of this register is 1 if the most recently received
 //            :    frame has a parity error or 0 if it does not.
-//            :    Bit 5 of this register is 1 if registers 2 and 3 contain a 
+//            :    Bit 5 of this register is 1 if registers 2 and 3 contain a
 //            :    valid frame.
 //            :    Bits 6-7 are unused and return 0 on reads.
 //            :    Writing to this register causes a bus error.
 //Notes       : xserial_rx_clock and xserial_tx_clock should run at the same
 //            : nominal frequency. This nominal frequency should be not
 //            : greater than the nominal frequency of the xbus_clock signal.
-//--------------------------------------------------------------------------- 
+//---------------------------------------------------------------------------
 //Copyright (c) 2005-2010 Cadence Design Systems,Inc.
 // All rights reserved worldwide
 //(Acquired from Verisity Design,Inc.,2005).
@@ -81,7 +81,7 @@ module xcore(base_addr,
              xbus_clock,
              xbus_reset,
              xbus_start,
-	     xbus_request,	
+	     xbus_request,
 	     xbus_grant,
              xbus_addr,
              xbus_size,
@@ -95,7 +95,7 @@ module xcore(base_addr,
              xserial_rx_data,
              xserial_tx_clock,
              xserial_tx_data);
-   
+
    input [15:8]base_addr;
    input       xbus_clock;
    input       xbus_reset;
@@ -114,11 +114,11 @@ module xcore(base_addr,
    input        xserial_rx_data;
    input        xserial_tx_clock;
    output       xserial_tx_data;
-   
+
    wire [7:0]   xbus_data;
-   
-   
-   
+
+
+
    wire [15:8]  base_addr;
    wire       xbus_clock;
    wire       xbus_reset;
@@ -138,11 +138,11 @@ module xcore(base_addr,
    wire         xserial_tx_clock;
    wire         xserial_tx_data;
    assign xbus_data = xcore_xbus_data;
-   
-   
-   
-   
-   
+
+
+
+
+
    // RX interface signals
    wire [12:0]  rx_frame; // Next item in RX FIFO
    wire         rx_frame_valid; // high if RX FIFO contains frames
@@ -152,22 +152,22 @@ module xcore(base_addr,
    wire         flow_req; // high if need to send message to remote end of link
    wire         flow_halt; // high if required message is HALT, low for RESUME
    wire         flow_ack; // high to acknowledge that message has been sent
-   
+
    // TX interface signals
    reg [11:0]   tx_frame; // the frame to be transmitted
    wire         tx_frame_req;
    wire         tx_frame_ack; // indicates frame sent.
-   
+
    // XBus decode signals
    reg          xbus_start_c;
    reg          xbus_selected;
    wire         xbus_reg;
-  
+
    reg          xbus_reg0;
    reg          xbus_reg1;
    reg          xbus_reg2;
    reg          xbus_reg3;
-   
+
    reg          xbus_reg_c;
    reg          xbus_reg0_c ;
    reg          xbus_reg1_c;
@@ -190,9 +190,9 @@ module xcore(base_addr,
    reg          tx_data_req;
    reg          tx_write_safe; // high if a write to tx_data_reg is safe
    reg          rx_read_safe;  // high if a read from rx_data_reg is safe
-   
-   
-   
+
+
+
    xcore_in_chan in_chan_inst(.xbus_clock(xbus_clock),
                            .xbus_reset(xbus_reset),
                            .frame(rx_frame),
@@ -204,7 +204,7 @@ module xcore(base_addr,
                            .flow_ack(flow_ack),
                            .xserial_rx_clock(xserial_rx_clock),
                            .xserial_rx_data(xserial_rx_data));
-   
+
    xcore_out_chan out_chan_inst(.xbus_clock(xbus_clock),
                              .xbus_reset(xbus_reset),
                              .frame(tx_frame),
@@ -213,11 +213,11 @@ module xcore(base_addr,
                              .halted(halted),
                              .xserial_tx_clock(xserial_tx_clock),
                              .xserial_tx_data(xserial_tx_data));
-   
+
    // If we have requested a frame be sent and the handshaking across the
    // clock domains has not yet finished, then the TX port is busy.
    assign tx_busy = tx_frame_req | tx_frame_ack;
-   
+
 
    always@(posedge xbus_clock)
       begin
@@ -230,12 +230,12 @@ module xcore(base_addr,
                xbus_start_c <= xbus_start;
             end // else: !if(xbus_reset == 1'b1)
       end // always@ (posedge xbus_clock)
-   
-         
-    
+
+
+
    // This process determines whether the current XBus address selects this
    // instance of the XCore.
-   
+
    always@(xbus_addr or base_addr)
       begin
          if(xbus_addr[15:8] == base_addr[15:8])
@@ -247,9 +247,9 @@ module xcore(base_addr,
                xbus_selected <= 1'b0;
             end // else: !if(xbus_addr[15:8] == base_addr[15:8])
       end // always@ (xbus_addr or base_addr)
-   
-   
-   
+
+
+
    // This process ensures that the xbus_wait signal is driven low (i.e. no
    // wait states are inserted) at the correct point of the transfer.
    always@(posedge xbus_clock)
@@ -260,7 +260,7 @@ module xcore(base_addr,
             end // if (xbus_reset == 1'b1)
          else
             begin
-               if((xbus_start_c == 1'b1) && (xbus_selected == 1'b1) && 
+               if((xbus_start_c == 1'b1) && (xbus_selected == 1'b1) &&
                   ((xbus_read == 1'b1)||(xbus_write == 1'b1)))
                   begin
                      xbus_wait <= 1'b0;
@@ -271,8 +271,8 @@ module xcore(base_addr,
                   end // else: !if((xbus_start_c == 1'b1) && (xbus_selected == 1'b1) &&...
             end // else: !if(xbus_reset == 1'b1)
       end // always@ (posedge xbus_clock)
-   
-   
+
+
    // xbus_reg is high in the address phase of any transfer directed at this
    // XCore instance.
    //always@(xbus_start_c or xbus_selected or xbus_read or xbus_write)
@@ -286,14 +286,14 @@ module xcore(base_addr,
         //       xbus_reg <=1'b0;
         //    end // else: !if((xbus_start_c == 1'b1) && (xbus_selected == 1'b1) && ((xbus_read === 1'b1) || (xbus_write === 1'b1)))
       //end // always@ (xbus_start_c or xbus_selected or xbus_read or xbus_write)
-   
+
    assign xbus_reg = xbus_start_c & xbus_selected & (xbus_read | xbus_write);
-   
-    
+
+
    // This process further decodes the address signals to determine if any of
    // the four internal registers are selected.
-   
-   
+
+
    always@(xbus_addr)
       begin
          if (xbus_addr[7:0] == 8'b00000000)
@@ -329,12 +329,12 @@ module xcore(base_addr,
                xbus_reg3 <= 1'b0;
             end // else: !if(xbus_addr[7:0] == 8'b00000011)
       end // always@ (xbus_addr)
-   
-   
-    
+
+
+
    // This process provides delayed versions of the various register signals
    // and the write signal that are valid in the data phase.
-  
+
    always@(posedge xbus_clock)
       begin
          if (xbus_reset == 1'b1)
@@ -356,15 +356,15 @@ module xcore(base_addr,
                xbus_write_c <= xbus_write;
             end // else: !if(xbus_reset == 1'b1)
       end // always@ (posedge xbus_clock)
-   
-    
+
+
    // This process determines if the transfer should return a bus error.
    // Possible errors are: size of transfer is larger than 1 byte; block
    // is selected but address does not select one of the four registers;
    // an attempt to write to register 0 when it is busy; a write to
    // register 2 or 3; Attempt to read register 2 when there is no valid
    // frame to be read.
-   
+
    always@(posedge xbus_clock)
       begin
          if (xbus_reset == 1'b1)
@@ -395,7 +395,7 @@ module xcore(base_addr,
                                     end // if ((xbus_reg0 == 1'b1) && (xbus_write == 1'b1)...
                                  else
                                     begin
-                                       if (((xbus_reg2 == 1'b1) || (xbus_reg3 == 1'b1)) 
+                                       if (((xbus_reg2 == 1'b1) || (xbus_reg3 == 1'b1))
                                            && (xbus_write == 1'b1))
                                           begin
                                              xbus_error_internal <= 1'b1;
@@ -422,17 +422,17 @@ module xcore(base_addr,
                   end // else: !if(xbus_reg == 1'b1)
             end // else: !if(xbus_reset == 1'b1)
       end // always@ (posedge xbus_clock)
-   
-                     
-   
-   
-   
-   
-   
-   
-   
-   
-   
+
+
+
+
+
+
+
+
+
+
+
    // This process drives the xbus_error signal at the appropriate point
    // in the transfer.
    always@(xbus_reset or xbus_reg_c or xbus_error_internal)
@@ -453,10 +453,10 @@ module xcore(base_addr,
                   end // else: !if(xbus_reg_c == 1'b1)
             end // else: !if(xbus_reset == 1'b1)
       end // always (xbus_reset or xbus_reg_c or xbus_error_internal)
-   
-   
-   
-    
+
+
+
+
    // This process drives the data bus on reads.
    always@(posedge xbus_clock)
       begin
@@ -487,7 +487,7 @@ module xcore(base_addr,
                               end // if ((xbus_start_c == 1'b1) && (xbus_selected == 1'b1) && (xbus_reg2 == 1'b1)...
                            else
                               begin
-                                 if((xbus_start_c == 1'b1) && (xbus_selected == 1'b1) && (xbus_reg3 == 1'b1) 
+                                 if((xbus_start_c == 1'b1) && (xbus_selected == 1'b1) && (xbus_reg3 == 1'b1)
                                     && (xbus_read == 1'b1))
                                     begin
                                        if(rx_frame_valid == 1'b1)
@@ -529,7 +529,7 @@ module xcore(base_addr,
                   end // if ((xbus_reg2_c == 1'b1) && (xbus_write_c == 1'b0) &&...
                else
                   begin
-                     if ((xbus_reg3_c == 1'b1) && (xbus_write_c == 1'b0) && 
+                     if ((xbus_reg3_c == 1'b1) && (xbus_write_c == 1'b0) &&
                          (xbus_error_internal == 1'b0) && (rx_frame_valid_c == 1'b1))
                         begin
                            rx_read_safe <= 1'b1;
@@ -537,8 +537,8 @@ module xcore(base_addr,
                   end // else: !if((xbus_reg2_c == 1'b1) && (xbus_write_c == 1'b0) &&...
             end // else: !if(xbus_reset == 1'b1)
       end // always@ (posedge xbus_clock)
-   
-   
+
+
    // This process determines when a frame is read from the input channel FIFO
    always@(posedge xbus_clock)
       begin
@@ -559,8 +559,8 @@ module xcore(base_addr,
                   end // else: !if((xbus_reg2_c == 1'b1) && (xbus_write_c == 1'b0) &&...
             end // else: !if(xbus_reset == 1'b1)
       end // always@ (posedge xbus_clock)
-   
-   
+
+
    // This process implements writes to register 1.
    always@(posedge xbus_clock)
       begin
@@ -577,8 +577,8 @@ module xcore(base_addr,
                   end // if ((xbus_reg1_c == 1'b1) && (xbus_write_c == 1'b1)...
             end // else: !if(xbus_reset == 1'b1)
       end // always@ (posedge xbus_clock)
-   
-   
+
+
    // This process determines when a write to register 0 has happened.
    always@(xbus_reg0_c or xbus_write_c or xbus_error_internal)
       begin
@@ -592,8 +592,8 @@ module xcore(base_addr,
                write_tx_data <= 1'b0;
             end // else: !if((xbus_reg0_c == 1'b1) && (xbus_write_c == 1'b1)...
       end // always@ (xbus_reg0_c or xbus_write_c or xbus_error_internal)
-   
-   
+
+
    // This process determines when it is safe to write to the TX_DATA register and when this
    // would generate a bus error.
    always@(posedge xbus_clock)
@@ -612,7 +612,7 @@ module xcore(base_addr,
                   end // if (write_tx_data == 1'b1)
                else
                   begin
-                     if ((xbus_reg0_c == 1'b1) && (xbus_write_c == 1'b0) && 
+                     if ((xbus_reg0_c == 1'b1) && (xbus_write_c == 1'b0) &&
                          (xbus_error_internal == 1'b0) && (tx_busy_reg_c == 1'b0))
                         begin
                            tx_write_safe <= 1'b1;
@@ -637,10 +637,10 @@ module xcore(base_addr,
                   end // if (write_tx_data == 1'b1)
             end // else: !if(xbus_reset == 1'b1)
       end // always@ (posedge xbus_clock)
-   
-         
-               
-   
+
+
+
+
    // This process determines when we need to send a flow control message.
    // These take priority over all other frames.
    always@(flow_req or tx_busy)
@@ -654,12 +654,12 @@ module xcore(base_addr,
                flow <= 1'b0;
             end // else: !if((flow_req == 1'b1) && (tx_busy == 1'b0))
       end // always@ (flow_req or tx_busy)
-   
-   
+
+
    // Make sure we acknowledge that the flow control message has been sent.
    assign flow_ack = flow;
-   
-   
+
+
    // This process keeps track of any data sends that have been pre-empted
    // by a flow control request. These get send after the flow control message
    // has been sent.
@@ -679,16 +679,16 @@ module xcore(base_addr,
                   begin
                      if ((tx_pend == 1'b1) && (tx_busy == 1'b0) && (flow == 1'b0))
                         begin
-                           // Following line change May 2007 - It used to be 
+                           // Following line change May 2007 - It used to be
                            // set to 1, I modified to 0. efrat
                            tx_pend <= 1'b0;
                         end
                   end // else: !((write_tx_data == 1'b1) && ((tx_busy == 1'b1) || (flow == 1'b1))
             end // else: !if(xbus_reset == 1'b1)
       end // always@ (posedge xbus_clock)
-   
-                           
-   
+
+
+
    // This process creates HALT and RESUME requests to the output channel as
    // required.
    always@(posedge xbus_clock)
@@ -721,9 +721,9 @@ module xcore(base_addr,
                   end // else: !if((flow == 1'b1) && (flow_halt == 1'b1))
             end // else: !if(xbus_reset == 1'b1)
       end // always@ (posedge xbus_clock)
-   
-                           
-   
+
+
+
    // This process ensures that writes to register 0 cause the output channel
    // to be kicked into play.
    always@(posedge xbus_clock)
@@ -754,18 +754,18 @@ module xcore(base_addr,
                   end // else: !if ((write_tx_data == 1'b1) && (tx_busy == 1'b0) && (flow == 1'b0))
             end // else: !if(xbus_reset == 1'b1)
       end // always@ (posedge xbus_clock)
-   
-   
+
+
    // XBus should see 'busy' if either the TX channel is busy or we have a data
    // frame pending.
    assign tx_busy_reg = tx_busy | tx_pend;
-   
-  
+
+
    // If either a flow message or a data frame needs to be sent, inform the TX
    // channel.
    assign tx_frame_req = tx_halt_req | tx_resume_req | tx_data_req;
-   
-         
+
+
    // This process decides whether user data or flow control messages get sent
    // to the output channel.
    always@(tx_halt_req or tx_resume_req or tx_data_reg or tx_mode_reg)
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xcore/v/xcore_out_chan.v b/lesson000X_mluvm_svsc/uvm_examples/xcore/v/xcore_out_chan.v
index bb058ee..f3370b7 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xcore/v/xcore_out_chan.v
+++ b/lesson000X_mluvm_svsc/uvm_examples/xcore/v/xcore_out_chan.v
@@ -1,4 +1,4 @@
-/*--------------------------------------------------------------------------- 
+/*---------------------------------------------------------------------------
 File name   : xcore_out_chan.v
 Title       : XCore output channel
 Project     : XCore eVC
@@ -22,49 +22,49 @@ module  xcore_out_chan(xbus_clock,
                        halted,
                        xserial_tx_clock,
                        xserial_tx_data);
-   
+
    input xbus_clock;
    input xbus_reset;
    input [11:0] frame ; // the frame to be transmitted
    input        frame_req; // held high to send frame until frame_ack goes high
    output       frame_ack; // indicates frame sent.
    input        halted; // high if HALT message has been received
-   
-   
+
+
    input        xserial_tx_clock;
    output       xserial_tx_data;
-   
-   
+
+
    wire         xbus_clock;
    wire         xbus_reset;
    wire [11:0]  frame ; // the frame to be transmitted
    wire         frame_req; // held high to send frame until frame_ack goes high
    reg          frame_ack; // indicates frame sent.
    wire         halted; // high if HALT message has been received
-   
-   
+
+
    wire         xserial_tx_clock;
    reg          xserial_tx_data;
-   
+
    reg          frame_req_c;
    reg          frame_req_cc;
    reg          latch_frame;
    reg          frame_done;
    reg          frame_done_c;
-   
+
    reg [14:0]   shift_reg;
    reg [3:0]    drive_count;
    reg          parity;
 
 `ifdef XCORE_SIM
-//Transaction creation for tx_frame   
+//Transaction creation for tx_frame
 trview_tx_frame: cover property (
      @(posedge xbus_clock) (
                    $rose(frame_ack) ##[1:$] $rose(drive_count == 4'b0000)));
 
 `endif
-   
-   
+
+
    // This process crosses the frame request signal into the XSerial TX cloock
    // domain.
    always@(posedge xserial_tx_clock)
@@ -80,10 +80,10 @@ trview_tx_frame: cover property (
                frame_req_c <= frame_req;
             end // else: !if(xbus_reset == 1'b1)
       end // always@ (posedge xserial_tx_clock)
-   
-         
-        
-   
+
+
+
+
    // This process determines if a new request to send a frame has been
    // received and the shift register is ready to send the next frame.
    always@(frame_req_cc or frame_done or drive_count or halted)
@@ -98,8 +98,8 @@ trview_tx_frame: cover property (
                latch_frame <= 1'b0;
             end // else: !if((frame_req_cc == 1'b1) && (frame_done == 1'b0) && (drive_count == 4'b0000)...
       end // always@ (frame_req_cc or frame_done or drive_count or halted)
-   
-    
+
+
    // This process generates the frame_done signal which indicates that the
    // frame has been latched into the shift register but the core hasn't yet
    // de-asserted frame_req.
@@ -124,8 +124,8 @@ trview_tx_frame: cover property (
                   end // else: !if(latch_frame == 1'b1)
             end // else: !if(xbus_reset == 1'b1)
       end // always@ (posedge xserial_tx_clock)
-   
-   
+
+
    // This process double clocks the frame_done signal into the XBus clock
    // domain to form the frame_ack signal.
    always@(posedge xbus_clock)
@@ -141,10 +141,10 @@ trview_tx_frame: cover property (
                frame_done_c <= frame_done;
             end // else: !if(xbus_reset == 1'b1)
       end // always@ (posedge xbus_clock)
-   
-               
-               
-   
+
+
+
+
    // This process counts the bits sent to the output port.
    always@(posedge xserial_tx_clock)
       begin
@@ -167,7 +167,7 @@ trview_tx_frame: cover property (
                   end // else: !if(latch_frame == 1'b1)
             end // else: !if(xbus_reset == 1'b1)
       end // always@ (posedge xserial_tx_clock)
-   
+
    // This process shifts the bits to form the serial frame.
    always@(posedge xserial_tx_clock)
       begin
@@ -188,9 +188,9 @@ trview_tx_frame: cover property (
                   end // else: !if(latch_frame == 1'b1)
             end // else: !if(xbus_reset == 1'b1)
       end // always@ (posedge xserial_tx_clock)
-   
-                 
-         
+
+
+
 
    // This process calculates the parity as the frame is shifted out.
    always@(posedge xserial_tx_clock)
@@ -211,8 +211,8 @@ trview_tx_frame: cover property (
                   end // else: !if(drive_count == 4'b1110)
             end // else: !if(xbus_reset == 1'b1)
       end // always@ (posedge xserial_tx_clock)
-   
-   
+
+
    // This process inserts the parity into the outgoing serial data stream.
    always@(posedge xserial_tx_clock)
       begin
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xserial/demo.sh b/lesson000X_mluvm_svsc/uvm_examples/xserial/demo.sh
index 6f16931..723c3a9 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xserial/demo.sh
+++ b/lesson000X_mluvm_svsc/uvm_examples/xserial/demo.sh
@@ -2,7 +2,7 @@
 #!/bin/sh -v
 #
 # Script for running xserial demo
-# 
+#
 #   demo.sh mti|vcs|nc[sim]|xl verilog|vhdl
 # =============================================================================
 
@@ -27,8 +27,8 @@ vlg_hdl_files="$xserial_path/v/*.v"
 vhd_hdl_files="$xserial_path/vhdl/in_chan.vhd $xserial_path/vhdl/out_chan.vhd $xserial_path/vhdl/dut.vhd $xserial_path/vhdl/tb_xserial.vhd"
 debussy_do_file="$package_path/examples/debussy_cmd.txt"
 mti_do_file="$package_path/examples/sv.do"
-nc_do_file="$package_path/examples/nc.i"      
-vcs_do_file="$package_path/examples/vcs.i"    
+nc_do_file="$package_path/examples/nc.i"
+vcs_do_file="$package_path/examples/vcs.i"
 vtop="xserial_evc_demo"
 #----------------------------------------------------------------------
 
@@ -90,7 +90,7 @@ while [ $# -gt 0 ]; do
                         shift
                         ;;
       esac
-	shift       
+	shift
 done
 
 
@@ -99,7 +99,7 @@ do_file="$nc_do_file"
 
 if [ -n "$run_file" ]; then
    cat $do_file > sim_cmd.txt
-   cat $run_file >> sim_cmd.txt 
+   cat $run_file >> sim_cmd.txt
    do_file="sim_cmd.txt"
 fi
 
@@ -109,7 +109,7 @@ hdl_files="$vlg_hdl_files"
 if [ $run_mode = batch ]; then
     gui_flag=""
     echo "run"  >> ./ncsim_run.tcl
-    echo "exit" >> ./ncsim_run.tcl 
+    echo "exit" >> ./ncsim_run.tcl
 
 fi
 
@@ -125,7 +125,7 @@ demo_file=`sn_which.sh $package_path/examples/$demo_file`
     $tcl_flag \
     -nosncomp \
     -input ./ncsim_run.tcl \
-    -defineall SPECMAN_INCLUDED 
+    -defineall SPECMAN_INCLUDED
 
 
 
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xserial/e/xserial_agent.e b/lesson000X_mluvm_svsc/uvm_examples/xserial/e/xserial_agent.e
index b847bdd..5f3b8b9 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xserial/e/xserial_agent.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xserial/e/xserial_agent.e
@@ -1,15 +1,15 @@
-/*------------------------------------------------------------------------- 
+/*-------------------------------------------------------------------------
 File name   : xserial_agent.e
 Title       : Agent unit implementation
 Project     : XSerial eVC
 Created     : 2008
 Description : This file contains all the fields and methods of the agent
-            : unit that are not exposed to the user. 
-Notes       : 
---------------------------------------------------------------------------- 
+            : unit that are not exposed to the user.
+Notes       :
+---------------------------------------------------------------------------
 Copyright (c) 2008-2010 Cadence Design Systems,Inc.
   All rights reserved worldwide
--------------------------------------------------------------------------*/ 
+-------------------------------------------------------------------------*/
 
 <'
 
@@ -21,13 +21,13 @@ extend xserial_agent_u {
     -- This field indicates whether there is a reset signal in the DUT
     has_reset : bool;
         keep soft has_reset == TRUE;
-        
+
     -- Ensure that the reset_asserted field is kept up-to-date.
-    on reset_start { 
+    on reset_start {
         reset_asserted = TRUE;
         message(LOW, "Reset was asserted");
     };
-    on reset_end { 
+    on reset_end {
         reset_asserted = FALSE;
         message(LOW, "Reset was de-asserted");
     };
@@ -35,17 +35,17 @@ extend xserial_agent_u {
     -- This method gets called whenever reset is re-asserted during a test.
     -- It performs all actions necessary to get this instance of the eVC
     -- back into a reset state.
-    
+
     -- This method returns a string that indicates context. It is used
     -- during error reporting.
     package error_header() : string is {
         result = append("XSerial eVC, Agent: ", name);
     }; -- err_header()
-    
+
     -- This method reports the current status of the agent.
     show_status() is empty;
-    
-    
+
+
 }; -- extend xserial_agent_u
 
 
@@ -61,7 +61,7 @@ extend has_reset xserial_agent_u {
     event reset_end  is only
         true(reset_asserted and
              (sig_reset$ != reset_active_level)) @reset_change;
-    
+
 }; -- extend has_reset xserial_agent_u
 
 
@@ -71,7 +71,7 @@ extend has_tx_path xserial_agent_u {
     show_status() is also {
         tx_monitor.show_status();
     }; -- show_status()
-    
+
 }; -- extend has_tx_path xserial_agent_u
 
 
@@ -89,18 +89,18 @@ extend ACTIVE has_tx_path xserial_agent_u {
 
     private connect_driver_clock() @tx_monitor.clock_rise is {
         while TRUE {
-            emit tx_driver.clock; 
+            emit tx_driver.clock;
             wait cycle;
         };
     }; -- connect_driver_clock()
-    
+
     run() is also {
         start connect_driver_clock();
     }; -- run()
 
 
     -- Rerun TX BFM if reset gets re-asserted during the test.
-        
+
     -- ACTIVE agents with a TX path also have the optional ability to
     -- generate the clock.
     private drive_clock() @sys.any is {
@@ -113,7 +113,7 @@ extend ACTIVE has_tx_path xserial_agent_u {
             wait delay (tx_clock_period - half_period);
         };
     }; -- drive_clock()
-    
+
     -- If enabled, then the clock generator should start at time zero
     -- and not be affected by reset (which is why this code is in the
     -- agent not the BFM - the BFM gets rerun() during a reset, whereas
@@ -134,7 +134,7 @@ extend ACTIVE has_tx_path xserial_agent_u {
 
 <'
 extend xserial_agent_u {
-    
+
     // configure
     configure(ctr : uint, new_params : xserial_agent_config_params) is {
         config.params = new_params.copy();
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xserial/e/xserial_agent_h.e b/lesson000X_mluvm_svsc/uvm_examples/xserial/e/xserial_agent_h.e
index ce743b7..472c1da 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xserial/e/xserial_agent_h.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xserial/e/xserial_agent_h.e
@@ -1,4 +1,4 @@
-/*------------------------------------------------------------------------- 
+/*-------------------------------------------------------------------------
 File name   : xserial_agent_h.e
 Title       : Agent unit public interface
 Project     : XSerial eVC
@@ -7,11 +7,11 @@ Description : This file declares the public interface of the agent unit.
 Notes       : Because the agent handles both the TX and RX parts of a link,
             : the 'has_tx_path' and 'has_rx_path' fields are used to
             : sub-type the agent so that the TX and RX paths can be
-            : separately disabled. 
---------------------------------------------------------------------------- 
+            : separately disabled.
+---------------------------------------------------------------------------
 Copyright (c) 2008-2010 Cadence Design Systems,Inc.
   All rights reserved worldwide
-------------------------------------------------------------------------*/ 
+------------------------------------------------------------------------*/
 
 <'
 
@@ -23,7 +23,7 @@ package cdn_xserial;
 unit xserial_agent_u like uvm_agent {
     tf_testflow_unit;
 
-    // This unit, and all other units under it, are part of the 
+    // This unit, and all other units under it, are part of the
     // XSERIAL_TF domain
     keep soft tf_domain == XSERIAL_TF;
 
@@ -36,7 +36,7 @@ unit xserial_agent_u like uvm_agent {
     -- This field holds the logical name of the eVC instance this agent is
     -- contained in
     name : xserial_env_name_t;
-        
+
     -- This field holds the signal name of the TX_CLOCK signal on the
     -- XSERIAL interface.
     sig_tx_clock : out simple_port of bit is instance;
@@ -52,26 +52,26 @@ unit xserial_agent_u like uvm_agent {
     -- This field holds the signal name of the RX_DATA signal on the
     -- XSERIAL interface.
     sig_rx_data  :  out simple_port of bit is instance;
-    
+
     -- This field holds the signal name of the RESET signal on the XSERIAL
-    -- interface. 
+    -- interface.
     sig_reset : inout simple_port of bit is instance;
-    
-    -- This field controls the active level of the RESET signal. 
-    -- By default, the reset is active high, but by constraining this 
+
+    -- This field controls the active level of the RESET signal.
+    -- By default, the reset is active high, but by constraining this
     -- field to 0, it can be set to active low.
     reset_active_level : bit;
         keep soft reset_active_level == 1;
-    
+
     -- This field determines what reset state the eVC starts in at the
     -- beginning of a test. By default, the eVC assumes that reset is
-    -- asserted at the start of a test. The reset_asserted field goes to 
-    -- FALSE at the first de-assertion of the reset signal. 
+    -- asserted at the start of a test. The reset_asserted field goes to
+    -- FALSE at the first de-assertion of the reset signal.
     reset_asserted : bool;
         keep soft reset_asserted == TRUE;
-    
+
     keep soft active_passive == ACTIVE;
-        
+
 
     -- If this field is TRUE then the agent does protocol checking on the
     -- tx_data signal.
@@ -83,22 +83,22 @@ unit xserial_agent_u like uvm_agent {
     check_rx_protocol : bool;
         keep soft check_rx_protocol == TRUE;
 
-    -- This field controls whether coverage information should be 
+    -- This field controls whether coverage information should be
     -- collected for this agent
     has_coverage : bool;
         keep soft has_coverage == TRUE;
-    
+
 
     -- This field controls the period of the TX clock in simulator time
     -- units. If this field is 0, then the eVC does not generate the clock.
     -- Note that this field is only used if the agent is ACTIVE and has a
-    -- tx path. It is recommended that this field be constrained using 
+    -- tx path. It is recommended that this field be constrained using
     -- physical time units
     -- e.g.: keep tx_clock_period == 20 ns; This ensures that there is no
     -- dependency on the simulator time resolution.
     tx_clock_period : time;
         keep soft tx_clock_period == 0;
-                                    
+
     -- If this field is not "" then the agent writes a log file of that
     -- name with a .elog extension. This log file contains all TX
     -- transactions. If both this field and rx_log_filename are the
@@ -106,7 +106,7 @@ unit xserial_agent_u like uvm_agent {
     -- single file.
     tx_log_filename : string;
         keep soft tx_log_filename == "xserial";
-        
+
     -- If this field is not "" then the agent writes a log file of that
     -- name with a .elog extension. This log file contains all RX
     -- transactions. If both this field and tx_log_filename are the
@@ -114,26 +114,26 @@ unit xserial_agent_u like uvm_agent {
     -- single file.
     rx_log_filename : string;
         keep soft rx_log_filename == "xserial";
-        
-    
+
+
     -- This field is set to the frame just transmitted just before the
     -- tx_frame_done event is emitted.
     !tx_frame : MONITOR xserial_frame_s;
-    
+
     -- This field is set to the frame just received just before the
     -- rx_frame_done event is emitted.
     !rx_frame : MONITOR xserial_frame_s;
-    
+
     -- This event gets emitted each time a frame is transmitted.
     event tx_frame_done;
-    
+
     -- This event gets emitted each time a frame is transmitted.
     event rx_frame_done;
-    
+
     -- This event gets emitted when reset is asserted.
     event reset_start;
-    
-    -- This event gets emitted when reset is de-asserted. 
+
+    -- This event gets emitted when reset is de-asserted.
     event reset_end;
 
     -- This field is used to sub-type the agent for when the TX path is
@@ -164,29 +164,29 @@ extend xserial_bfm_u {
 extend has_tx_path xserial_agent_u {
 
     event tf_phase_clock is only @tx_monitor.unqualified_clock_rise;
-   
+
     -- This field is the instance of the monitor for the transmit direction.
     -- It only exists if the TX direction is enabled for this agent.
     tx_monitor : TX xserial_monitor_u is instance;
         keep tx_monitor.file_logger.to_file == read_only(tx_log_filename);
-        keep tx_monitor.has_protocol_checker == 
+        keep tx_monitor.has_protocol_checker ==
                         read_only(check_tx_protocol);
         keep tx_monitor.has_coverage == has_coverage;
-    
+
     connect_pointers() is also {
         tx_monitor.agent = me;
     };
-    
+
     keep tx_monitor.collector.sig_clock.hdl_path() ==
                          read_only(sig_tx_clock.hdl_path());
     keep tx_monitor.collector.sig_data.hdl_path() ==
                        read_only(sig_tx_data.hdl_path());
-    
+
 }; -- extend has_tx_path xserial_agent_u
 
 
 extend has_rx_path xserial_agent_u {
-        
+
     -- This field is the instance of the monitor for the receive direction.
     -- It only exists if the RX direction is enabled for this agent.
     rx_monitor : RX xserial_monitor_u is instance;
@@ -225,13 +225,13 @@ extend ACTIVE has_tx_path xserial_agent_u {
                              read_only(sig_tx_clock.hdl_path());
     keep tx_bfm.sig_tx_data.hdl_path() ==
                              read_only(sig_tx_data.hdl_path());
-      
+
     -- This field is the instance of the transmit sequence driver. It only
     -- exists if the TX direction is enabled for this agent and the agent is
     -- ACTIVE.
     tx_driver : xserial_driver_u is instance;
         keep tx_driver.name == read_only(name);
-        
+
 }; -- extend ACTIVE has_tx_path xserial_agent_u
 
 
@@ -240,25 +240,25 @@ extend has_rx_path has_tx_path xserial_agent_u {
     connect_pointers() is also {
         tx_monitor.reverse_monitor = rx_monitor;
         rx_monitor.reverse_monitor = tx_monitor;
-    }; 
+    };
 
 }; -- extend has_rx_path has_tx_path xserial_agent_u
 
 
--- If agent is in ACTIVE mode and both paths are enabled, then the Tx BFM 
+-- If agent is in ACTIVE mode and both paths are enabled, then the Tx BFM
 -- needs to know where the Rx monitor is so it can check on the current
 -- state of flow control
 extend ACTIVE has_rx_path has_tx_path xserial_agent_u {
 
     keep tx_bfm.rx_monitor == read_only(rx_monitor);
-    
+
 }; -- extend ACTIVE has_rx_path has_tx_path xserial_agent_u
 
 
 // CONFIGURATION:
 // --------------
 
-// the macro instantiates unit xserial_agent_config_u and struct 
+// the macro instantiates unit xserial_agent_config_u and struct
 // xserial_agent_config_params, in xserial_agent_u.
 // if they have no been defined earlier - also defines them
 // In this example, xserial_agent_config_u xserial_agent_config_params have
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xserial/e/xserial_bfm.e b/lesson000X_mluvm_svsc/uvm_examples/xserial/e/xserial_bfm.e
index 3126f11..57ecdd0 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xserial/e/xserial_bfm.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xserial/e/xserial_bfm.e
@@ -1,14 +1,14 @@
-/*------------------------------------------------------------------------- 
+/*-------------------------------------------------------------------------
 File name   : xserial_bfm.e
 Title       : XSerial BFM implementation
 Project     : XSerial eVC
 Created     : 2008
 Description : This file contains private implementation of the BFM unit.
-Notes       : 
---------------------------------------------------------------------------- 
+Notes       :
+---------------------------------------------------------------------------
 Copyright (c) 2008-2010 Cadence Design Systems,Inc.
   All rights reserved worldwide
--------------------------------------------------------------------------*/ 
+-------------------------------------------------------------------------*/
 
 <'
 
@@ -16,7 +16,7 @@ package cdn_xserial;
 
 
 extend xserial_bfm_u {
-   
+
     -- This method is called to set the BFM to it's correct state during
     -- and after reset.
     private init_bfm() is {
@@ -24,24 +24,24 @@ extend xserial_bfm_u {
         sig_tx_data$ = 1;
         message(LOW, "TX BFM initialised");
     };
-    
-      
+
+
     -- This TCM drives a single frame onto the TX_DATA signal.
-    private drive_frame(frame : TX xserial_frame_s) 
+    private drive_frame(frame : TX xserial_frame_s)
                                    @tf_phase_clock is {
-    
+
         message(HIGH, "transmit frame generated and ready to be sent: ",
                                                                   frame);
-        
+
         wait [frame.transmit_delay] * cycle;
-    
+
         -- If this is not a MESSAGE frame, then make sure receiver is ready.
         if frame.payload is not a MESSAGE xserial_frame_payload_s {
             while (rx_monitor != NULL) and (not rx_monitor.ready) {
                 wait cycle;
             };
         };
-        
+
         msg_started(MEDIUM, "Sending frame", frame);
 
         -- transmit frame
@@ -55,7 +55,7 @@ extend xserial_bfm_u {
 
         -- Make sure data goes high again even if stop bit is corrupted.
         sig_tx_data$ = 1;
-        
+
         msg_ended(MEDIUM, "Sending frame", frame);
 
     }; -- drive_frame()
@@ -64,27 +64,27 @@ extend xserial_bfm_u {
     -- driver and passing them to the BFM.
     private main_bfm() @tf_phase_clock is {
         while TRUE {
-            
+
             var next_frame := driver.get_next_item();
             drive_frame(next_frame);
             emit driver.item_done;
         }; -- while TRUE
     }; -- main_bfm()
-    
+
     tf_reset() @tf_phase_clock is also {
         init_bfm();
     };
-    
+
     tf_main_test() @tf_phase_clock is also {
         start main_bfm();
         // Register the thread as running until POST_TEST, non blocking
-        tf_get_domain_mgr().register_thread_by_name(me, "main_bfm", 
+        tf_get_domain_mgr().register_thread_by_name(me, "main_bfm",
                                                     POST_TEST, FALSE);
-    }; 
+    };
+
+
 
-    
-    
-    // Calculate recoreded attributes 
+    // Calculate recoreded attributes
     tr_get_attribute_value(inst: any_struct, name: string): string is also {
         if inst is a xserial_frame_s (f) then {
             result = f.get_attribute_value(name);
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xserial/e/xserial_bfm_h.e b/lesson000X_mluvm_svsc/uvm_examples/xserial/e/xserial_bfm_h.e
index 84d8b9e..10bc981 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xserial/e/xserial_bfm_h.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xserial/e/xserial_bfm_h.e
@@ -1,9 +1,9 @@
-/*------------------------------------------------------------------------- 
+/*-------------------------------------------------------------------------
 File name   : xserial_bfm_h.e
 Title       : XSerial BFM public interface
 Project     : XSerial eVC
 Created     : 2008
-Description : This file declares the public interface of the BFM unit. 
+Description : This file declares the public interface of the BFM unit.
 Notes       : There is no RX BFM because the RX link direction contains no
             : signals that the eVC can drive. As such, the entire RX path
             : functionality is contained in the RX monitor and the eVC does
@@ -11,10 +11,10 @@ Notes       : There is no RX BFM because the RX link direction contains no
             :
             : The BFM depends on the functionality of the RX and TX
             : monitors.
---------------------------------------------------------------------------- 
+---------------------------------------------------------------------------
 Copyright (c) 2008-2010 Cadence Design Systems,Inc.
   All rights reserved worldwide
--------------------------------------------------------------------------*/ 
+-------------------------------------------------------------------------*/
 
 <'
 
@@ -26,10 +26,10 @@ package cdn_xserial;
 unit xserial_bfm_u like uvm_bfm {
     tf_testflow_unit;
     event tf_phase_clock is only @tx_monitor.unqualified_clock_rise;
-   
+
     -- This field is a pointer to the TX monitor.
     tx_monitor : xserial_monitor_u;
-    
+
     -- This field is a pointer to the RX monitor (or NULL if the RX path is
     -- disabled).
     rx_monitor : xserial_monitor_u;
@@ -37,7 +37,7 @@ unit xserial_bfm_u like uvm_bfm {
 
     -- This field is a pointer to the sequence driver.
     driver : xserial_driver_u;
-    
+
     -- This field holds the signal name of the TX_CLOCK signal on the
     -- XSERIAL interface.
     sig_tx_clock : out simple_port of bit is instance;
@@ -45,7 +45,7 @@ unit xserial_bfm_u like uvm_bfm {
     -- This field holds the signal name of the TX_DATA signal on the XSERIAL
     -- interface.
     sig_tx_data  : out simple_port of bit is instance;
-   
+
 }; -- unit xserial_bfm_u
 
 
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xserial/e/xserial_collector.e b/lesson000X_mluvm_svsc/uvm_examples/xserial/e/xserial_collector.e
index 3ac7fa9..111450d 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xserial/e/xserial_collector.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xserial/e/xserial_collector.e
@@ -1,4 +1,4 @@
-/*------------------------------------------------------------------------- 
+/*-------------------------------------------------------------------------
 File name   : xserial_collector.e
 Title       : XSerial collector unit
 Project     : XSerial eVC
@@ -8,11 +8,11 @@ Notes       : The collector collects all activity on the bus and collects
             : information on each frame that occurs.
             : It passes the collected info, after basic processing, to the
             : monitor.
-            : The monitor performs higher level process, coverage and checks 
---------------------------------------------------------------------------- 
+            : The monitor performs higher level process, coverage and checks
+---------------------------------------------------------------------------
 Copyright (c) 2008-2010 Cadence Design Systems,Inc.
   All rights reserved worldwide
--------------------------------------------------------------------------*/ 
+-------------------------------------------------------------------------*/
 
 <'
 package cdn_xserial;
@@ -38,7 +38,7 @@ extend xserial_collector_u {
             result += 1;
         };
     }; -- wait_frame_start()
-    
+
 
     -- This method should be passed an instance of a xserial_frame_s. It
     -- collects a frame from the interface and unpacks it into the frame
@@ -54,38 +54,38 @@ extend xserial_collector_u {
         monitor_frame.inter_frame_delay = wait_frame_start();
         emit frame_started_eo$;
         message(MEDIUM, direction, " Collector detected frame start");
-        msg_started(HIGH, append(direction, " Collecting frame"), 
+        msg_started(HIGH, append(direction, " Collecting frame"),
                     monitor_frame);
         frame_started_o$.write(monitor_frame);
 
         -- collect the frame
         -- Raw data is collected in this variable
         var raw_bits : list of bit;
-        
+
         -- Collect the raw data
         for i from 1 to 14 {
             raw_bits.add(sig_data$);
             wait cycle;
         };
         raw_bits.add(sig_data$);
-        
+
         -- Unpack the raw data into the frame struct and check it's
         -- format if required.
         monitor_frame.unpack_frame(raw_bits, has_protocol_checker);
-        
+
         message(MEDIUM, direction, " Collector detected frame end");
-        msg_ended(HIGH, append(direction, " Collecting frame"), 
+        msg_ended(HIGH, append(direction, " Collecting frame"),
                   monitor_frame);
 
         emit frame_ended_eo$;
-        
+
         -- Pass to upper components
         frame_ended_o$.write(monitor_frame);
     };
-    
+
     -- This method continually monitors frames at the interface of
     -- this agent
-    
+
     private collect_frames() @tf_phase_clock is {
         message(LOW, direction, " collect_frames started");
         while TRUE {
@@ -94,7 +94,7 @@ extend xserial_collector_u {
         };
     };
 
-    
+
    -- This TCM starts the monitor. It gets called by the agent to start the
     -- monitor at the start of the test and each time reset is asserted. The
     -- user can delay activation of the monitor by extending this method
@@ -103,15 +103,15 @@ extend xserial_collector_u {
         -- Start the main monitor.
         start collect_frames();
         // Register the thread as running until POST_TEST, non blocking
-        tf_get_domain_mgr().register_thread_by_name(me, "collect_frames", 
+        tf_get_domain_mgr().register_thread_by_name(me, "collect_frames",
                                                     POST_TEST, FALSE);
      }; -- tf_main_test()
-    
+
     // Attributes that are calculated (and just that sampling of fields)
     tr_get_attribute_value(inst: any_struct, name: string): string is also {
         if inst is a xserial_frame_s (f) then {
             result = f.get_attribute_value(name);
         };
     };
-}; -- extend xserial_collector_u 
+}; -- extend xserial_collector_u
 '>
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xserial/e/xserial_collector_h.e b/lesson000X_mluvm_svsc/uvm_examples/xserial/e/xserial_collector_h.e
index 8b3921f..a76791e 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xserial/e/xserial_collector_h.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xserial/e/xserial_collector_h.e
@@ -1,4 +1,4 @@
-/*------------------------------------------------------------------------- 
+/*-------------------------------------------------------------------------
 File name   : xserial_collector_h.e
 Title       : XSerial collector unit
 Project     : XSerial eVC
@@ -8,11 +8,11 @@ Notes       : The collector collects all activity on the bus and collects
             : information on each frame that occurs.
             : It passes the collected info, after basic processing, to the
             : monitor.
-            : The monitor performs higher level process, coverage and checks 
---------------------------------------------------------------------------- 
+            : The monitor performs higher level process, coverage and checks
+---------------------------------------------------------------------------
 Copyright (c) 2008-2010 Cadence Design Systems,Inc.
   All rights reserved worldwide
--------------------------------------------------------------------------*/ 
+-------------------------------------------------------------------------*/
 
 <'
 package cdn_xserial;
@@ -24,10 +24,10 @@ package cdn_xserial;
 -- assist in monitoring.
 extend MONITOR xserial_frame_s {
 
-    -- This field indicates which eVC instance this frame is 
+    -- This field indicates which eVC instance this frame is
     -- associated with.
     name : xserial_env_name_t;
-    
+
     -- This field holds the time between the end of the previous frame and
     -- the beginning of this one.
     inter_frame_delay : uint;
@@ -42,15 +42,15 @@ unit xserial_collector_u like uvm_collector {
 
     frame_started_eo : out event_port is instance;
     frame_ended_eo   : out event_port is instance;
-    
+
     -- These ports pass collected frames to upper components
     -- By default - bound to empty.
-    frame_started_o : out interface_port of tlm_analysis 
+    frame_started_o : out interface_port of tlm_analysis
                                          of MONITOR xserial_frame_s
                                          is instance;
         keep bind (frame_started_o, empty);
-    
-    frame_ended_o : out interface_port of tlm_analysis 
+
+    frame_ended_o : out interface_port of tlm_analysis
                                            of MONITOR xserial_frame_s
                                            is instance;
         keep bind (frame_ended_o, empty);
@@ -60,7 +60,7 @@ unit xserial_collector_u like uvm_collector {
 
     -- This is the clock signal of the link being monitored.
     sig_clock : in simple_port of bit is instance;
-    
+
     -- This is the data signal of the link being monitored.
     sig_data : in simple_port of bit is instance;
 
@@ -76,21 +76,21 @@ unit xserial_collector_u like uvm_collector {
 
     -- The monitored frame is built up in this field.
     !monitor_frame : MONITOR xserial_frame_s;
-       
+
      -- Clocks
 
     -- This event is the clock change event, the base of the
-    -- rise/fall clocks 
+    -- rise/fall clocks
     event unqualified_clock_change is change(sig_clock$) @sim;
 
-    -- This event is the clock rise event for this direction prior to 
+    -- This event is the clock rise event for this direction prior to
     -- qualification with reset.
     event unqualified_clock_rise;
 
-    -- This event is the clock fall event for this direction prior to 
+    -- This event is the clock fall event for this direction prior to
     -- qualification with reset.
     event unqualified_clock_fall;
-    
+
     on unqualified_clock_change {
        if (sig_clock$ == 0) then {
           emit unqualified_clock_fall;
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xserial/e/xserial_coverage.e b/lesson000X_mluvm_svsc/uvm_examples/xserial/e/xserial_coverage.e
index 4e9aa39..98ebc13 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xserial/e/xserial_coverage.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xserial/e/xserial_coverage.e
@@ -1,4 +1,4 @@
-/*------------------------------------------------------------------------- 
+/*-------------------------------------------------------------------------
 File name   : xserial_coverage_h.e
 Title       : Coverage definitions
 Project     : XSerial eVC
@@ -12,10 +12,10 @@ Notes       : Two different coverage events are used here because, at
             : name and the direction. By using two events, one for each
             : direction, separate coverage groups can be maintained for
             : each direction.
---------------------------------------------------------------------------- 
+---------------------------------------------------------------------------
 Copyright (c) 2008-2010 Cadence Design Systems,Inc.
   All rights reserved worldwide
--------------------------------------------------------------------------*/ 
+-------------------------------------------------------------------------*/
 
 <'
 
@@ -27,16 +27,16 @@ extend xserial_frame_s {
     -- This event is emitted by the appropriate TX monitor whenever a frame
     -- transmission completes. It is used to collect coverage.
     event tx_frame_done;
-    
+
     -- This event is emitted by the appropriate RX monitor whenever a frame
     -- reception completes. It is used to collect coverage.
     event rx_frame_done;
-    
+
 }; -- extend xserial_frame_s
 
 
 extend has_coverage xserial_monitor_u {
-    
+
     -- Each time a frame ends, emit the event used to collect coverage for
     -- that frame.
     on frame_ended {
@@ -55,36 +55,36 @@ extend MONITOR xserial_frame_s {
     // For seeing the coverage report of only one agent, use
     // the cover name or e_path in the command. For example:
     // show cover xserial_frame_s.tx_frame_done(XSERIAL_A)
-    cover tx_frame_done using 
+    cover tx_frame_done using
                           per_unit_instance = xserial_agent_u is {
         item destination : uint(bits:2) = payload.destination;
-        item frame_format : xserial_frame_format_t = 
+        item frame_format : xserial_frame_format_t =
           payload.frame_format;
-        item data : byte = 
+        item data : byte =
           payload.as_a(DATA xserial_frame_payload_s).data
           using when = (payload is a DATA xserial_frame_payload_s);
-        item frame_message : xserial_frame_message_t = 
+        item frame_message : xserial_frame_message_t =
           payload.as_a(MESSAGE xserial_frame_payload_s).frame_message
           using when = (payload is a MESSAGE xserial_frame_payload_s);
         item parity;
         item inter_frame_delay;
     }; -- cover tx_frame_done
-        
-    cover rx_frame_done using 
+
+    cover rx_frame_done using
                           per_unit_instance=xserial_agent_u is {
         item destination : uint(bits:2) = payload.destination;
-        item frame_format : xserial_frame_format_t = 
+        item frame_format : xserial_frame_format_t =
           payload.frame_format;
-        item data : byte = 
+        item data : byte =
           payload.as_a(DATA xserial_frame_payload_s).data
           using when = (payload is a DATA xserial_frame_payload_s);
-        item frame_message : xserial_frame_message_t = 
+        item frame_message : xserial_frame_message_t =
           payload.as_a(MESSAGE xserial_frame_payload_s).frame_message
           using when = (payload is a MESSAGE xserial_frame_payload_s);
         item parity;
         item inter_frame_delay;
     }; -- cover rx_frame_done
-        
+
 }; -- extend xserial_frame_s
 
 '>
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xserial/e/xserial_end_test.e b/lesson000X_mluvm_svsc/uvm_examples/xserial/e/xserial_end_test.e
index b65ef40..e0b65e7 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xserial/e/xserial_end_test.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xserial/e/xserial_end_test.e
@@ -1,4 +1,4 @@
-/*------------------------------------------------------------------------- 
+/*-------------------------------------------------------------------------
 File name   : xserial_end_test.e
 Title       : End of test stuff
 Project     : XSerial eVC
@@ -7,13 +7,13 @@ Description : This file handles 'end of test'.
 Notes       : End of test handling is done using the objection mechanism.
             : Each proactive MAIN sequence raises an objection to TEST_DONE
             : at the start of the sequence and drops the objection at the
-            : end of the sequence. A built in drain time is used to ensure 
+            : end of the sequence. A built in drain time is used to ensure
             : that the test has really finished.
---------------------------------------------------------------------------- 
+---------------------------------------------------------------------------
 Copyright (c) 2008-2010 Cadence Design Systems,Inc.
   All rights reserved worldwide
 
--------------------------------------------------------------------------*/ 
+-------------------------------------------------------------------------*/
 
 <'
 
@@ -23,7 +23,7 @@ package cdn_xserial;
 extend MAIN xserial_sequence {
     prevent_test_done : bool;
        keep soft prevent_test_done == TRUE;
-}; -- extend xserial_sequence 
+}; -- extend xserial_sequence
 
 extend MAIN ENV_SETUP xserial_sequence {
     -- Raise an objection to TEST_DONE at setup
@@ -39,7 +39,7 @@ extend MAIN POST_TEST xserial_sequence {
     -- This field is used to control the delay between the end of the MAIN
     -- sequence and the dropping of the objection to TEST_DONE - i.e. the
     -- time allowed for the last data to drain through the DUT. This is
-    -- measured in clock cycles. 
+    -- measured in clock cycles.
     drain_time : uint;
         keep soft drain_time == 10;
 };
@@ -55,7 +55,7 @@ extend MAIN POST_TEST xserial_sequence {
             driver.drop_objection(TEST_DONE);
         };
     }; -- post_body()
-    
+
 }; -- extend MAIN xserial_sequence
 
 
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xserial/e/xserial_env.e b/lesson000X_mluvm_svsc/uvm_examples/xserial/e/xserial_env.e
index 8ba61b7..8cd8d2c 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xserial/e/xserial_env.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xserial/e/xserial_env.e
@@ -1,14 +1,14 @@
-/*------------------------------------------------------------------------- 
+/*-------------------------------------------------------------------------
 File name   : xserial_env.e
 Title       : Implementation of the env
 Project     : XSerial eVC
 Created     : 2008
 Description : This file contains the implementation of the env.
-Notes       : 
---------------------------------------------------------------------------- 
+Notes       :
+---------------------------------------------------------------------------
 Copyright (c) 2008-2010 Cadence Design Systems,Inc.
   All rights reserved worldwide
--------------------------------------------------------------------------*/ 
+-------------------------------------------------------------------------*/
 
 <'
 
@@ -23,12 +23,12 @@ extend xserial_env_u {
         out("eVC instance : ", name);
         out("     ", agent.active_passive);
     }; -- show_banner()
-    
+
     -- Implement the show_status() method
     show_status() is only {
         agent.show_status();
     }; -- show_status()
-        
+
     -- Report the final status at the end of the test.
     finalize() is also {
         message(LOW, "Test done:");
@@ -44,13 +44,13 @@ extend xserial_env_u {
 
 <'
 extend xserial_env_u {
-    // configure 
+    // configure
     configure( ctr    : uint,
                new_params : xserial_env_config_params_s) is {
 
         // Propagate config parameters to the agent
-        uvm_configure ctr agent {mode} {new_params.mode}; 
-          
+        uvm_configure ctr agent {mode} {new_params.mode};
+
         // Update local configuraiton parameters
         config.params = new_params.copy();
     };
@@ -64,17 +64,17 @@ extend xserial_env_u {
      // Configure the transaction recording
     connect_pointers() is also {
         var tr_cfg : recording_config = new;
-        
+
         // Attributes to be collected
         // These are callback attributes - read from the payload
-        
+
         tr_cfg.register_callback_attribute("xserial_frame_s","destination");
-        tr_cfg.set_attribute_sampling("xserial_frame_s","destination", 
+        tr_cfg.set_attribute_sampling("xserial_frame_s","destination",
                                       {ENDED});
         tr_cfg.register_callback_attribute("xserial_frame_s","data");
         tr_cfg.set_attribute_sampling("xserial_frame_s","data", {ENDED});
 
         assign_recording_config(tr_cfg);
-    }; 
+    };
 };
 '>
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xserial/e/xserial_env_h.e b/lesson000X_mluvm_svsc/uvm_examples/xserial/e/xserial_env_h.e
index 5c476b6..2d1c2a1 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xserial/e/xserial_env_h.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xserial/e/xserial_env_h.e
@@ -1,10 +1,10 @@
-/*------------------------------------------------------------------------- 
+/*-------------------------------------------------------------------------
 File name   : xserial_env_h.e
 Title       : Env unit public interface
 Project     : XSerial eVC
 Created     : 2008
 Description : This file contains the declaration of the env unit and all
-            : user accessible fields, events and methods. 
+            : user accessible fields, events and methods.
 Notes       : In this eVC, there is only a single agent per env. An env
             : should contain all agents that logically belong to the same
             : "network". In the case of the XSerial protocol, a network
@@ -13,10 +13,10 @@ Notes       : In this eVC, there is only a single agent per env. An env
             : the signals at the other device, there is no need to have a
             : passive agent monitoring the other end of the link. As such,
             : only a single agent is ever required per env.
---------------------------------------------------------------------------- 
+---------------------------------------------------------------------------
 Copyright (c) 2008-2010 Cadence Design Systems,Inc.
   All rights reserved worldwide
--------------------------------------------------------------------------*/ 
+-------------------------------------------------------------------------*/
 
 <'
 
@@ -26,20 +26,20 @@ package cdn_xserial;
 unit xserial_env_u like uvm_env {
     tf_testflow_unit;
     keep soft tf_domain == XSERIAL_TF;
-    // By default - run all phases on sys.any. 
+    // By default - run all phases on sys.any.
     // If required - override by conecting to another clock
     event tf_phase_clock is only @sys.any;
-   
-    
+
+
     -- This field provides a screen logger for the env. Note that this eVC
     -- has only a single agent per env, so there is no point adding a
     -- separate screen logger for each agent.
     logger : message_logger is instance;
         keep soft logger.verbosity == NONE;
-    
+
     -- This field holds the logical name of this eVC instance.
-    name : xserial_env_name_t;    
-    
+    name : xserial_env_name_t;
+
     -- This field is used to sub-type the agent for when the TX path is
     -- enabled.
     const has_tx_path : bool;
@@ -56,7 +56,7 @@ unit xserial_env_u like uvm_env {
         keep agent.name == read_only(name);
         keep type agent.has_tx_path == has_tx_path;
         keep type agent.has_rx_path == has_rx_path;
-        
+
 }; -- unit xserial_env_u
 
 '>
@@ -66,7 +66,7 @@ Status report:
 
 <'
 extend xserial_env_u {
-    
+
     -- Print a banner for each eVC instance at the start of the test
     show_banner() is also {
         out("(c) Cadence 2002-2006");
@@ -74,7 +74,7 @@ extend xserial_env_u {
         out("     ", agent.active_passive);
     }; -- show_banner()
 
-    
+
     -- The short_name() method should return the name of this eVC instance.
     short_name(): string is {
         result = append(name);
@@ -84,7 +84,7 @@ extend xserial_env_u {
     short_name_style(): vt_style is {
         result = DARK_CYAN;
     };
-    
+
     -- Implement the show_status() method
     show_status() is {
         agent.show_status();
@@ -95,14 +95,14 @@ extend xserial_env_u {
         message(LOW, "Test done:");
         show_status();
     }; -- finalize()
-};    
+};
 
 
 
 // CONFIGURATION:
 // --------------
 
-// the macro defines xserial_env_config_u and xserial_env_config_params_s, 
+// the macro defines xserial_env_config_u and xserial_env_config_params_s,
 // and instantiates them in xserial_env_u.
 uvm_build_config env xserial_env_u xserial_env_config_u xserial_env_config_params_s;
 
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xserial/e/xserial_frame_h.e b/lesson000X_mluvm_svsc/uvm_examples/xserial/e/xserial_frame_h.e
index 7a14135..ace5fe8 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xserial/e/xserial_frame_h.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xserial/e/xserial_frame_h.e
@@ -1,14 +1,14 @@
-/*------------------------------------------------------------------------- 
+/*-------------------------------------------------------------------------
 File name   : xserial_frame_h.e
 Title       : XSerial eVC frame structure
 Project     : XSerial eVC
 Created     : 2008
 Description : This file declares the format of the XSerial frame.
-Notes       : 
---------------------------------------------------------------------------- 
+Notes       :
+---------------------------------------------------------------------------
 Copyright (c) 2008-2010 Cadence Design Systems,Inc.
   All rights reserved worldwide
--------------------------------------------------------------------------*/ 
+-------------------------------------------------------------------------*/
 
 <'
 
@@ -28,11 +28,11 @@ type xserial_frame_kind_t : [GENERIC, MONITOR, TX];
 extend xserial_frame_status_t : [BAD_START,  -- start bit is not 0
                                     BAD_PARITY, -- parity bit is incorrect
                                     BAD_STOP];  -- stop bit is not 1
-                                    
-              
-              
+
+
+
 -- This struct represents a single frame. It is used as the sequence
--- item for the transmit sequence interface.                      
+-- item for the transmit sequence interface.
 struct xserial_frame_s like any_sequence_item {
 
     -- For generated frames, this field is automatically updated by the eVC
@@ -48,22 +48,22 @@ struct xserial_frame_s like any_sequence_item {
         keep soft kind == GENERIC;
 
     -- This field is the physical start bit of the frame and, by default, is
-    -- always 0 (the legal value). To create an erroneous start bit, 
+    -- always 0 (the legal value). To create an erroneous start bit,
     -- constrain this field to be 1.
     %start_bit : bit;
         keep soft start_bit == 0;
-        
+
     -- This field holds the payload part of the frame. See the file
     -- xserial_frame_payload_h.e for more details.
     %payload : xserial_frame_payload_s;
-    
+
     -- For generated frames, this field controls whether the parity bit is
     -- correct or bad. By default, correct parity is generated. For unpacked
     -- frames, this field indicates whether the unpacked parity bit is
     -- correct or not.
     bad_parity : bool;
         keep soft bad_parity == FALSE;
-    
+
     -- This field contains the parity bit for the frame. Parity is
     -- calculated as the even parity of all data bits in the payload. The
     -- virtual field parity_kind can be used to constrain either correct
@@ -71,41 +71,41 @@ struct xserial_frame_s like any_sequence_item {
     %parity : bit;
         keep not read_only(bad_parity) => parity == calc_parity();
         keep     read_only(bad_parity) => parity != calc_parity();
-        
+
     -- This field is the physical stop bit of the frame and, by default, is
     -- always 1 (the legal value). To create an erroneous stop bit,
     -- constrain this field to be 0.
     %stop_bit : bit;
         keep soft stop_bit == 1;
-        
+
     -- This method returns the even parity of a payload.
     calc_parity() : bit is {
         for each (b) in payload.pack_payload() {
             result ^= b;
         };
     }; -- calc_parity()
-    
+
     -- This method returns TRUE if the parity field contains the correct
     -- even parity for the payload. This can be used on received frames to
     -- quickly determine the status of the parity bit.
     parity_ok() : bool is {
         result = (parity == calc_parity());
     }; -- parity_ok()
-    
+
     post_generate() is also {
         update_status();
     }; -- post_generate()
-    
+
     -- This method returns the frame as a list of bits. By using this method
     -- rather than explicitly packing the struct, the user does not need
     -- to be aware of the details of how a frame is packed. Note that in
-    -- the XSerial eVC example, this is relatively trivial, but in more 
+    -- the XSerial eVC example, this is relatively trivial, but in more
     -- complex eVCs, the process of packing a struct may be complex.
     pack_frame() : list of bit is {
         result = pack(packing.low, start_bit, payload.pack_payload(),
                       parity, stop_bit);
     }; -- pack_frame()
-    
+
     -- This method takes a bitstream and unpacks it into the frame struct.
     -- As with pack_frame(), this method hides the implementation details
     -- of the struct packing/unpacking from the user. In addition, if the
@@ -130,20 +130,20 @@ struct xserial_frame_s like any_sequence_item {
         if bitstream.size() != 15 {
             error("FATAL: Frame is not 15 bits long");
         };
-        
+
         -- Unpack the start bit
         unpack(packing.low, bitstream, start_bit);
-        
+
         -- Check that the start bit is legal
         if check_protocol {
             check start_bit_err that start_bit == 0
                 else dut_error("Frame start bit is not 0");
         };
-        
+
         -- Unpack the payload
         payload = new;
         payload.unpack_payload(bitstream[1..12], check_protocol);
-        
+
         -- Unpack the parity and stop bits;
         unpack(packing.low, bitstream[13..14], parity, stop_bit);
 
@@ -152,17 +152,17 @@ struct xserial_frame_s like any_sequence_item {
             check parity_err that parity_ok()
                 else dut_error("Frame has bad parity: ", parity);
         };
-        
+
         -- Check the stop bit.
         if check_protocol {
             check stop_bit_err that stop_bit == 1
                 else dut_error("Frame stop bit is not 1");
         };
-        
+
     }; -- unpack_frame_internal()
-    
+
     -- This method returns a convenient string representation of the
-    -- contents of the frame. This is used for logging, waveform viewing, 
+    -- contents of the frame. This is used for logging, waveform viewing,
     -- etc.
     nice_string(): string is also {
         result = append(payload.nice_string(), " ERRORS:");
@@ -177,17 +177,17 @@ struct xserial_frame_s like any_sequence_item {
             };
         }
     }; -- nice_string()
-    
+
     -- This method compares this frame with a frame supplied as a parameter.
     -- If the compare_dest field is false, then differences in the payload
     -- destination fields are ignored. It returns a list of strings that
     -- contains all detected differences.
-    compare_frames(exp_frame : xserial_frame_s, 
+    compare_frames(exp_frame : xserial_frame_s,
                    compare_dest : bool) : list of string is {
         if exp_frame.start_bit != start_bit {
-            result.add(append("Expected start bit: ", 
+            result.add(append("Expected start bit: ",
                               exp_frame.start_bit,
-                              ", Actual start bit: ", 
+                              ", Actual start bit: ",
                               start_bit));
             return result;
         };
@@ -200,13 +200,13 @@ struct xserial_frame_s like any_sequence_item {
                               parity_ok()?"OK":"BAD"));
         };
         if exp_frame.stop_bit != stop_bit {
-            result.add(append("Expected stop bit: ", 
+            result.add(append("Expected stop bit: ",
                               exp_frame.stop_bit,
-                              ", Actual stop bit: ", 
+                              ", Actual stop bit: ",
                               stop_bit));
         };
     }; -- compare_frames()
-    
+
     -- This method is called in post_generate() and also in unpack_frame()
     -- to update the status field according to the detected errors in the
     -- frame.
@@ -216,46 +216,46 @@ struct xserial_frame_s like any_sequence_item {
         -- otherwise.
         status = {};
 
-        -- If the start bit is illegal, then reflect this in 
+        -- If the start bit is illegal, then reflect this in
         -- the status  field
         if start_bit != 0 {
             status.add(BAD_START);
         };
-        
-        -- If there are any protocol errors in the payload, then reflect 
+
+        -- If there are any protocol errors in the payload, then reflect
         -- these in the status field.
         status.add(payload.status);
-        
+
         -- If the parity is bad then reflect this in the status field.
         if not parity_ok() {
             status.add(BAD_PARITY);
             bad_parity = TRUE;
         } else {
             bad_parity = FALSE;
-        };            
-            
+        };
+
         -- If the stop bit is illegal, then reflect this in the status field
         if stop_bit != 1 {
             status.add(BAD_STOP);
         };
-        
+
     }; -- update_status()
 
-    
-    -- Called by Structured Messages 
+
+    -- Called by Structured Messages
     get_attribute_value(name: string): string is {
-     
-        if name == "destination" or 
+
+        if name == "destination" or
            name == "data" {
-            
+
             if payload == NULL {
                 return "";
             };
             result = payload.get_attribute_value(name);
         };
-        
+
     };
-    
+
 }; -- struct xserial_frame_s
 
 
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xserial/e/xserial_frame_payload_data_h.e b/lesson000X_mluvm_svsc/uvm_examples/xserial/e/xserial_frame_payload_data_h.e
index 40e970b..a37f03b 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xserial/e/xserial_frame_payload_data_h.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xserial/e/xserial_frame_payload_data_h.e
@@ -1,16 +1,16 @@
-/*------------------------------------------------------------------------- 
+/*-------------------------------------------------------------------------
 File name   : xserial_frame_payload_data_h.e
-Title       : XSerial eVC frame payload structure for data frames 
+Title       : XSerial eVC frame payload structure for data frames
 Project     : XSerial eVC
 Created     : 2008
 Description : This file declares the format of the DATA subtype of the
-            : XSerial frame payload. 
-Notes       : 
---------------------------------------------------------------------------- 
+            : XSerial frame payload.
+Notes       :
+---------------------------------------------------------------------------
 Copyright (c) 2008-2010 Cadence Design Systems,Inc.
   All rights reserved worldwide
 
--------------------------------------------------------------------------*/ 
+-------------------------------------------------------------------------*/
 
 <'
 
@@ -32,7 +32,7 @@ extend DATA xserial_frame_payload_s {
     -- This field contains the data bits for a DATA payload. Bit 0 is sent
     -- first down the serial interface.
     %data : byte;
-    
+
     -- Unpack the data part of a DATA payload
     unpack_payload(bitstream : list of bit, check_protocol : bool) is also {
         unpack(packing.low, bitstream[4..11], data);
@@ -42,20 +42,20 @@ extend DATA xserial_frame_payload_s {
     nice_string(): string is also {
         result = appendf("%s DATA:%02x       ", result, data);
     }; -- nice_string()
-   
+
     -- Compare data fields of DATA payloads.
-    compare_payloads(exp_payload : xserial_frame_payload_s, 
+    compare_payloads(exp_payload : xserial_frame_payload_s,
                      compare_dest : bool) : list of string is also {
         if exp_payload is a DATA xserial_frame_payload_s (d) and
            d.data != data {
-            result.add(append("Expected data field: ", 
+            result.add(append("Expected data field: ",
                               hex(d.data),
-                              ", Actual data field: ", 
+                              ", Actual data field: ",
                               hex(data)));
         };
     }; -- compare_payloads()
 
-    -- Called by Structured Messages 
+    -- Called by Structured Messages
     get_attribute_value(name: string): string is also {
         if name == "data" {
             result = append(data);
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xserial/e/xserial_frame_payload_h.e b/lesson000X_mluvm_svsc/uvm_examples/xserial/e/xserial_frame_payload_h.e
index 088dcb7..222b749 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xserial/e/xserial_frame_payload_h.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xserial/e/xserial_frame_payload_h.e
@@ -1,15 +1,15 @@
-/*------------------------------------------------------------------------- 
+/*-------------------------------------------------------------------------
 File name   : xserial_frame_payload_h.e
 Title       : XSerial eVC frame payload structure
 Project     : XSerial eVC
 Created     : 2008
 Description : his file declares the format of the generic XSerial frame
-            : payload. 
-Notes       : 
---------------------------------------------------------------------------- 
+            : payload.
+Notes       :
+---------------------------------------------------------------------------
 Copyright (c) 2008-2010 Cadence Design Systems,Inc.
   All rights reserved worldwide
--------------------------------------------------------------------------*/ 
+-------------------------------------------------------------------------*/
 
 <'
 
@@ -19,13 +19,13 @@ package cdn_xserial;
 -- The various possible sub-types are extended in the files that declare
 -- the sub-type formats. Note that the UNDEFINED value is used in the case
 -- where the user wants to generate a payload with an illegal frame_format
--- value. 
+-- value.
 type xserial_frame_format_t : [UNDEFINED = UNDEF];
 
 
 
--- This type is used to indicate the status of a frame. In this file, 
--- only the values that are relevant to payloads are declared. 
+-- This type is used to indicate the status of a frame. In this file,
+-- only the values that are relevant to payloads are declared.
 -- The xserial_frame.e file extends this type to give other status
 -- values. Note that because the XSerial protocol does not provide any
 -- means of identifying the end of a frame other than the value of the
@@ -44,24 +44,24 @@ struct xserial_frame_payload_s {
 
     -- For generated payloads, this field is automatically updated by the
     -- eVC during post_generate() to indicate what error conditions are
-    -- present in the payload. The user should not attempt to constrain 
-    -- or assign a value to this field. When a payload is unpacked, this 
-    -- field reflects the result of the unpacking. If this field is an 
+    -- present in the payload. The user should not attempt to constrain
+    -- or assign a value to this field. When a payload is unpacked, this
+    -- field reflects the result of the unpacking. If this field is an
     -- empty list then no errors are present in the payload.
     !status : list of xserial_frame_status_t;
-        
+
     -- This field holds the destination address for the frame. This can be
     -- used by routers but is otherwise ignored.
     %destination : uint(bits:2);
 
-    -- This field specifies the format of frame. 
-    -- The xserial_frame_format_t type can be extended to define 
+    -- This field specifies the format of frame.
+    -- The xserial_frame_format_t type can be extended to define
     -- various frame formats as required. Note that this field can only
-    -- take values that are declared legal frame formats or UNDEFINED. 
-    -- For this reason, the actual physical coding of this field in the 
+    -- take values that are declared legal frame formats or UNDEFINED.
+    -- For this reason, the actual physical coding of this field in the
     -- payload is held in the physical_frame_format field - which allows
     -- the user to generate frames with specific illegal formats.
-    -- For generated frames, this field will not be UNDEFINED by default. 
+    -- For generated frames, this field will not be UNDEFINED by default.
     -- To generate frames will random illegal frame format values,
     -- constrain this field to UNDEFINED. To generate frames with specific
     -- illegal frame format values, constrain this field to UNDEFINED and
@@ -70,7 +70,7 @@ struct xserial_frame_payload_s {
     -- frame format or UNDEFINED for illegal frame formats.
     frame_format : xserial_frame_format_t;
         keep soft frame_format != UNDEFINED;
-     
+
     -- This field is the actual physical frame format field as encoded
     -- in the frame. See the frame_format field for more details.
     %physical_frame_format : uint(bits:2);
@@ -80,20 +80,20 @@ struct xserial_frame_payload_s {
             physical_frame_format not in
                 all_values(xserial_frame_format_t).all(it != UNDEFINED).
                            apply(it.as_a(uint));
-        
+
     post_generate() is also {
         update_status();
     }; -- post_generate()
-    
+
     -- This method returns the payload as a list of bits. By using this
-    -- method rather than explicitly packing the struct, the user does 
+    -- method rather than explicitly packing the struct, the user does
     -- not need to be aware of the details of how a payload is packed.
     -- Note that in the XSerial eVC example, this is trivial, but in more
     -- complex eVCs, the process of packing a struct may be complex.
     pack_payload() : list of bit is {
         result = pack(packing.low, me);
     }; -- pack_payload()
-    
+
     -- This method takes a bitstream and unpacks it into the payload struct.
     -- As with pack_payload(), this method hides the implementation details
     -- of the struct packing/unpacking from the user. In addition, if the
@@ -104,20 +104,20 @@ struct xserial_frame_payload_s {
 
         unpack_payload_internal(bitstream, check_protocol);
         update_status();
-    
+
     }; -- unpack_payload()
-    
+
     -- The unpack_payload() method calls the unpack_payload_internal()
-    -- method and then calls update_status(). This allows sub-types of 
+    -- method and then calls update_status(). This allows sub-types of
     -- the payload to extend the unpacking behaviour while still ensuring
     -- that update_status() gets called last.
-    unpack_payload_internal(bitstream      : list of bit, 
+    unpack_payload_internal(bitstream      : list of bit,
                             check_protocol : bool) is {
-    
-    
+
+
         -- The payload should always be exactly 12 bits long. NOTE: this
-        -- isn't a DUT error (as the protocol provides no means of 
-        -- detecting that a DUT has sent a frame that isn't 15 bits long) 
+        -- isn't a DUT error (as the protocol provides no means of
+        -- detecting that a DUT has sent a frame that isn't 15 bits long)
         -- - so this is really an eVC usage error.
         if bitstream.size() != 12 {
             error("FATAL: Frame payload is not 12 bits long");
@@ -132,47 +132,47 @@ struct xserial_frame_payload_s {
         } else {
             frame_format = UNDEFINED;
         };
-        
+
         -- Make sure we've got a legal frame format. We'll assume that if
         -- the user extends xserial_frame_format_t then this makes the
         -- new value a legal frame format and the user will extend this
         -- subtype appropriately.
         if check_protocol {
             check illegal_frame_format that frame_format != UNDEFINED
-                else dut_error("Illegal frame format found: ", 
+                else dut_error("Illegal frame format found: ",
                                physical_frame_format);
         };
-        
+
     }; -- unpack_payload_internal()
-    
-    -- This method returns a convenient string representation of the 
+
+    -- This method returns a convenient string representation of the
     -- contents of the payload. This is used for logging, waveform viewing,
     -- etc.
     nice_string(): string is {
         result = appendf("DEST:%01d", destination);
     }; -- nice_string()
-    
+
     -- This method compares this payload with a payload supplied as a
     -- parameter. If the compare_dest field is false, then differences in
     -- the destination fields are ignored. It returns a list of strings that
     -- contains all detected differences.
-    compare_payloads(exp_payload : xserial_frame_payload_s, 
+    compare_payloads(exp_payload : xserial_frame_payload_s,
                      compare_dest : bool) : list of string is {
         if compare_dest and exp_payload.destination != destination {
-            result.add(append("Expected destination field: ", 
+            result.add(append("Expected destination field: ",
                               bin(exp_payload.destination),
-                              ", Actual destination field: ", 
+                              ", Actual destination field: ",
                               bin(destination)));
         };
         if exp_payload.frame_format != frame_format {
-            result.add(append("Expected format field: ", 
+            result.add(append("Expected format field: ",
                               exp_payload.frame_format,
-                              ", Actual format field: ", 
+                              ", Actual format field: ",
                               frame_format));
             return result;
         };
     }; -- compare_payloads()
-    
+
     -- This method is called in post_generate() and also in unpack_payload()
     -- to update the status field according to the detected errors in the
     -- payload.
@@ -189,8 +189,8 @@ struct xserial_frame_payload_s {
         };
 
     }; -- update_status()
-    
-    -- Called by Structured Messages 
+
+    -- Called by Structured Messages
     get_attribute_value(name: string): string is {
         if name == "destination" {
             result = append(destination);
@@ -213,16 +213,16 @@ extend UNDEFINED xserial_frame_payload_s {
     unpack_payload(bitstream : list of bit, check_protocol : bool) is also {
         unpack(packing.low, bitstream[4..11], dummy);
     }; -- unpack_payload()
-    
+
     -- Make sure that if this payload gets printed, the bad frame format
     -- is included in the string.
     nice_string(): string is also {
-        result = appendf("%s BAD_FORMAT:%02b ", 
-                         result, 
+        result = appendf("%s BAD_FORMAT:%02b ",
+                         result,
                          physical_frame_format.as_a(uint(bits:2)));
     }; -- nice_string()
-   
-    
+
+
 }; -- extend UNDEFINED xserial_frame_payload_s
 
 '>
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xserial/e/xserial_frame_payload_message_h.e b/lesson000X_mluvm_svsc/uvm_examples/xserial/e/xserial_frame_payload_message_h.e
index 693b623..04fba75 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xserial/e/xserial_frame_payload_message_h.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xserial/e/xserial_frame_payload_message_h.e
@@ -1,15 +1,15 @@
-/*------------------------------------------------------------------------- 
+/*-------------------------------------------------------------------------
 File name   : xserial_frame_payload_message_h.e
 Title       : XSerial eVC frame payload structure for message frame
 Project     : XSerial eVC
 Created     : 2008
 Description : This file declares the format of the MESSAGE subtype of the
-            : XSerial frame payload. 
-Notes       : 
---------------------------------------------------------------------------- 
+            : XSerial frame payload.
+Notes       :
+---------------------------------------------------------------------------
 Copyright (c) 2008-2010 Cadence Design Systems,Inc.
   All rights reserved worldwide
--------------------------------------------------------------------------*/ 
+-------------------------------------------------------------------------*/
 
 <'
 
@@ -40,7 +40,7 @@ extend MESSAGE xserial_frame_payload_s {
     -- by extending the xserial_frame_message_t type:
     --   IDLE - has no effect - can be used for testing messaging
     --   HALT - indicates to remote end of link that local end cannot
-    --          currently receive any more data 
+    --          currently receive any more data
     --          (e.g. because a FIFO is full).
     --   RESUME - indicates to remote end of link that previous
     --            HALT condition is cancelled.
@@ -56,11 +56,11 @@ extend MESSAGE xserial_frame_payload_s {
             physical_message not in
                 all_values(xserial_frame_message_t).all(it != UNDEFINED).
                        apply(it.as_a(uint));
-    
+
     -- Unpack the message part of a MESSAGE payload
-    unpack_payload_internal(bitstream      : list of bit, 
+    unpack_payload_internal(bitstream      : list of bit,
                             check_protocol : bool) is also {
-    
+
         --unpack the frame_message from the bitstream.
         unpack(packing.low, bitstream[4..11], physical_message);
         if physical_message in all_values(xserial_frame_message_t).
@@ -69,31 +69,31 @@ extend MESSAGE xserial_frame_payload_s {
         } else {
             frame_message = UNDEFINED;
         };
-        
+
         -- Make sure we've got a legal message. We'll assume that if
         -- the user extends xserial_frame_message_t then this makes the
         -- new value a legal message.
         if check_protocol {
             check illegal_frame_msg that frame_message != UNDEFINED
-                else dut_error("Illegal frame_message in MESSAGE frame: ", 
+                else dut_error("Illegal frame_message in MESSAGE frame: ",
                                 physical_message);
         };
-        
+
     }; -- unpack_payload_internal()
-   
+
     -- Add the message value to the 'nice string'.
     nice_string(): string is also {
         result = appendf("%s MESSAGE:%-6s", result, frame_message);
     }; -- nice_string()
-   
+
     -- Compare messages
-    compare_payloads(exp_payload : xserial_frame_payload_s, 
+    compare_payloads(exp_payload : xserial_frame_payload_s,
                      compare_dest : bool) : list of string is also {
         if exp_payload is a MESSAGE xserial_frame_payload_s (m) and
            m.frame_message != frame_message {
-            result.add(append("Expected message: ", 
+            result.add(append("Expected message: ",
                               m.frame_message,
-                              ", Actual message: ", 
+                              ", Actual message: ",
                               frame_message));
         };
     }; -- compare_payloads()
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xserial/e/xserial_monitor.e b/lesson000X_mluvm_svsc/uvm_examples/xserial/e/xserial_monitor.e
index 66b19ca..dd1c5c4 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xserial/e/xserial_monitor.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xserial/e/xserial_monitor.e
@@ -1,4 +1,4 @@
-/*------------------------------------------------------------------------- 
+/*-------------------------------------------------------------------------
 File name   : xserial_monitor.e
 Title       : XSerial monitor unit
 Project     : XSerial eVC
@@ -8,11 +8,11 @@ Notes       : The collector collects all activity on the bus and collects
             : information on each frame that occurs.
             : It passes the collected info, after basic processing, to the
             : monitor.
-            : The monitor performs higher level process, coverage and checks 
---------------------------------------------------------------------------- 
+            : The monitor performs higher level process, coverage and checks
+---------------------------------------------------------------------------
 Copyright (c) 2008 - 2010 Cadence Design Systems,Inc.
   All rights reserved worldwide
--------------------------------------------------------------------------*/ 
+-------------------------------------------------------------------------*/
 
 <'
 
@@ -23,8 +23,8 @@ extend MONITOR xserial_frame_s {
 
     -- This method returns a log file line for this frame.
     package log_frame(direction : xserial_direction_t) : string is {
-        result = appendf("%8d%9d   %-11.11s %s  %s", 
-                         sys.time, inter_frame_delay, name, 
+        result = appendf("%8d%9d   %-11.11s %s  %s",
+                         sys.time, inter_frame_delay, name,
                          direction, nice_string());
     }; -- log_frame()
 
@@ -35,21 +35,21 @@ extend xserial_monitor_u {
     tf_testflow_unit;
     keep soft tf_domain == XSERIAL_TF;
     event tf_phase_clock is only @unqualified_clock_rise;
-    
+
     -- These are the qualified clock events for this direction
     event clock_fall is @collector.clock_fall;
-    
-    -- This method writes a header to the log file with information 
+
+    -- This method writes a header to the log file with information
     -- about what is contained in each column of the log file along with
     -- the date and time the file was created.
     private write_log_header() is {
         -- Write date and time, filename etc. along with field headings to
         -- log file.
-        message(XSERIAL_FILE, LOW, 
-                append(append(file_logger.to_file, ".elog"), 
+        message(XSERIAL_FILE, LOW,
+                append(append(file_logger.to_file, ".elog"),
                        " - created ", date_time()));
         message(XSERIAL_FILE, LOW, "");
-        message(XSERIAL_FILE, LOW, 
+        message(XSERIAL_FILE, LOW,
                 "    TIME    DELAY   ENV         DIR DEST   ",
                 "PAYLOAD        STATUS");
         message(XSERIAL_FILE, LOW,
@@ -62,34 +62,34 @@ extend xserial_monitor_u {
     -- rewritten if reset is reapplied during the test.
     private log_header_written : bool;
         keep log_header_written == FALSE;
-    
+
     -- If this is the beginning of the test, write a file log header. The
     -- log_header_written field is used to prevent the log header being
     -- written again if rerun() is called.
     tf_env_setup()@tf_phase_clock is also {
         write_log_header();
     };
-    
+
     tf_main_test() @tf_phase_clock is also {
         -- Spec says that we should always come out of reset assuming that
         -- remote device is ready to receive data.
-        ready = TRUE; 
+        ready = TRUE;
     };
-    
-    
+
+
     // Implement the started and ended ports
     //
-    
-    started_write(frame :  MONITOR xserial_frame_s) is also { 
+
+    started_write(frame :  MONITOR xserial_frame_s) is also {
         monitor_frame = frame;
-        msg_started(MEDIUM, append(direction, " Monitoring frame"), 
+        msg_started(MEDIUM, append(direction, " Monitoring frame"),
                     monitor_frame);
     };
-    
 
-    
+
+
     ended_write(frame :  MONITOR xserial_frame_s) is also {
-        
+
         -- Analysis the frame, and udpate its fields accordingly
         frame.name = agent.name;
 
@@ -105,18 +105,18 @@ extend xserial_monitor_u {
         num_frames += 1;
         message(XSERIAL_FILE, MEDIUM,
                     monitor_frame.log_frame(direction));
-        message(HIGH, direction, " Monitor detected frame end: ", 
+        message(HIGH, direction, " Monitor detected frame end: ",
                 monitor_frame);
-                
-        msg_ended(MEDIUM, append(direction, " Monitoring frame"), 
+
+        msg_ended(MEDIUM, append(direction, " Monitoring frame"),
                   monitor_frame);
         -- pass to upper components
         frame_ended_o$.write(monitor_frame);
- 
+
         if direction == TX {
             agent.tx_frame = monitor_frame;
             emit agent.tx_frame_done;
-            
+
         } else {
             agent.rx_frame = monitor_frame;
             emit agent.rx_frame_done;
@@ -124,23 +124,23 @@ extend xserial_monitor_u {
     }; // ended_write()
 
 
-    
+
     -- This method returns a string that indicates context. It is used
     -- during error reporting.
     package error_header() : string is {
         result = append(direction, " Monitor");
     }; -- err_header()
 
-    -- This method reports the current status of the monitor.    
+    -- This method reports the current status of the monitor.
     show_status() is {
-        message(LOW, direction, " Monitor detected ", dec(num_frames), 
+        message(LOW, direction, " Monitor detected ", dec(num_frames),
                 " frames");
     }; -- show_status()
 
 
 
-    
-    // Calculate recoreded attributes 
+
+    // Calculate recoreded attributes
     tr_get_attribute_value(inst: any_struct, name: string): string is also {
         if inst is a xserial_frame_s (f) then {
             result = f.get_attribute_value(name);
@@ -148,7 +148,7 @@ extend xserial_monitor_u {
     };
 
 
-}; -- extend xserial_monitor_u 
+}; -- extend xserial_monitor_u
 
 '>
 
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xserial/e/xserial_monitor_h.e b/lesson000X_mluvm_svsc/uvm_examples/xserial/e/xserial_monitor_h.e
index fa4217f..b9ac33c 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xserial/e/xserial_monitor_h.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xserial/e/xserial_monitor_h.e
@@ -1,4 +1,4 @@
-/*------------------------------------------------------------------------- 
+/*-------------------------------------------------------------------------
 File name   : xserial_monitor_h.e
 Title       : XSerial monitor unit public interface
 Project     : XSerial eVC
@@ -12,17 +12,17 @@ Description : The monitor unit implements a monitor for one direction of
             : contains additional information to the GENERIC sub-type) and
             : optionally writes information to a log file.
             : The monitor gets frames that are collected by the collector,
-            : analyzes them, adds to the logs, and performs checks and 
+            : analyzes them, adds to the logs, and performs checks and
             : coverage
-Notes       : 
---------------------------------------------------------------------------- 
+Notes       :
+---------------------------------------------------------------------------
 Copyright (c) 2008-2010 Cadence Design Systems,Inc.
   All rights reserved worldwide
--------------------------------------------------------------------------*/ 
+-------------------------------------------------------------------------*/
 
 <'
 
-package cdn_xserial; 
+package cdn_xserial;
 
 
 
@@ -31,8 +31,8 @@ package cdn_xserial;
 extend message_tag: [XSERIAL_FILE];
 
 
--- This unit contains a monitor that is capable of monitoring traffic in 
--- one direction on an XSerial link. Two instances of this unit are 
+-- This unit contains a monitor that is capable of monitoring traffic in
+-- one direction on an XSerial link. Two instances of this unit are
 -- required to monitor a bidirectional link.
 unit xserial_monitor_u like uvm_monitor {
 
@@ -44,60 +44,60 @@ unit xserial_monitor_u like uvm_monitor {
     -- direction.
     direction : xserial_direction_t;
 
-    -- This field controls whether the monitor should collect 
+    -- This field controls whether the monitor should collect
     -- coverage information
     has_coverage : bool;
 
     -- This is the logger used for creating log files.
-    file_logger : message_logger is instance;    
+    file_logger : message_logger is instance;
         keep file_logger.tags == {XSERIAL_FILE};
         keep soft file_logger.to_screen == FALSE;
         keep soft file_logger.format == none;
         keep soft file_logger.verbosity == FULL;
 
-    
+
     -- If this field is TRUE then the agent does protocol checking
     has_protocol_checker : bool;
 
-    
-    -- This field is a pointer to the monitor for the reverse link 
-    -- direction. If such a monitor does not exist (perhaps one link 
+
+    -- This field is a pointer to the monitor for the reverse link
+    -- direction. If such a monitor does not exist (perhaps one link
     -- direction has been disabled), then this field will be NULL.
     !reverse_monitor : xserial_monitor_u;
-    
+
     -- This field indicates whether the device sending the frames that this
     -- monitor is monitoring is currently ready to receive frames or not.
     !ready : bool;
-     
+
     -- The monitored frame is built up in this field.
     !monitor_frame : MONITOR xserial_frame_s;
-    
+
     -- This field counts the number of frames this monitor detects over the
     -- duration of the test.
     num_frames : uint;
         keep num_frames == 0;
-    
+
     -- Getting infomration from the collector
     frame_started_ei : in event_port is instance;
         keep bind (frame_started_ei, collector.frame_started_eo);
-        
+
     frame_ended_ei : in event_port is instance;
         keep bind (frame_ended_ei, collector.frame_ended_eo);
 
     -- This event is emitted at the start of a frame.
     event frame_started is @frame_started_ei$;
-    
+
     -- This event is emitted at the end of a frame.
     event frame_ended is @frame_ended_ei$;
 
-    
+
     -- These ports get collected frames from the collector
     frame_started_i : in interface_port of tlm_analysis
                                         of MONITOR xserial_frame_s
                                         using prefix=started_
                                         is instance;
         keep bind (frame_started_i, collector.frame_started_o);
-    
+
     started_write(frame :  MONITOR xserial_frame_s) is { };
 
     frame_ended_i : in interface_port of tlm_analysis
@@ -106,21 +106,21 @@ unit xserial_monitor_u like uvm_monitor {
                                           is instance;
         keep bind (frame_ended_i, collector.frame_ended_o);
     ended_write(frame :  MONITOR xserial_frame_s) is { };
-   
+
 
     -- This port passes collected frames to upper components
     -- By default - bound to empty.
-    frame_ended_o : out interface_port of tlm_analysis of MONITOR 
+    frame_ended_o : out interface_port of tlm_analysis of MONITOR
                                            xserial_frame_s is instance;
         keep bind (frame_ended_o, empty);
-    
-    
+
+
     -- Passing events to upper components
     frame_started_eo : out event_port is instance;
         keep bind (frame_started_eo, empty);
     on frame_started { emit frame_started_eo$;};
 
-    
+
     event clock_rise is cycle @collector.clock_rise;
     event unqualified_clock_rise is cycle @collector.unqualified_clock_rise;
 }; -- extend  xserial_monitor_u
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xserial/e/xserial_port_config.e b/lesson000X_mluvm_svsc/uvm_examples/xserial/e/xserial_port_config.e
index d04cdea..86c9ea0 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xserial/e/xserial_port_config.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xserial/e/xserial_port_config.e
@@ -1,15 +1,15 @@
-/*------------------------------------------------------------------------- 
+/*-------------------------------------------------------------------------
 File name   : xserial_port_config.e
 Title       : Port config
 Project     : 2008
-Developers  : 
+Developers  :
 Created     : 2008
 Description : This file binds the signal ports to external
-Notes       : 
---------------------------------------------------------------------------- 
+Notes       :
+---------------------------------------------------------------------------
 Copyright (c) 2008-2010 Cadence Design Systems,Inc.
   All rights reserved worldwide
--------------------------------------------------------------------------*/ 
+-------------------------------------------------------------------------*/
 
 <'
 package cdn_xserial;
@@ -31,15 +31,15 @@ extend xserial_env_u {
 };
 
 
-extend xserial_collector_u { 
+extend xserial_collector_u {
     keep bind(sig_clock, external);
     keep bind(sig_data, external);
-  
-    when TX xserial_collector_u { 
+
+    when TX xserial_collector_u {
         keep soft sig_clock.hdl_path() == "xserial_tx_clock";
         keep soft sig_data.hdl_path() == "xserial_tx_data";
     };
-     when RX xserial_collector_u { 
+     when RX xserial_collector_u {
         keep soft sig_clock.hdl_path() == "xserial_rx_clock";
         keep soft sig_data.hdl_path() == "xserial_rx_data";
     };
@@ -49,9 +49,9 @@ extend xserial_collector_u {
 extend xserial_bfm_u {
     keep bind(sig_tx_clock, external);
     keep bind(sig_tx_data, external);
-  
+
     keep soft sig_tx_clock.hdl_path() == "xserial_tx_clock";
     keep soft sig_tx_data.hdl_path() == "xserial_tx_data";
-}; -- extend xserial_bfm_u 
+}; -- extend xserial_bfm_u
 
 '>
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xserial/e/xserial_protocol_checker.e b/lesson000X_mluvm_svsc/uvm_examples/xserial/e/xserial_protocol_checker.e
index c980770..2207422 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xserial/e/xserial_protocol_checker.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xserial/e/xserial_protocol_checker.e
@@ -1,15 +1,15 @@
-/*------------------------------------------------------------------------- 
+/*-------------------------------------------------------------------------
 File name   : xserial_protocol_checker.e
-Title       : Protocol checker 
+Title       : Protocol checker
 Project     : XSerial eVC
 Created     : 2008
-Description : This file contains the optional protocol checker 
+Description : This file contains the optional protocol checker
             : functionality within the monitor.
-Notes       : 
---------------------------------------------------------------------------- 
+Notes       :
+---------------------------------------------------------------------------
 Copyright (c) 2008-2010 Cadence Design Systems,Inc.
   All rights reserved worldwide
--------------------------------------------------------------------------*/ 
+-------------------------------------------------------------------------*/
 
 <'
 
@@ -18,34 +18,34 @@ package cdn_xserial;
 extend has_protocol_checker xserial_monitor_u {
 
     -- This event is emitted in each clock cycle where the remote device
-    -- has signalled that it is not ready to receive data frames. 
+    -- has signalled that it is not ready to receive data frames.
     -- The falling edge of clock is used to ensure that there are no race
     -- conditions in the case where both monitors are clocked off the same
     -- clock signal. If the rising edge is used then the order in which the
     -- RX and TX monitors
     -- react to the rising edge of clock can affect the protocol checker.
-    event halted is true((reverse_monitor != NULL) and 
+    event halted is true((reverse_monitor != NULL) and
                          (not reverse_monitor.ready)) @clock_fall;
-                         
+
     -- This event is the same as halted but delayed to the next rising
     -- edge of clock.
     event halted_del is {@halted; [1]} @clock_rise;
 
     -- This event is emitted each time a frame starts while the remote
-    -- device is not ready. 
-    event frame_start_halted is (@halted_del and 
+    -- device is not ready.
+    event frame_start_halted is (@halted_del and
                                  @frame_started and
                                  @halted)
                                                           @clock_rise;
-             
+
     -- This event is emitted each time a message frame ends
     event message_frame_ended is
-        true(monitor_frame.payload is a MESSAGE xserial_frame_payload_s) 
+        true(monitor_frame.payload is a MESSAGE xserial_frame_payload_s)
                                                               @frame_ended;
-             
-    -- At the end of each frame, check that either it was a message frame 
-    -- or the remote device hadn't signalled a HALT before the start of 
-    -- the frame. Only message frames are allowed to start while the 
+
+    -- At the end of each frame, check that either it was a message frame
+    -- or the remote device hadn't signalled a HALT before the start of
+    -- the frame. Only message frames are allowed to start while the
     -- remote device is not ready.
     expect exp_send_while_not_ready is
         (not @frame_start_halted) or @message_frame_ended @frame_ended
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xserial/e/xserial_sequence_h.e b/lesson000X_mluvm_svsc/uvm_examples/xserial/e/xserial_sequence_h.e
index 0370653..dcafd13 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xserial/e/xserial_sequence_h.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xserial/e/xserial_sequence_h.e
@@ -1,4 +1,4 @@
-/*------------------------------------------------------------------------- 
+/*-------------------------------------------------------------------------
 File name   : xserial_sequence_h.e
 Title       : Xserial Sequence
 Project     : XSerial eVC
@@ -6,10 +6,10 @@ Created     : 2008
 Description : This file implements sequences.
 Notes       : See Sequence documentation for more information about how
             : sequences work.
---------------------------------------------------------------------------- 
+---------------------------------------------------------------------------
 Copyright (c) 2008-2010 Cadence Design Systems,Inc.
   All rights reserved worldwide
--------------------------------------------------------------------------*/ 
+-------------------------------------------------------------------------*/
 
 <'
 
@@ -26,11 +26,11 @@ type xserial_env_name_t : [];
 -- interface.
 extend TX xserial_frame_s {
 
-    -- This field can be used to sub-type the TX frame according to the 
+    -- This field can be used to sub-type the TX frame according to the
     -- eVC instance that is sending it.
     name : xserial_env_name_t;
         keep name == read_only(driver).name;
-    
+
     -- This field controls the delay before transmission of this frame in
     -- clock cycles - timed from the end of the previous frame.
     transmit_delay : uint;
@@ -40,14 +40,14 @@ extend TX xserial_frame_s {
 
 
 -- This is the generic sequence struct for transmitting frames from the eVC.
-sequence xserial_sequence using 
+sequence xserial_sequence using
     testflow = TRUE,
-    item=TX xserial_frame_s, 
+    item=TX xserial_frame_s,
     created_driver=xserial_driver_u;
 
 
--- Provide extensions to the sequence driver so that the driver, 
--- the sequence and the sequence items can all be sub-typed by the 
+-- Provide extensions to the sequence driver so that the driver,
+-- the sequence and the sequence items can all be sub-typed by the
 -- instance name of the eVC.
 extend xserial_driver_u {
     keep soft tf_domain == XSERIAL_TF;
@@ -62,19 +62,19 @@ extend xserial_sequence {
     -- This field allows sequences to be sub-typed on the name of the env.
     name : xserial_env_name_t;
         keep name == read_only(driver).name;
- 
+
     -- This is a utility field for basic sequences. This allows the user to
     -- do "do frame ...".
     !frame: TX xserial_frame_s;
 
-    // Cover the sequence. 
+    // Cover the sequence.
     // Ignore the pre-defined kinds, they do not add info to the coverage
     cover ended is {
         item kind using ignore = (kind == RANDOM or
                                   kind == SIMPLE or
                                   kind == MAIN);
-    }; 
-    
+    };
+
 }; -- extend xserial_sequence
 
 
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xserial/e/xserial_top.e b/lesson000X_mluvm_svsc/uvm_examples/xserial/e/xserial_top.e
index 0f0919e..9c9781d 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xserial/e/xserial_top.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xserial/e/xserial_top.e
@@ -1,4 +1,4 @@
-/*------------------------------------------------------------------------- 
+/*-------------------------------------------------------------------------
 File name   : xserial_top.e
 Title       : Top level of XSerial eVC
 Project     : XSerial eVC
@@ -6,10 +6,10 @@ Created     : 2008
 Description : This file imports all files in the eVC
 Notes       : Files ending in _h.e are public files for the user to read
             : all other files could potentially be encrypted.
---------------------------------------------------------------------------- 
+---------------------------------------------------------------------------
 Copyright (c) 2008-2010 Cadence Design Systems,Inc.
 All rights reserved worldwide
--------------------------------------------------------------------------*/ 
+-------------------------------------------------------------------------*/
 
 <'
 
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xserial/e/xserial_types_h.e b/lesson000X_mluvm_svsc/uvm_examples/xserial/e/xserial_types_h.e
index 274d78c..5f739a8 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xserial/e/xserial_types_h.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xserial/e/xserial_types_h.e
@@ -1,15 +1,15 @@
-/*------------------------------------------------------------------------- 
+/*-------------------------------------------------------------------------
 File name   : xserial_types_h.e
 Title       : Common type declarations
-Project     : UVM XSerial eVC 
-Developers  :  
+Project     : UVM XSerial eVC
+Developers  :
 Created     : 2008
 Description : This file declares common types used throughout the eVC.
-Notes       : 
---------------------------------------------------------------------------- 
+Notes       :
+---------------------------------------------------------------------------
 Copyright (c) 2008-2010 Cadence Design Systems,Inc.
 All rights reserved worldwide
--------------------------------------------------------------------------*/ 
+-------------------------------------------------------------------------*/
 
 <'
 
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xserial/examples/test_1.e b/lesson000X_mluvm_svsc/uvm_examples/xserial/examples/test_1.e
index 448eeaa..6845558 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xserial/examples/test_1.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xserial/examples/test_1.e
@@ -1,14 +1,14 @@
-/*------------------------------------------------------------------------- 
+/*-------------------------------------------------------------------------
 File name   : test_1.e
 Title       : XSerial eVC demo - example testcase file
 Project     : XSerial eVC
 Created     : 2008
 Description : Example testcase file for demo purposes
-Notes       : 
---------------------------------------------------------------------------- 
+Notes       :
+---------------------------------------------------------------------------
 Copyright (c) 2008-2010 Cadence Design Systems,Inc.
   All rights reserved worldwide.
-----------------------------------------------------------------------------*/ 
+----------------------------------------------------------------------------*/
 
 <'
 
@@ -21,7 +21,7 @@ extend sys {
         -- Print in hexadecimal by default
         set_config(print, radix, hex);
     };
-    
+
 }; -- extend sys
 
 extend XSERIAL_A MAIN MAIN_TEST xserial_sequence {
@@ -30,7 +30,7 @@ extend XSERIAL_A MAIN MAIN_TEST xserial_sequence {
 
 extend XSERIAL_B MAIN MAIN_TEST xserial_sequence {
     keep count == 20;
-};  
+};
 
 extend XSERIAL_C MAIN MAIN_TEST  xserial_sequence {
     keep count == 10;
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xserial/examples/test_error_injection.e b/lesson000X_mluvm_svsc/uvm_examples/xserial/examples/test_error_injection.e
index bfb7cc8..dd18468 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xserial/examples/test_error_injection.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xserial/examples/test_error_injection.e
@@ -1,4 +1,4 @@
-/*------------------------------------------------------------------------- 
+/*-------------------------------------------------------------------------
 File name   : test_error_injection.e
 Title       : XSerial eVC demo - example testcase file
 Project     : XSerial eVC
@@ -8,10 +8,10 @@ Notes       : This test case introduces bad format and parity errors randomly
             : on the output of the XSERIAL_A instance of the XSerial eVC.
             : Note that the DUT discards any frames with parity errors (and
             : flags this using the appropriate port error signal).
---------------------------------------------------------------------------- 
+---------------------------------------------------------------------------
 Copyright (c) 2008-2010 Cadence Design Systems,Inc.
   All rights reserved worldwide.
-----------------------------------------------------------------------------*/ 
+----------------------------------------------------------------------------*/
 
 <'
 
@@ -24,7 +24,7 @@ extend sys {
         -- Print in hexadecimal by default
         set_config(print, radix, hex);
     };
-    
+
 }; -- extend sys
 
 extend XSERIAL_A MAIN MAIN_TEST xserial_sequence {
@@ -33,7 +33,7 @@ extend XSERIAL_A MAIN MAIN_TEST xserial_sequence {
 
 extend XSERIAL_B MAIN MAIN_TEST xserial_sequence {
     keep count == 20;
-};  
+};
 
 extend XSERIAL_C MAIN MAIN_TEST xserial_sequence {
     keep count == 10;
@@ -51,7 +51,7 @@ extend XSERIAL_A TX xserial_frame_s {
     keep soft payload.frame_format == select {
         30 : UNDEFINED;
         70 : DATA;
-    };    
+    };
     keep soft bad_parity == select {
         30 : TRUE;
         70 : FALSE;
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xserial/examples/test_item_constraint.e b/lesson000X_mluvm_svsc/uvm_examples/xserial/examples/test_item_constraint.e
index cef8d74..36f864f 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xserial/examples/test_item_constraint.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xserial/examples/test_item_constraint.e
@@ -1,17 +1,17 @@
-/*------------------------------------------------------------------------- 
+/*-------------------------------------------------------------------------
 File name   : test_item_constraint.e
 Title       : XSerial eVC demo - example testcase file
 Project     : XSerial eVC
 Created     : 2008
-Description : Example file for item constraint demonstration. MAIN is calling 
-              MID_LAYER sequence which in turn calls LOW_LAYER which does an 
+Description : Example file for item constraint demonstration. MAIN is calling
+              MID_LAYER sequence which in turn calls LOW_LAYER which does an
               item. using the item constraint macro, we influence the item
               generation from a top layer sequence.
-Notes       : 
---------------------------------------------------------------------------- 
+Notes       :
+---------------------------------------------------------------------------
 Copyright (c) 2008-2010 Cadence Design Systems,Inc.
   All rights reserved worldwide.
-----------------------------------------------------------------------------*/ 
+----------------------------------------------------------------------------*/
 
 <'
 
@@ -24,8 +24,8 @@ extend sys {
         -- Print in hexadecimal by default
         set_config(print, radix, hex);
     };
-    
-}; 
+
+};
 
 extend xserial_sequence_kind:[MID_LAYER, LOW_LAYER];
 
@@ -44,19 +44,19 @@ extend XSERIAL_A LOW_LAYER MAIN_TEST xserial_sequence {
 };
 
 
-// set a constraint on the item that is generated in a low layer sequence 
+// set a constraint on the item that is generated in a low layer sequence
 item_constraint TX xserial_frame_s.set_payload {
     payload.frame_format == DATA; //|block of constraints
-    payload.DATA'data == 5;       //| 
+    payload.DATA'data == 5;       //|
 };
 
 
 
 extend XSERIAL_A MAIN MAIN_TEST xserial_sequence {
     !sub_seq: XSERIAL_A MID_LAYER MAIN_TEST xserial_sequence;
-    
+
     body() @driver.clock is only {
-        // activating the sequence with the keyword results in the block 
+        // activating the sequence with the keyword results in the block
         // of constraints being executed during item generation.
         do set_payload sub_seq;
     };
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xserial/examples/test_multi_reset.e b/lesson000X_mluvm_svsc/uvm_examples/xserial/examples/test_multi_reset.e
index 0827a54..cdcf047 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xserial/examples/test_multi_reset.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xserial/examples/test_multi_reset.e
@@ -1,15 +1,15 @@
-/*------------------------------------------------------------------------- 
+/*-------------------------------------------------------------------------
 File name   : test_multi_reset.e
 Title       : XSerial demo of multiple resets
 Project     : XSerial eVC
 Created     : 2008
 Description : Example testcase file for demo purposes - demonstrates
             : multiple resets.
-Notes       : 
---------------------------------------------------------------------------- 
+Notes       :
+---------------------------------------------------------------------------
 Copyright (c) 2008-2010 Cadence Design Systems,Inc.
   All rights reserved worldwide.
-----------------------------------------------------------------------------*/ 
+----------------------------------------------------------------------------*/
 
 <'
 
@@ -22,7 +22,7 @@ extend sys {
         -- Print in hexadecimal by default
         set_config(print, radix, hex);
     };
-    
+
 }; -- extend sys
 
 extend XSERIAL_A MAIN MAIN_TEST xserial_sequence {
@@ -47,7 +47,7 @@ extend xserial_frame_payload_s {
 
 
 extend xserial_env_u {
-    
+
     // One of the envs resets the environment during the run
     when XSERIAL_A xserial_env_u {
     do_extra_reset() @sys.any is {
@@ -55,20 +55,20 @@ extend xserial_env_u {
         agent.sig_reset$ = 1;
         wait [5];
         agent.sig_reset$ = 0;
-        
+
         message(LOW, "Calling rerun_phase(RESET)");
         agent.tf_get_domain_mgr().rerun_phase(RESET);
      }; -- do_extra_reset()
-    
+
     run() is also {
         start do_extra_reset();
     }; -- run()
-        
+
     };
-    
-    
+
+
     event device_reset is cycle @agent.reset_start;
-    
+
     on device_reset {
         // Inform the verification env about the reset
         agent.tf_get_domain_mgr().rerun_phase(RESET);
@@ -94,5 +94,5 @@ extend sys {
     };
 };
 
-   
+
 '>
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xserial/examples/test_reconfiguration.e b/lesson000X_mluvm_svsc/uvm_examples/xserial/examples/test_reconfiguration.e
index ca3880f..f89a61e 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xserial/examples/test_reconfiguration.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xserial/examples/test_reconfiguration.e
@@ -1,18 +1,18 @@
-/*------------------------------------------------------------------------- 
+/*-------------------------------------------------------------------------
 File name   : test_reconfiguration.e
 Title       : XSerial demo of multiple configurations
 Project     : XSerial eVC
 Created     : 2008
 Description : This file demonstrates the ability of the eVC to cope with
-            : multiple configurations. 
-            :  
+            : multiple configurations.
+            :
             : Call xserial_env configure method several times, each time
             : with different set of parameters, and check the result.
-Notes       : 
---------------------------------------------------------------------------- 
+Notes       :
+---------------------------------------------------------------------------
 Copyright (c) 2008-2010 Cadence Design Systems,Inc.
   All rights reserved worldwide.
-----------------------------------------------------------------------------*/ 
+----------------------------------------------------------------------------*/
 
 <'
 
@@ -25,7 +25,7 @@ extend sys {
         -- Print in hexadecimal by default
         set_config(print, radix, hex);
     };
-    
+
 }; -- extend sys
 
 extend XSERIAL_A MAIN MAIN_TEST xserial_sequence {
@@ -53,14 +53,14 @@ extend XSERIAL_A xserial_env_u {
     run() is also {
          message(LOW, "Config mode to SLOW");
         //            ----------------------------------------
-        uvm_configure 1 me {mode} 
+        uvm_configure 1 me {mode}
                                {xserial_mode_t'SLOW};
-               
+
         // Check:
         check that config.params.mode == SLOW else
           dut_error("1st configuration failed, config.params.mode == ",
-                    config.params.mode);         
-    };   
+                    config.params.mode);
+    };
 };
 
 
@@ -70,26 +70,26 @@ extend sys {
          message(LOW, "Config XSERIAL_1 mode to NORMAL");
         //            ----------------------------------------
         uvm_configure 2 xserial_evcs[1] {mode} {xserial_mode_t'NORMAL};
-               
+
         // Check:
         check that xserial_evcs[1].config.params.mode == NORMAL else
           dut_error("2nd configuration failed, ",
                     "xserial_evcs[1].config.params.mode == ",
-                    xserial_evcs[1].config.params.mode);    
-        
+                    xserial_evcs[1].config.params.mode);
+
          message(LOW, "Config XSERIAL_2 mode to FAST");
         //            ----------------------------------------
         uvm_configure 3 xserial_evcs[2] {mode} {xserial_mode_t'FAST};
-               
+
         // Check:
         check that xserial_evcs[2].config.params.mode == FAST else
           dut_error("3rd configuration failed, ",
                     "xserial_evcs[2].config.params.mode == ",
-                    xserial_evcs[2].config.params.mode);         
+                    xserial_evcs[2].config.params.mode);
+
+
+    };
 
-    
-    };   
-    
 };
 
 '>
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xserial/examples/xserial_config.e b/lesson000X_mluvm_svsc/uvm_examples/xserial/examples/xserial_config.e
index a46fa45..07f5472 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xserial/examples/xserial_config.e
+++ b/lesson000X_mluvm_svsc/uvm_examples/xserial/examples/xserial_config.e
@@ -1,4 +1,4 @@
-/*------------------------------------------------------------------------- 
+/*-------------------------------------------------------------------------
 File name   : xserial_config.e
 Title       : XSerial eVC example config file
 Project     : XSerial eVC
@@ -8,10 +8,10 @@ Description : Provides XSerial eVC configuration that is common to all test
 Notes       : The DUT for this demonstration verification environment is
             : a 3 input, 3 output router. See the EXAMPLES_README file
             : for more info.
---------------------------------------------------------------------------- 
+---------------------------------------------------------------------------
 Copyright (c) 2008-2010 Cadence Design Systems,Inc.
   All rights reserved worldwide
--------------------------------------------------------------------------*/ 
+-------------------------------------------------------------------------*/
 
 <'
 
@@ -20,7 +20,7 @@ import xserial/e/xserial_top;
 
 import xserial/e/xserial_port_config;
 
--- Create a logical name for each eVC instance. 
+-- Create a logical name for each eVC instance.
 extend xserial_env_name_t : [XSERIAL_A, XSERIAL_B, XSERIAL_C];
 
 -- Instantiate the eVC instances under sys.
@@ -69,7 +69,7 @@ extend XSERIAL_A xserial_agent_u {
 extend XSERIAL_B xserial_agent_u {
     -- eVC does not drive clock
     keep tx_clock_period == 0;
-    
+
     -- These are the signal names for this agent
     keep sig_tx_clock.hdl_path() == "clock";
     keep sig_tx_data.hdl_path()  == "port_b_in_data";
@@ -82,7 +82,7 @@ extend XSERIAL_B xserial_agent_u {
 extend XSERIAL_C xserial_agent_u {
     -- eVC does not drive clock
     keep tx_clock_period == 0;
-    
+
     -- These are the signal names for this agent
     keep sig_tx_clock.hdl_path() == "clock";
     keep sig_tx_data.hdl_path()  == "port_c_in_data";
@@ -97,7 +97,7 @@ extend XSERIAL_C xserial_agent_u {
 extend xserial_agent_u {
     keep tx_log_filename == append(name, "_tx");
     keep rx_log_filename == append(name, "_rx");
-}; 
+};
 
 
 
@@ -107,7 +107,7 @@ extend xserial_agent_u {
 extend sys {
     init() is also {
         // Use a performance enhancement feature
-        set_config(simulation, enable_ports_unification, TRUE);   
+        set_config(simulation, enable_ports_unification, TRUE);
     };
 };
 '>
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xserial/v/dut.v b/lesson000X_mluvm_svsc/uvm_examples/xserial/v/dut.v
index 2b8c21c..ec0e3ce 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xserial/v/dut.v
+++ b/lesson000X_mluvm_svsc/uvm_examples/xserial/v/dut.v
@@ -5,7 +5,7 @@
 //Developers  : Richard Vialls
 //Created     : 09-May-2002
 //Description : A simple 3 input, 3 output router
-//Notes       : 
+//Notes       :
 //---------------------------------------------------------------------------
 //Copyright (c) 2005-20010 Cadence Design Systems, Inc. All rights reserved worldwide.
 //Please refer to the terms and conditions in $IPCM_HOME.
@@ -26,7 +26,7 @@ module router (reset,
 
    input reset;
    input clock;
-   
+
    input port_a_in_data;
    output port_a_err;
    output port_a_out_data;
@@ -41,7 +41,7 @@ module router (reset,
 
    wire   reset;
    wire   clock;
-   
+
    wire   port_a_in_data;
    wire   port_a_err;
    wire   port_a_out_data;
@@ -54,8 +54,8 @@ module router (reset,
    wire   port_c_err;
    wire   port_c_out_data;
 
-   
- 
+
+
    wire [1:0] id_a;
    assign id_a = 2'b00;
 
@@ -93,7 +93,7 @@ module router (reset,
    reg [11:0]  data_bus;
    reg         data_bus_valid;
    wire        full;
-   
+
 
 
    in_channel in_port_a(.clock(clock),
@@ -107,7 +107,7 @@ module router (reset,
                         .flow_req(chan_a_flow_req),
                         .flow_halt(chan_a_flow_halt),
                         .flow_ack(chan_a_flow_ack));
-   
+
    in_channel in_port_b(.clock(clock),
                         .reset(reset),
                         .in_data(port_b_in_data),
@@ -131,12 +131,12 @@ module router (reset,
                         .flow_req(chan_c_flow_req),
                         .flow_halt(chan_c_flow_halt),
                         .flow_ack(chan_c_flow_ack));
-   
-  
-  
-  
- 
- 
+
+
+
+
+
+
    out_channel out_port_a(.id(id_a),
                           .clock(clock),
                           .reset(reset),
@@ -149,7 +149,7 @@ module router (reset,
                           .full(chan_a_full),
                           .halted(chan_a_halted),
                           .out_data(port_a_out_data));
-   
+
    out_channel out_port_b(.id(id_b),
                           .clock(clock),
                           .reset(reset),
@@ -162,7 +162,7 @@ module router (reset,
                           .full(chan_b_full),
                           .halted(chan_b_halted),
                           .out_data(port_b_out_data));
-      
+
    out_channel out_port_c(.id(id_c),
                           .clock(clock),
                           .reset(reset),
@@ -175,16 +175,16 @@ module router (reset,
                           .full(chan_c_full),
                           .halted(chan_c_halted),
                           .out_data(port_c_out_data));
-   
-  
+
+
    // If any of the output FIFOs are full, then we cannot guarantee
    // to be able to route a frame, so stall the router.
    assign full = chan_a_full | chan_b_full | chan_c_full;
-   
+
    // This process is the actual router. Frames from each of the
    // input channels are merged onto a single data bus (the channels
    // are prioritised, A, B then C). Each output channel then only
-   // picks off the frames that are addressed to it. 
+   // picks off the frames that are addressed to it.
    always@(reset or full or chan_a_valid or chan_a_data
            or chan_b_valid or chan_b_data or chan_c_valid
            or chan_c_data)
@@ -195,7 +195,7 @@ module router (reset,
                chan_b_ack <= 1'b0;
                chan_c_ack <= 1'b0;
             end // if (reset == 1'b1)
-         else 
+         else
             begin
                if ((chan_a_valid == 1'b1) && (full == 1'b0))
                   begin
@@ -217,7 +217,7 @@ module router (reset,
                            chan_b_ack <= 1'b1;
                            chan_c_ack <= 1'b0;
                         end // if ((chan_b_valid == 1'b1) && (full == 1'b0))
-                     else 
+                     else
                         begin
                            if ((chan_c_valid == 1'b1) && (full == 1'b0))
                               begin
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xserial/v/dut_if_wrapper.sv b/lesson000X_mluvm_svsc/uvm_examples/xserial/v/dut_if_wrapper.sv
index 300345f..c06d68a 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xserial/v/dut_if_wrapper.sv
+++ b/lesson000X_mluvm_svsc/uvm_examples/xserial/v/dut_if_wrapper.sv
@@ -1,12 +1,12 @@
-/*------------------------------------------------------------------------- 
+/*-------------------------------------------------------------------------
 File name   : dut_if_wrap.sv
 Title       : XSerial router wrapper (using a interface)
 Project     : XSerial golden example
-Developers  : 
-Created     : 
-Description : [Future] This file defines a module that wraps the XSerial 
+Developers  :
+Created     :
+Description : [Future] This file defines a module that wraps the XSerial
             : router DUT and defines an interface port.
-Notes       : 
+Notes       :
               This file is NOT currently used by the scripts, until modport
               expressions are supported.
 
@@ -16,7 +16,7 @@ Please refer to the terms and conditions in $IPCM_HOME.
 ------------------------------------------------------------------- */
 
 
- 
+
  module dut_wrap (interface dut_if);
 
    router dut(
@@ -31,6 +31,6 @@ Please refer to the terms and conditions in $IPCM_HOME.
               .port_c_in_data(     dut_if.port_c_in_data),
               .port_c_err(         dut_if.port_c_err),
               .port_c_out_data(    dut_if.port_c_out_data)   );
-   
+
 endmodule : dut_wrap
 
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xserial/v/in_chan.v b/lesson000X_mluvm_svsc/uvm_examples/xserial/v/in_chan.v
index 4dd269f..290a11b 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xserial/v/in_chan.v
+++ b/lesson000X_mluvm_svsc/uvm_examples/xserial/v/in_chan.v
@@ -5,7 +5,7 @@
 //Developers  : Richard Vialls
 //Created     : 09-May-2002
 //Description : Input deserialiser and FIFO for 1 input channel of routerC
-//Notes       : 
+//Notes       :
 //---------------------------------------------------------------------------
 //Copyright (c) 2005-20010 Cadence Design Systems, Inc. All rights reserved worldwide.
 //Please refer to the terms and conditions in $IPCM_HOME.
@@ -33,54 +33,54 @@ module in_channel(clock,
    output        flow_req;
    output        flow_halt;
    input         flow_ack;
-   
-   
+
+
    wire          clock;
    wire          reset;
    wire          in_data;
    reg           err;
    wire [11:0]   out_data;
-   
+
    reg           out_valid;
    wire          out_ack;
    reg           halted;
    wire          flow_req;
    wire          flow_halt;
    wire          flow_ack;
-   
+
    // This is the input channel FIFO
    reg [11:0]    fifo [0:3] ;
-      
+
    // collect_count counts the bits of the frame as it is collected
    reg [3:0]     collect_count;
-   
+
    // input frame is latched in following signal
    reg [12:0]    collector;
-  
+
    // temporary signal for parity calculation
    reg           parity;
-   
+
    // in_valid is high for the clock cycle in which collector contains valid data
    reg           in_valid;
 
    // FIFO write pointer
    reg [1:0]     write_ptr;
-  
+
    // FIFO read pointer
    reg [1:0]     read_ptr;
-  
+
    // Counts current number of items in FIFO
    reg [2:0]     item_count;
-  
+
    // High causes write to FIFO
    reg           write_fifo;
-  
+
    // High causes read from FIFO
    wire          read_fifo;
-  
+
    // Local copy of flow_req
    reg           flow_req_int;
-  
+
    // Local copy of flow_halt
    reg           flow_halt_int;
 
@@ -98,9 +98,9 @@ module in_channel(clock,
                parity <= parity ^ in_data;
             end // else: !if(collect_count != 4'b1101)
       end // always@ (posedge clock)
-   
-  
-   // This process determines when collector contains a valid frame. 
+
+
+   // This process determines when collector contains a valid frame.
    always@(posedge clock)
       begin
          if (reset == 1'b1)
@@ -122,12 +122,12 @@ module in_channel(clock,
 
 
    assign out_data = fifo[read_ptr];
-   
 
 
-   
 
-  
+
+
+
    // This process counts the incoming bits from the port
    always@(posedge clock)
       begin
@@ -150,8 +150,8 @@ module in_channel(clock,
                   end // else: !if(collect_count == 4'b0000)
             end // else: !if(reset == 1'b1)
       end // always@ (posedge clock)
-   
-  
+
+
    // This process collects the incoming frame
    always@(posedge clock)
       begin
@@ -161,8 +161,8 @@ module in_channel(clock,
                collector[12] <= in_data;
             end // if (collect_count != 4'b0000)
       end // always@ (posedge clock)
-      
-  
+
+
    // This process drives the err signal if a parity error is detected.
    always@(posedge clock)
       begin
@@ -178,8 +178,8 @@ module in_channel(clock,
                   end // if (in_valid == 1'b1)
             end // else: !if(reset == 1'b1)
       end // always@ (posedge clock)
-   
-         
+
+
    // This process writes non-message frames to the FIFO.
    always@(in_valid or parity or collector)
       begin
@@ -192,7 +192,7 @@ module in_channel(clock,
                write_fifo <= 1'b0;
             end // else: !if((in_valid == 1'b1) && (parity == 1'b0) && (collector[3:2] != 2'b01))
       end // always@ (in_valid or parity or collector)
-   
+
    // This process processes HALT and RESUME messages and drives halted to the
    // rest of the system.
    always@(posedge clock)
@@ -216,8 +216,8 @@ module in_channel(clock,
                   end // else: !if((in_valid == 1'b1) && (parity == 1'b0) && (collector[11:2] == 10'b0000000101))
             end // else: !if(reset == 1'b1)
       end // always@ (posedge clock)
-   
-    
+
+
    // This process handles the write pointer for the FIFO
    always@(posedge clock)
       begin
@@ -232,11 +232,11 @@ module in_channel(clock,
                   write_ptr <= write_ptr +1;
                end // if (write_fifo == 1'b1)
       end // always@ (posedge clock)
-   
-    
+
+
    // The FIFO is read each time the out_ack signal is asserted.
    assign read_fifo = out_ack;
-  
+
    // This process handles the read pointer for the FIFO
    always@(posedge clock)
       begin
@@ -252,7 +252,7 @@ module in_channel(clock,
                   end // if (read_fifo == 1'b1)
             end // else: !if(reset == 1'b1)
       end // always@ (posedge clock)
-   
+
 
    // This process keeps track of how many items are currently in the FIFO.
    always@(posedge clock)
@@ -277,7 +277,7 @@ module in_channel(clock,
             end // else: !if(reset == 1'b1)
       end // always@ (posedge clock)
 
-   
+
    // This process determines when the FIFO contains valid data that
    // can be routed to an output channel.
    always@(reset or item_count)
@@ -299,14 +299,14 @@ module in_channel(clock,
             end // else: !if(reset == 1'b1)
       end // always@ (reset or item_count)
 
-  
-       
+
+
    // This process determines when there is a possibility that the input
    // FIFO could overflow and generates requests for flow control messages
    // to prevent this. Note that after a flow control HALT message is sent,
    // up to two frames may be received before the remote end of the link
    // can stop sending more frames.
-   
+
    always@(posedge clock)
       begin
          if (reset == 1'b1)
@@ -352,7 +352,7 @@ module in_channel(clock,
                   end // else: !if((write_fifo == 1'b1) && (read_fifo == 1'b0) && (item_count == 3'b001))
             end // else: !if(reset == 1'b1)
       end // always@ (posedge clock)
-   
+
    assign flow_req = flow_req_int;
    assign flow_halt = flow_halt_int;
 endmodule // in_channel
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xserial/v/out_chan.v b/lesson000X_mluvm_svsc/uvm_examples/xserial/v/out_chan.v
index 27c64a7..900cc46 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xserial/v/out_chan.v
+++ b/lesson000X_mluvm_svsc/uvm_examples/xserial/v/out_chan.v
@@ -1,12 +1,12 @@
-//--------------------------------------------------------------------------- 
+//---------------------------------------------------------------------------
 //File name   : out_chan.v
 //Title       : Example DUT for XSerial eVC - output channel and fifo
 //Project     : XSerial eVC
 //Developers  : Richard Vialls
 //Created     : 09-May-2002
 //Description : FIFO and output serialiser for 1 output channel of router
-//Notes       : 
-//--------------------------------------------------------------------------- 
+//Notes       :
+//---------------------------------------------------------------------------
 //Copyright (c) 2005-20010 Cadence Design Systems, Inc. All rights reserved worldwide.
 //Please refer to the terms and conditions in $IPCM_HOME.
 //---------------------------------------------------------------------------
@@ -36,7 +36,7 @@ module out_channel(id,
    output       full;
    input        halted;
    output       out_data;
-   
+
    wire [1:0]   id;
    wire         clock;
    wire         reset;
@@ -49,50 +49,50 @@ module out_channel(id,
    reg          full;
    wire         halted;
    reg          out_data;
-   
-   
-   
+
+
+
    // The output channel FIFO
    reg [11:0]   fifo [0:3];
-   
+
    // The FIFO write pointer
    reg [1:0]    write_ptr;
-   
+
    // The FIFO read pointer
    reg [1:0]    read_ptr;
-   
-   
+
+
    // Indicates how many items there are at present in the FIFO
    reg [2:0]    item_count;
-   
-   
+
+
    // High to cause a write to the FIFO
    reg          write_fifo;
-   
+
    // High to cause a read from the FIFO
    reg          read_fifo;
-   
+
    // Counts bits sent to the port
    reg [3:0]    drive_count;
-   
-   
+
+
    // Output shift register
    reg [14:0]   out_shift;
-   
-   
+
+
    // High to load a flow control message into the shift register
    reg          flow;
-   
-   
+
+
    // temporary signal for parity calculation
    reg          parity;
-   
-   
-   
 
-   
+
+
+
+
    // This process determines when a frame needs to be added to the FIFO
-   
+
    always@(id or in_data or in_valid)
       begin
          if ((in_valid == 1'b1) && (in_data[1:0] == id))
@@ -104,12 +104,12 @@ module out_channel(id,
                write_fifo <= 1'b0;
             end // else: !if((in_valid == 1'b1) && (in_data[1:0] == id))
       end // always@ (id or in_data or in_valid)
-   
-   
+
+
    // This process handles the FIFO write pointer. Note that the destination
    // bits in the frame payload are replaced with the number of the channel
    // that the frame was received from (source).
-   
+
    always@(posedge clock)
       begin
          if (reset == 1'b1)
@@ -126,12 +126,12 @@ module out_channel(id,
                   end // if (write_fifo == 1'b1)
             end // else: !if(reset == 1'b1)
       end // always@ (posedge clock)
-   
-   
-   
+
+
+
    // This process handles the FIFO read pointer
-   
-   
+
+
    // This process keeps track of how many items are in the FIFO
    always@(posedge clock)
       begin
@@ -154,8 +154,8 @@ module out_channel(id,
                   end // else: !if((write_fifo == 1'b1) && (read_fifo == 1'b0))
             end // else: !if(reset == 1'b1)
       end // always@ (posedge clock)
-   
-   
+
+
    // This process determines when the FIFO is full
    always@(item_count)
       begin
@@ -168,14 +168,14 @@ module out_channel(id,
                full <= 1'b0;
             end // else: !if(item_count == 3'b100)
       end // always@ (item_count)
-   
-   
+
+
    // This process determines when we can read an item from the FIFO and
    // send it to the serialiser. The serialiser must be ready for another
    // frame, the FIFO must not be empty, the remote end of the link must
    // not have sent a HALT message and we mustn't be pre-empted by a
    // request to send a flow control message.
-   
+
    always@(drive_count or item_count or halted or flow_req)
       begin
          if(( drive_count == 4'b0000 ) && (item_count != 3'b000) && (halted == 1'b0) && (flow_req == 1'b0))
@@ -187,11 +187,11 @@ module out_channel(id,
                read_fifo <= 1'b0;
             end // else: !if(( drive_count == 4'b0000 ) && (item_count != 3'b000) && (halted == 1'b0) && (flow_req == 1'b0))
       end // always@ (drive_count or item_count or halted or flow_req)
-   
-   
+
+
    // This process determines when we need to send a flow control message.
    // These take priority over all other frames.
-   
+
    always@(drive_count or flow_req)
       begin
          if ((drive_count == 4'b0000) && (flow_req == 1'b1))
@@ -203,11 +203,11 @@ module out_channel(id,
                flow <= 1'b0;
             end // else: !if((drive_count == 4'b0000) && (flow_req == 1'b1))
       end // always@ (drive_count or flow_req)
-   
-   
+
+
    // Make sure we acknowledge that the flow control message has been sent.
    assign flow_ack = flow;
-   
+
    // This process counts the bits of the frame as they are serialised.
    always@(posedge clock)
       begin
@@ -230,10 +230,10 @@ module out_channel(id,
                   end // else: !if((read_fifo == 1'b1) || (flow == 1'b1))
             end // else: !if(reset == 1'b1)
       end // always@ (posedge clock)
-   
-   
-   
-   
+
+
+
+
    // This process handles the output shift register. Note that the
    // shift register is normally loaded from the FIFO, but may also
    // be loaded with flow control messages.
@@ -272,8 +272,8 @@ module out_channel(id,
                   end // else: !if(read_fifo == 1'b1)
             end // else: !if(reset == 1'b1)
       end // always@ (posedge clock)
-   
-   
+
+
    // This process calculates parity on the output frame.
    always@(posedge clock)
       begin
@@ -286,7 +286,7 @@ module out_channel(id,
                parity <= parity ^ out_shift[0];
             end // else: !if(drive_count == 4'b1110)
       end // always@ (posedge clock)
-   
+
    // This process inserts the newly calculated parity into the
    // output frame.
    always@(out_shift or parity or drive_count)
@@ -300,5 +300,5 @@ module out_channel(id,
                out_data <= parity;
             end // else: !if(drive_count != 4'b0010)
       end // always@ (out_shift or parity or drive_count)
-   
+
 endmodule // out_channel
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xserial/v/tb_xserial.v b/lesson000X_mluvm_svsc/uvm_examples/xserial/v/tb_xserial.v
index 6f0512f..1188bde 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xserial/v/tb_xserial.v
+++ b/lesson000X_mluvm_svsc/uvm_examples/xserial/v/tb_xserial.v
@@ -1,20 +1,20 @@
-//--------------------------------------------------------------------------- 
+//---------------------------------------------------------------------------
 //File name   : tb_xserial.v
 //Title       : Verilog testbench for XSerial eVC demo
 //Project     : XSerial eVC
 //Developers  : Richard Vialls
 //Created     : 09-May-2002
-//Description : 
-//Notes       : 
-//--------------------------------------------------------------------------- 
+//Description :
+//Notes       :
+//---------------------------------------------------------------------------
 //Copyright (c) 2005-20010 Cadence Design Systems, Inc. All rights reserved worldwide.
 //Please refer to the terms and conditions in $IPCM_HOME.
-//--------------------------------------------------------------------------- 
-   
+//---------------------------------------------------------------------------
+
 module xserial_evc_demo;
-   
 
-  
+
+
    reg reset;
    reg clock;
    reg port_a_in_data;
@@ -38,10 +38,10 @@ module xserial_evc_demo;
                   .port_c_in_data(port_c_in_data),
                   .port_c_err(port_c_err),
                   .port_c_out_data(port_c_out_data));
- 
- 
 
-  
+
+
+
 
    always
       #100 clock = ~clock;
@@ -53,5 +53,5 @@ module xserial_evc_demo;
          clock = 1'b1;
          #500 reset = 1'b0;
       end // initial begin
-   
+
 endmodule // xserial_evc_demo
diff --git a/lesson000X_mluvm_svsc/uvm_examples/xserial/v/vr_xserial_dut_if.sv b/lesson000X_mluvm_svsc/uvm_examples/xserial/v/vr_xserial_dut_if.sv
index d8c7f72..7f0b82e 100644
--- a/lesson000X_mluvm_svsc/uvm_examples/xserial/v/vr_xserial_dut_if.sv
+++ b/lesson000X_mluvm_svsc/uvm_examples/xserial/v/vr_xserial_dut_if.sv
@@ -4,11 +4,11 @@ Title       : DUT interface declarations for the XSerial router
 Project     : Xserial uVC
 Created     : 2006-02-23
 Description : [Future] This file declares the DUT interface for the router DUT
-Notes       : 
-            : 
+Notes       :
+            :
               This file is NOT currently used by the scripts, until modport
               expressions are supported.
- 
+
 ----------------------------------------------------------------------
 Copyright (c) 2005-20010 Cadence Design Systems, Inc. \
 All rights reserved worldwide.
@@ -22,16 +22,16 @@ interface xserial_dut_if ( input logic clock, input logic reset);
    logic port_a_in_data;
    logic port_a_err;
    logic port_a_out_data;
-   
+
    logic port_b_in_data;
    logic port_b_err;
    logic port_b_out_data;
-   
+
    logic port_c_in_data;
    logic port_c_err;
    logic port_c_out_data;
 
-   
+
    modport port_a (
 	       input   .xserial_reset(reset),
 	       input   .xserial_rx_clock(clock),
@@ -41,7 +41,7 @@ interface xserial_dut_if ( input logic clock, input logic reset);
                output  .xserial_err(port_a_err) );
 
 
-   modport port_b ( 
+   modport port_b (
 	       input   .xserial_reset(reset),
 	       input   .xserial_rx_clock(clock),
                input   .xserial_rx_data(port_b_in_data),
@@ -49,7 +49,7 @@ interface xserial_dut_if ( input logic clock, input logic reset);
                output  .xserial_tx_data(port_b_out_data),
                output  .xserial_err(port_b_err));
 
-   modport port_c ( 
+   modport port_c (
 	       input   .xserial_reset(reset),
 	       input   .xserial_rx_clock(clock),
                input   .xserial_rx_data(port_b_in_data),
@@ -69,8 +69,8 @@ interface xserial_dut_if ( input logic clock, input logic reset);
                 input  port_c_in_data,
                 input  port_c_err,
                 input  port_c_out_data);
-   
-   
-endinterface 
+
+
+endinterface
 
 
diff --git a/lesson0010_constraint_1/constraint_1.sv b/lesson0010_constraint_1/constraint_1.sv
index f797d29..e2145cf 100644
--- a/lesson0010_constraint_1/constraint_1.sv
+++ b/lesson0010_constraint_1/constraint_1.sv
@@ -1,12 +1,12 @@
 module dice_game;
-   
+
 class a_die;
-   rand int value;   
+   rand int value;
 
    constraint six_sides { value>=1 && value<=6; }
 
    function void pre_randomize();
-      $display("  start.");      
+      $display("  start.");
    endfunction
    function void post_randomize();
       $display("%m  done.");
@@ -18,17 +18,17 @@ endclass
 
 
    initial begin
-      a_die my_die;      
+      a_die my_die;
       int junk;
-      
+
       my_die  = new();
 
       repeat(4) begin
 	 my_die.randomize();
-	 $display(" die roll = %0d",my_die.value);      
+	 $display(" die roll = %0d",my_die.value);
       end
 
-   end // initial begin   
+   end // initial begin
 
 endmodule // dice_game
 aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
diff --git a/lesson0010_constraint_1/dice_roll.sv b/lesson0010_constraint_1/dice_roll.sv
index 6b1eedf..a29027f 100644
--- a/lesson0010_constraint_1/dice_roll.sv
+++ b/lesson0010_constraint_1/dice_roll.sv
@@ -5,25 +5,25 @@ class a_die;
 
    constraint six_sides { value>=1 && value<=6; }
 
-   function void pre_randomize();      
+   function void pre_randomize();
       $write(" die ready to be rolled ....");
-   endfunction   
-   
-   function void post_randomize();      
+   endfunction
+
+   function void post_randomize();
       $display(" die roll is now = %0d", value);
-   endfunction   
+   endfunction
 endclass
 
-   
+
    initial begin
       a_die my_die;
       my_die  = new();
 
       repeat (4) begin
-	 my_die.randomize();	 
+	 my_die.randomize();
       end
-      
-   end 
 
-   
+   end
+
+
 endmodule // dice_game
diff --git a/lesson0010_constraint_1/sean.sv b/lesson0010_constraint_1/sean.sv
index 035fcce..201d06d 100644
--- a/lesson0010_constraint_1/sean.sv
+++ b/lesson0010_constraint_1/sean.sv
@@ -3,11 +3,11 @@ class a_die;
 
    constraint six_sides { value>=1 && value<=6; }
 
-   function void pre_randomize();      
+   function void pre_randomize();
       $write(" die ready to be rolled ....");
-   endfunction   
-   
-   function void post_randomize();      
+   endfunction
+
+   function void post_randomize();
       $display(" die roll is now = %0d", value);
-   endfunction   
-endclass
\ No newline at end of file
+   endfunction
+endclass
diff --git a/lesson0011_constraint_2/a.sv b/lesson0011_constraint_2/a.sv
index fa5b954..a551cf6 100644
--- a/lesson0011_constraint_2/a.sv
+++ b/lesson0011_constraint_2/a.sv
@@ -7,25 +7,25 @@ class dice;
 				 && value2>=1 && value2<=6; }
 
    constraint seven_eleven { ((value+value2)==7) || ((value+value2)==11); }
-   
-   function void pre_randomize();      
+
+   function void pre_randomize();
       $write(" dice ready to be rolled ....");
-   endfunction   
-   
-   function void post_randomize();      
+   endfunction
+
+   function void post_randomize();
       $display(" dice roll is now = %0d %0d", value, value2);
-   endfunction   
+   endfunction
 endclass
 
    initial begin
       dice my_dice;
       my_dice  = new();
 
-      my_dice.six_sides.constraint_mode(0);      
+      my_dice.six_sides.constraint_mode(0);
       repeat (6) begin
 //	 assert (my_dice.randomize()) else
 //	   $display(" Mister SVS, randomization failed, miserably.");
-	 if (my_dice.randomize()) 
+	 if (my_dice.randomize())
 	   ;
 	 else
 	   $display(" ERROR: Mister SVS, randomization failed, miserably.");
@@ -42,7 +42,7 @@ endmodule // dice_game
 //RUN  - result: bad second roll
 //edit original constraint
 //RUN - result: good roll
-//add second constraint for 7s,11s. 
+//add second constraint for 7s,11s.
 //           POINT: use ==, not =  EXPRESSIONS, not ASSIGNMENT.
 //RUN - maybe get 11, maybe need to increase repeat
 //make conflicting constraints
diff --git a/lesson0011_constraint_2/constraint_1.sv b/lesson0011_constraint_2/constraint_1.sv
index eb0baa2..69978d5 100644
--- a/lesson0011_constraint_2/constraint_1.sv
+++ b/lesson0011_constraint_2/constraint_1.sv
@@ -1,12 +1,12 @@
 module dice_game;
-   
+
 class a_die;
-   rand int value;   
+   rand int value;
 
    constraint six_sides { value>=1 && value<=6; }
 
    function void pre_randomize();
-      $display("  start.");      
+      $display("  start.");
    endfunction
    function void post_randomize();
       $display("%m  done.");
@@ -18,17 +18,17 @@ endclass
 
 
    initial begin
-      a_die my_die;      
+      a_die my_die;
       int junk;
-      
+
       my_die  = new();
 
       repeat(4) begin
 	 my_die.randomize();
-	 $display(" die roll = %0d",my_die.value);      
+	 $display(" die roll = %0d",my_die.value);
       end
 
-   end // initial begin   
+   end // initial begin
 
 endmodule // dice_game
 
diff --git a/lesson0011_constraint_2/dice_roll.sv b/lesson0011_constraint_2/dice_roll.sv
index 95acc06..103fb58 100644
--- a/lesson0011_constraint_2/dice_roll.sv
+++ b/lesson0011_constraint_2/dice_roll.sv
@@ -3,34 +3,34 @@ module dice_game;
 class dice;
    rand int value, value2;
 
-   constraint six_sides { value>=1  && value<=6; 
-                          value2>=1 && value2<=6; 
+   constraint six_sides { value>=1  && value<=6;
+                          value2>=1 && value2<=6;
    }
 
    constraint seven_eleven { ((value+value2)==7) || ((value+value2)==11); }
-   
-   function void pre_randomize();      
+
+   function void pre_randomize();
       $write(" dice ready to be rolled ....");
-   endfunction   
-   
-   function void post_randomize();      
+   endfunction
+
+   function void post_randomize();
       $display(" dice roll is now = %0d %0d", value, value2);
-   endfunction   
+   endfunction
 endclass
 
-   
+
    initial begin
       dice my_dice;
       my_dice  = new();
 
-      my_dice.constraint_mode(0);      
-      my_dice.six_sides.constraint_mode(1);      
+      my_dice.constraint_mode(0);
+      my_dice.six_sides.constraint_mode(1);
       repeat (8) begin
-	 assert (my_dice.randomize()) else 
-	   $fatal(" ERROR: Mister SVS, randomization failed, miserably.");	 
+	 assert (my_dice.randomize()) else
+	   $fatal(" ERROR: Mister SVS, randomization failed, miserably.");
       end
-      
-   end 
 
-   
+   end
+
+
 endmodule // dice_game
diff --git a/lesson0012_constraint_3/a.sv b/lesson0012_constraint_3/a.sv
index d55ee41..2eb138c 100644
--- a/lesson0012_constraint_3/a.sv
+++ b/lesson0012_constraint_3/a.sv
@@ -3,45 +3,45 @@ module dice_game;
 class dice;
    rand int value, value2;
 
-   constraint six_sides { value>=1  && value<=6; 
-                          value2>=1 && value2<=6; 
+   constraint six_sides { value>=1  && value<=6;
+                          value2>=1 && value2<=6;
    }
 
    constraint seven_eleven { ((value+value2)==7) || ((value+value2)==11); }
-   
-   function void pre_randomize();      
+
+   function void pre_randomize();
       $write(" Dice ready to be rolled ....");
-   endfunction   
-   
-   function void post_randomize();      
+   endfunction
+
+   function void post_randomize();
       $display(" dice roll is now = %0d %0d", value, value2);
-   endfunction   
+   endfunction
 endclass
 
-   
+
    initial begin
       dice my_dice;
       my_dice  = new();
 
-      my_dice.constraint_mode(0);      
-      my_dice.six_sides.constraint_mode(1);      
+      my_dice.constraint_mode(0);
+      my_dice.six_sides.constraint_mode(1);
       repeat (6) begin
 	 assert (my_dice.randomize() with  { ((value+value2)==2) || ((value+value2)==12); }) else begin
-	   $fatal(" ERROR: Mister SVS, randomization failed, miserably.");	 
+	   $fatal(" ERROR: Mister SVS, randomization failed, miserably.");
 	 end
 	 $display("     ..going to reroll the second die.");
 	 my_dice.randomize(value2);
 	 $display("     ..going to reroll the first die with inline constraint of >=4.");
 	 my_dice.randomize(value) with {value>=5;};
 
-	 $display("\n"); 
+	 $display("\n");
       end
 
 
-      $display(" The End");      
-   end 
+      $display(" The End");
+   end
+
 
-   
 endmodule // dice_game
 
 
@@ -52,6 +52,6 @@ endmodule // dice_game
 //showandtell
 //randomize just value1 with inline constraint
 //showandtell
-//randomize 
+//randomize
 //do another inline constraint by copy-modifiy of initial one
 
diff --git a/lesson0012_constraint_3/b.sv b/lesson0012_constraint_3/b.sv
index 5e809a9..0991797 100644
--- a/lesson0012_constraint_3/b.sv
+++ b/lesson0012_constraint_3/b.sv
@@ -3,27 +3,27 @@ module dice_game;
 class dice;
    randc int value;
 
-   constraint six_sides { value>=1  && value<=6; } 
-   constraint odds      { (value%2)==1; } 
-      
+   constraint six_sides { value>=1  && value<=6; }
+   constraint odds      { (value%2)==1; }
+
    function void post_randomize();
       $display(" dice roll is now = %0d", value);
-   endfunction   
+   endfunction
 endclass
 
-   
+
    initial begin
       dice my_dice;
       my_dice  = new();
 
-      //my_dice.constraint_mode(0);      
+      //my_dice.constraint_mode(0);
 
       repeat (10) begin
-	 assert (my_dice.randomize()) else  $fatal(" ERROR: Mister SVS, randomization failed, miserably.");	 
-      end      
-   end 
+	 assert (my_dice.randomize()) else  $fatal(" ERROR: Mister SVS, randomization failed, miserably.");
+      end
+   end
+
 
-   
 endmodule // dice_game
 /*
 
@@ -33,5 +33,5 @@ endmodule // dice_game
 4. show that we cycle thru
 5. add another constraint of only odds
 
- */ 
-  
\ No newline at end of file
+ */
+
diff --git a/lesson0012_constraint_3/dice_roll.sv b/lesson0012_constraint_3/dice_roll.sv
index 9a4d958..a28e3a9 100644
--- a/lesson0012_constraint_3/dice_roll.sv
+++ b/lesson0012_constraint_3/dice_roll.sv
@@ -3,38 +3,38 @@ module dice_game;
 class dice;
    rand int value, value2;
 
-   constraint six_sides { value>=1  && value<=6; 
-                          value2>=1 && value2<=6; 
+   constraint six_sides { value>=1  && value<=6;
+                          value2>=1 && value2<=6;
    }
 
    constraint seven_eleven { ((value+value2)==7) || ((value+value2)==11); }
-   
-   function void pre_randomize();      
+
+   function void pre_randomize();
       $write(" dice ready to be rolled ....");
-   endfunction   
-   
-   function void post_randomize();      
+   endfunction
+
+   function void post_randomize();
       $display(" dice roll is now = %0d %0d", value, value2);
-   endfunction   
+   endfunction
 endclass
 
-   
+
    initial begin
       dice my_dice;
       my_dice  = new();
 
-      my_dice.constraint_mode(0);      
-      my_dice.six_sides.constraint_mode(1);      
+      my_dice.constraint_mode(0);
+      my_dice.six_sides.constraint_mode(1);
       repeat (5) begin
-	 assert (my_dice.randomize() with  { ((value+value2)==2) || ((value+value2)==12); }) else 
-	   $fatal(" ERROR: Mister SVS, randomization failed, miserably.");	 
+	 assert (my_dice.randomize() with  { ((value+value2)==2) || ((value+value2)==12); }) else
+	   $fatal(" ERROR: Mister SVS, randomization failed, miserably.");
          $display("     ..going to reroll the second die.");
-         void'(my_dice.randomize(value2));      	 
+         void'(my_dice.randomize(value2));
 	 $display("     ..going to reroll the first die with inline constraint of >=5.");
          void'(my_dice.randomize(value) with {value>=5;});
-         $display("\n");       
-      end      
-   end 
+         $display("\n");
+      end
+   end
+
 
-   
 endmodule // dice_game
diff --git a/lesson0013_randc_and_constraint/a.sv b/lesson0013_randc_and_constraint/a.sv
index d55ee41..2eb138c 100644
--- a/lesson0013_randc_and_constraint/a.sv
+++ b/lesson0013_randc_and_constraint/a.sv
@@ -3,45 +3,45 @@ module dice_game;
 class dice;
    rand int value, value2;
 
-   constraint six_sides { value>=1  && value<=6; 
-                          value2>=1 && value2<=6; 
+   constraint six_sides { value>=1  && value<=6;
+                          value2>=1 && value2<=6;
    }
 
    constraint seven_eleven { ((value+value2)==7) || ((value+value2)==11); }
-   
-   function void pre_randomize();      
+
+   function void pre_randomize();
       $write(" Dice ready to be rolled ....");
-   endfunction   
-   
-   function void post_randomize();      
+   endfunction
+
+   function void post_randomize();
       $display(" dice roll is now = %0d %0d", value, value2);
-   endfunction   
+   endfunction
 endclass
 
-   
+
    initial begin
       dice my_dice;
       my_dice  = new();
 
-      my_dice.constraint_mode(0);      
-      my_dice.six_sides.constraint_mode(1);      
+      my_dice.constraint_mode(0);
+      my_dice.six_sides.constraint_mode(1);
       repeat (6) begin
 	 assert (my_dice.randomize() with  { ((value+value2)==2) || ((value+value2)==12); }) else begin
-	   $fatal(" ERROR: Mister SVS, randomization failed, miserably.");	 
+	   $fatal(" ERROR: Mister SVS, randomization failed, miserably.");
 	 end
 	 $display("     ..going to reroll the second die.");
 	 my_dice.randomize(value2);
 	 $display("     ..going to reroll the first die with inline constraint of >=4.");
 	 my_dice.randomize(value) with {value>=5;};
 
-	 $display("\n"); 
+	 $display("\n");
       end
 
 
-      $display(" The End");      
-   end 
+      $display(" The End");
+   end
+
 
-   
 endmodule // dice_game
 
 
@@ -52,6 +52,6 @@ endmodule // dice_game
 //showandtell
 //randomize just value1 with inline constraint
 //showandtell
-//randomize 
+//randomize
 //do another inline constraint by copy-modifiy of initial one
 
diff --git a/lesson0013_randc_and_constraint/dice_roll.sv b/lesson0013_randc_and_constraint/dice_roll.sv
index 5e7688e..b671cbe 100644
--- a/lesson0013_randc_and_constraint/dice_roll.sv
+++ b/lesson0013_randc_and_constraint/dice_roll.sv
@@ -4,23 +4,23 @@ class dice;
    randc int value;     //random-cyclic variable (cycles thru all values before repeating)
    //rand int value;        //random variable
 
-   constraint six_sides { value>=1  && value<=6; } 
+   constraint six_sides { value>=1  && value<=6; }
    constraint odd { (value%2)==1; }
    function void post_randomize();
       $display(" dice roll is now = %0d", value);
-   endfunction   
+   endfunction
 endclass
 
-   
+
    initial begin
       dice my_dice;
       my_dice  = new();
 
-      //my_dice.constraint_mode(0);      
+      //my_dice.constraint_mode(0);
 
       repeat (10) begin
-	 assert (my_dice.randomize()) else  $fatal(" ERROR: Mister SVS, randomization failed, miserably.");	 
-      end      
-   end    
+	 assert (my_dice.randomize()) else  $fatal(" ERROR: Mister SVS, randomization failed, miserably.");
+      end
+   end
 
 endmodule // dice_game
diff --git a/lesson0014_rand_and_dist/a.sv b/lesson0014_rand_and_dist/a.sv
index d55ee41..2eb138c 100644
--- a/lesson0014_rand_and_dist/a.sv
+++ b/lesson0014_rand_and_dist/a.sv
@@ -3,45 +3,45 @@ module dice_game;
 class dice;
    rand int value, value2;
 
-   constraint six_sides { value>=1  && value<=6; 
-                          value2>=1 && value2<=6; 
+   constraint six_sides { value>=1  && value<=6;
+                          value2>=1 && value2<=6;
    }
 
    constraint seven_eleven { ((value+value2)==7) || ((value+value2)==11); }
-   
-   function void pre_randomize();      
+
+   function void pre_randomize();
       $write(" Dice ready to be rolled ....");
-   endfunction   
-   
-   function void post_randomize();      
+   endfunction
+
+   function void post_randomize();
       $display(" dice roll is now = %0d %0d", value, value2);
-   endfunction   
+   endfunction
 endclass
 
-   
+
    initial begin
       dice my_dice;
       my_dice  = new();
 
-      my_dice.constraint_mode(0);      
-      my_dice.six_sides.constraint_mode(1);      
+      my_dice.constraint_mode(0);
+      my_dice.six_sides.constraint_mode(1);
       repeat (6) begin
 	 assert (my_dice.randomize() with  { ((value+value2)==2) || ((value+value2)==12); }) else begin
-	   $fatal(" ERROR: Mister SVS, randomization failed, miserably.");	 
+	   $fatal(" ERROR: Mister SVS, randomization failed, miserably.");
 	 end
 	 $display("     ..going to reroll the second die.");
 	 my_dice.randomize(value2);
 	 $display("     ..going to reroll the first die with inline constraint of >=4.");
 	 my_dice.randomize(value) with {value>=5;};
 
-	 $display("\n"); 
+	 $display("\n");
       end
 
 
-      $display(" The End");      
-   end 
+      $display(" The End");
+   end
+
 
-   
 endmodule // dice_game
 
 
@@ -52,6 +52,6 @@ endmodule // dice_game
 //showandtell
 //randomize just value1 with inline constraint
 //showandtell
-//randomize 
+//randomize
 //do another inline constraint by copy-modifiy of initial one
 
diff --git a/lesson0014_rand_and_dist/aa.sv b/lesson0014_rand_and_dist/aa.sv
index 5c0ecce..bbf330c 100644
--- a/lesson0014_rand_and_dist/aa.sv
+++ b/lesson0014_rand_and_dist/aa.sv
@@ -24,11 +24,11 @@ class dice;
 				      2:=1,  // 1/(5+1+1+1+1+1)
 				      1:=1   // 1/(5+1+1+1+1+1)
 				      }; }
-*/ 
+*/
 //   constraint fixed_odds{ value dist {[6:4]:/1, 3:/1, 2:/1, 1:/1}; }// BAD RANGE [low:high]. error
-//   constraint fixed_odds{ value dist {[4:6]:/1, 3:/1, 2:/1, 1:/1}; }  
-   constraint fixed_odds{ value dist {[4:6]:=1, 3:/1, 2:/1, 1:/1}; }  
-   
+//   constraint fixed_odds{ value dist {[4:6]:/1, 3:/1, 2:/1, 1:/1}; }
+   constraint fixed_odds{ value dist {[4:6]:=1, 3:/1, 2:/1, 1:/1}; }
+
    function void post_randomize();
       $display(" dice roll is now = %0d", value);
       stats[value]  = stats[value]+1;
@@ -49,16 +49,16 @@ endclass
       my_dice  = new();
 
       repeat (100) begin
-	 assert (my_dice.randomize()) else  begin 
-	    $display(" ERROR: Mister SVS, randomization failed, miserably.");	 
-	    $fatal(1);	    
+	 assert (my_dice.randomize()) else  begin
+	    $display(" ERROR: Mister SVS, randomization failed, miserably.");
+	    $fatal(1);
 	 end
       end
 
       my_dice.show_stats();
    end
 
-   
+
 endmodule // dice_game
 
 
diff --git a/lesson0014_rand_and_dist/dice_roll.sv b/lesson0014_rand_and_dist/dice_roll.sv
index ec0177a..dd82e58 100644
--- a/lesson0014_rand_and_dist/dice_roll.sv
+++ b/lesson0014_rand_and_dist/dice_roll.sv
@@ -3,11 +3,11 @@ module dice_game;
 // distributions (dist) can be used in constraints for specifying sets of weighted values
 //    which control the distribution of results
 // distribution set - comma separated list of values (or expressions or ranges)
-   
+
 class dice;
-   rand int value;        //random variable  
+   rand int value;        //random variable
    int stats[1:6]  = {0,0,0,0,0,0};
-   
+
 //   constraint six_sides { value>=1  && value<=6; }
      constraint fixed_odds{ value dist {6,5,4,3,2,1}; }
 /*     constraint fixed_odds{ value dist {
@@ -26,15 +26,15 @@ class dice;
 				      2:=1,   // 1/(50+1+1+1+1+1)
 				      1:=1    // 1/(50+1+1+1+1+1)
 				      }; }
-*/ 
+*/
 
-//   constraint fixed_odds{ value dist {[4:6]:/1, 3:/1, 2:/1, 1:/1}; }  
-//   constraint fixed_odds{ value dist {[4:6]:=1, 3:/1, 2:/1, 1:/1}; }  
+//   constraint fixed_odds{ value dist {[4:6]:/1, 3:/1, 2:/1, 1:/1}; }
+//   constraint fixed_odds{ value dist {[4:6]:=1, 3:/1, 2:/1, 1:/1}; }
 //   constraint fixed_odds{ value dist {[6:4]:=1, 3:/1, 2:/1, 1:/1}; }// BAD RANGE [low:high]. error
 
-  
+
    function void post_randomize();
-      $display(" dice roll is now = %0d", value);      
+      $display(" dice roll is now = %0d", value);
       stats[value]  = stats[value]+1;
    endfunction
 
@@ -44,7 +44,7 @@ class dice;
 		  iii, stats[iii], stats.sum(), (real'(stats[iii])/real'(stats.sum()))*100);
       end
    endfunction
-   
+
 endclass
 
 
@@ -53,13 +53,13 @@ endclass
       my_dice  = new();
 
       repeat (100) begin
-	 assert (my_dice.randomize()) else  begin 
-	    $display(" ERROR: Mister SVS, randomization failed, miserably.");	 
-	    $fatal(1);	    
+	 assert (my_dice.randomize()) else  begin
+	    $display(" ERROR: Mister SVS, randomization failed, miserably.");
+	    $fatal(1);
 	 end
       end
 
       my_dice.show_stats();
    end
-   
+
 endmodule // dice_game
diff --git a/lesson0015_extern/abc.sv b/lesson0015_extern/abc.sv
index 520c8d7..98e625a 100644
--- a/lesson0015_extern/abc.sv
+++ b/lesson0015_extern/abc.sv
@@ -1,15 +1,15 @@
 odule dice_game;
-   
+
 class dice;
-   rand int value;        //random variable  
+   rand int value;        //random variable
    int stats[1:6]  = {0,0,0,0,0,0};
-   
-   
-   constraint fixed_odds;  //implicit external constraint 
+
+
+   constraint fixed_odds;  //implicit external constraint
    constraint even;        //explicit external constraint
 
    function void post_randomize();
-      $display(" dice roll is now = %0d", value);      
+      $display(" dice roll is now = %0d", value);
       stats[value]  = stats[value]+1;
    endfunction
 
@@ -17,10 +17,10 @@ class dice;
 endclass
 
 
-   
+
    constraint dice::fixed_odds{ value dist {6,5,4,3,2,1}; }
    constraint dice::even{ (value%2)==0; }
-   
+
    function void dice::show_stats();
       foreach (stats[iii]) begin
 	 $display("%3d : %3d of %3d : %2.2f%",
@@ -28,28 +28,28 @@ endclass
       end
    endfunction
 
-   
-   
+
+
    initial begin
       dice my_dice;
       my_dice  = new();
 
       repeat (100) begin
-	 assert (my_dice.randomize()) else  begin 
-	    $display(" ERROR: Mister SVS, randomization failed, miserably.");	 
-	    $fatal(1);	    
+	 assert (my_dice.randomize()) else  begin
+	    $display(" ERROR: Mister SVS, randomization failed, miserably.");
+	    $fatal(1);
 	 end
       end
 
       my_dice.show_stats();
-   end   
+   end
 endmodule // dice_game
 /*
-#15  
+#15
 1) purpose: learn about "extern" to move method and constraint bodies out of classes, to make code cleaner
 2) coming off of page 144/5 and 444 of 2009 spec
-3) base code 
-4) large class with many lines devoted to methods and constraints. tough to skim  
+3) base code
+4) large class with many lines devoted to methods and constraints. tough to skim
 5) move method (task/function) out of class declaration
  extern qualifier means body/implementation/declaration is outside the class
  outside, use "class-name":: to tie it back in.
@@ -57,14 +57,14 @@ endmodule // dice_game
  6) move constraint out as implicit constraint
  7) run
  8) remove body. run and show warning.  then re-add body
- 
+
  9) add a second constraint make even
  10)move constraint out as explicit constraint
  11) run //FAILS b/c not supported by 12.1 IUS
- 12) implicit VS. explict.  
-       explicit MUST have declaration.  
+ 12) implicit VS. explict.
+       explicit MUST have declaration.
        implicit can skip declaration (making empty constraint), warning must be issued
- 
+
 i) make prototype
 ii) move func out and tie it back in with "class-name"::
  NOTE: declartion much match prototype exactly, except for 'tie-in' (class resolution) w/ class
@@ -74,17 +74,17 @@ ii) move func out and tie it back in with "class-name"::
 implicit  //w/o extern, do not need declaration
 explicit  //w/ extern, must have declaration.  Not yet supported by my simulator
  //
- 
 
- 
+
+
  #17
  purpose: continuing look at "extern" methods
  Coming off of page 145
  Note about return type and class resolution operator. use in example
-  
- 
- 
+
+
+
   444
   637
-      
- */
\ No newline at end of file
+
+ */
diff --git a/lesson0015_extern/dice_roll.sv b/lesson0015_extern/dice_roll.sv
index bf30914..bdcebb3 100644
--- a/lesson0015_extern/dice_roll.sv
+++ b/lesson0015_extern/dice_roll.sv
@@ -2,48 +2,48 @@
 //  moving methods/constraints out of classes
 
 module dice_game;
-   
+
 class dice;
-   rand int value;       
+   rand int value;
    int stats[1:6]  = {0,0,0,0,0,0};
-      
+
 
    constraint fixed_odds;  //implicit external constraint
    extern constraint even; //explicit external constraint
-   
+
    extern function void post_randomize();
    extern function void show_stats();
 
 endclass
 
 
-   constraint dice::even { (value%2)==0; }   
+   constraint dice::even { (value%2)==0; }
    //constraint dice::fixed_odds{ value dist {6,5,4,3,2,1}; }
 
    function void dice::post_randomize();
-      $display(" dice roll is now = %0d", value);      
+      $display(" dice roll is now = %0d", value);
       stats[value]  = stats[value]+1;
    endfunction
-   
+
    function void dice::show_stats();
       foreach (stats[iii]) begin
 	 $display("%3d : %3d of %3d : %2.2f%",
 		  iii, stats[iii], stats.sum(), (real'(stats[iii])/real'(stats.sum()))*100);
       end
    endfunction
-      
-      
+
+
    initial begin
       dice my_dice;
       my_dice  = new();
 
       repeat (100) begin
-	 assert (my_dice.randomize()) else  begin 
-	    $display(" ERROR: Mister SVS, randomization failed, miserably.");	 
-	    $fatal(1);	    
+	 assert (my_dice.randomize()) else  begin
+	    $display(" ERROR: Mister SVS, randomization failed, miserably.");
+	    $fatal(1);
 	 end
       end
 
       my_dice.show_stats();
-   end   
+   end
 endmodule // dice_game
diff --git a/lesson0016_full_simple_tb/bind.sv b/lesson0016_full_simple_tb/bind.sv
index 6369394..d8e3fca 100644
--- a/lesson0016_full_simple_tb/bind.sv
+++ b/lesson0016_full_simple_tb/bind.sv
@@ -8,9 +8,9 @@ bind dut bound2 bound2_u(.my_if.clk(clk),
 */
 
 /*
-IDEAL GOAL.  #3.  do not use bound or bound2.  just connect/bind internal_if.smp 
+IDEAL GOAL.  #3.  do not use bound or bound2.  just connect/bind internal_if.smp
  to the dut.  The goal is to use the assertions in the interface on internal signals.
  At the submodule testbench level
-  
+
 bind dut internal_if.smp_mp somename(.clk(clk), .data_bus(data_bus), .bus_data(bus_data));
  */
diff --git a/lesson0016_full_simple_tb/dut.sv b/lesson0016_full_simple_tb/dut.sv
index 4a9ccd8..cd42a33 100644
--- a/lesson0016_full_simple_tb/dut.sv
+++ b/lesson0016_full_simple_tb/dut.sv
@@ -7,8 +7,8 @@ module dut(
    logic [31:0] bus_data;
 
    assign bus_data = ~data_bus;
-   
+
    always@(posedge clk) begin
       result = bus_data % 32'h8;//implicit casting
    end
-endmodule : dut
\ No newline at end of file
+endmodule : dut
diff --git a/lesson0016_full_simple_tb/env.svh b/lesson0016_full_simple_tb/env.svh
index 3aa90e4..0023fbe 100644
--- a/lesson0016_full_simple_tb/env.svh
+++ b/lesson0016_full_simple_tb/env.svh
@@ -2,6 +2,6 @@ import uvm_pkg::*;
 
 class env extends uvm_env;
 
-   
 
-endclass : env
\ No newline at end of file
+
+endclass : env
diff --git a/lesson0016_full_simple_tb/in_if.sv b/lesson0016_full_simple_tb/in_if.sv
index 71a477f..0ae06e7 100644
--- a/lesson0016_full_simple_tb/in_if.sv
+++ b/lesson0016_full_simple_tb/in_if.sv
@@ -3,11 +3,11 @@ interface in_if (input clk);
 
    //clocking blocks
    clocking drv_cb @(posedge clk);
-      output data_bus;      
+      output data_bus;
    endclocking
 
    clocking smp_cb @(posedge clk);
-      input data_bus;      
+      input data_bus;
    endclocking
 
    //modports
diff --git a/lesson0016_full_simple_tb/internal_if.sv b/lesson0016_full_simple_tb/internal_if.sv
index a18dc19..d387369 100644
--- a/lesson0016_full_simple_tb/internal_if.sv
+++ b/lesson0016_full_simple_tb/internal_if.sv
@@ -2,7 +2,7 @@ interface internal_if(input clk);
 
    logic [31:0] data_bus;
    logic [31:0] bus_data;
- 
+
    modport smp_mp (input clk, data_bus, bus_data);
 
    //add assertions here
diff --git a/lesson0018_uvm_config_db/Help/solution/new.sv b/lesson0018_uvm_config_db/Help/solution/new.sv
index a497135..580c473 100644
--- a/lesson0018_uvm_config_db/Help/solution/new.sv
+++ b/lesson0018_uvm_config_db/Help/solution/new.sv
@@ -45,9 +45,9 @@ input  logic [31:0] inbus [3:0];
 output logic [31:0] outbus;
 
 always@(posedge clk) begin
-if (!resetn) 
+if (!resetn)
 outbus <= 32'd0;
-else 
+else
 outbus <= inbus[3]|inbus[2]|inbus[1]|inbus[0];
 end
 
diff --git a/lesson0018_uvm_config_db/Help/solution/test.sv b/lesson0018_uvm_config_db/Help/solution/test.sv
index 4990f52..c174e20 100644
--- a/lesson0018_uvm_config_db/Help/solution/test.sv
+++ b/lesson0018_uvm_config_db/Help/solution/test.sv
@@ -21,10 +21,10 @@ svs_dut svs_dut(
 .clk(clk),
 .resetn(resetn),
 
-.inbus[3]() , 
-.inbus[2]() , 
-.inbus[1]() , 
-.inbus[0]() , 
+.inbus[3]() ,
+.inbus[2]() ,
+.inbus[1]() ,
+.inbus[0]() ,
 .outbus(outbus)
 );
 
@@ -41,9 +41,9 @@ output logic [31:0] outbus
 
 
 always@(posedge clk) begin
-if (!resetn) 
+if (!resetn)
 outbus <= 32'd0;
-else 
+else
 outbus <= inbus[3]|inbus[2]|inbus[1]|inbus[0];
 end
 
diff --git a/lesson0018_uvm_config_db/svs_dut.sv b/lesson0018_uvm_config_db/svs_dut.sv
index 803453d..19b03fa 100644
--- a/lesson0018_uvm_config_db/svs_dut.sv
+++ b/lesson0018_uvm_config_db/svs_dut.sv
@@ -9,11 +9,11 @@ module svs_dut(
 	       );
 
    always@(posedge clk) begin
-      if (!resetn) 
+      if (!resetn)
 	outbus <= 32'd0;
       else begin
-	 outbus <= inbus3 | inbus2 | inbus1 | inbus0;	 
+	 outbus <= inbus3 | inbus2 | inbus1 | inbus0;
 	 $display(" inbus 0=%8x 1=%8x 2=%8x 3=%8x",inbus0, inbus1, inbus2, inbus3);
       end
    end
-endmodule
\ No newline at end of file
+endmodule
diff --git a/lesson0018_uvm_config_db/svs_env.svh b/lesson0018_uvm_config_db/svs_env.svh
index 85a0c96..43e2333 100644
--- a/lesson0018_uvm_config_db/svs_env.svh
+++ b/lesson0018_uvm_config_db/svs_env.svh
@@ -12,7 +12,7 @@ class svs_env extends uvm_env;
 
 
    function void build_phase(uvm_phase phase);
-      
+
    endfunction : build_phase
 
-endclass : svs_env
\ No newline at end of file
+endclass : svs_env
diff --git a/lesson0018_uvm_config_db/svs_if.sv b/lesson0018_uvm_config_db/svs_if.sv
index 7cd29d2..34a2384 100644
--- a/lesson0018_uvm_config_db/svs_if.sv
+++ b/lesson0018_uvm_config_db/svs_if.sv
@@ -1,3 +1,3 @@
 interface svs_if (input clk, input resetn);
    logic [31:0] bus32;
-endinterface
\ No newline at end of file
+endinterface
diff --git a/lesson0018_uvm_config_db/svs_test.sv b/lesson0018_uvm_config_db/svs_test.sv
index 24dd472..197c08a 100644
--- a/lesson0018_uvm_config_db/svs_test.sv
+++ b/lesson0018_uvm_config_db/svs_test.sv
@@ -13,11 +13,11 @@ class svs_test extends uvm_test;
    function void end_of_elaboration_phase(uvm_phase phase);
       uvm_top.print_topology();
    endfunction
-   
+
    task run_phase(uvm_phase phase);
       phase.raise_objection(this);
       repeat (4) `uvm_info("DBG","message1 goes here",UVM_NONE)
       #100;
       phase.drop_objection(this);
    endtask : run_phase
-endclass : svs_test
\ No newline at end of file
+endclass : svs_test
diff --git a/lesson0018_uvm_config_db/svs_top.sv b/lesson0018_uvm_config_db/svs_top.sv
index 3540a26..5cabd49 100644
--- a/lesson0018_uvm_config_db/svs_top.sv
+++ b/lesson0018_uvm_config_db/svs_top.sv
@@ -5,7 +5,7 @@ module svs_top ();
    logic [31:0] outbus;
 
    svs_if svs_if_u[3:0](.clk(clk), .resetn(resetn));
-   
+
    svs_test svs_test_u = new();
    //svs_test_u = new;
 
@@ -30,6 +30,6 @@ module svs_top ();
 		   );
 
    initial begin
-      run_test("");//svs_test");      
+      run_test("");//svs_test");
    end
 endmodule // svs_top
diff --git a/lesson0019_uvm_config_db/svs_dut.sv b/lesson0019_uvm_config_db/svs_dut.sv
index 803453d..19b03fa 100644
--- a/lesson0019_uvm_config_db/svs_dut.sv
+++ b/lesson0019_uvm_config_db/svs_dut.sv
@@ -9,11 +9,11 @@ module svs_dut(
 	       );
 
    always@(posedge clk) begin
-      if (!resetn) 
+      if (!resetn)
 	outbus <= 32'd0;
       else begin
-	 outbus <= inbus3 | inbus2 | inbus1 | inbus0;	 
+	 outbus <= inbus3 | inbus2 | inbus1 | inbus0;
 	 $display(" inbus 0=%8x 1=%8x 2=%8x 3=%8x",inbus0, inbus1, inbus2, inbus3);
       end
    end
-endmodule
\ No newline at end of file
+endmodule
diff --git a/lesson0019_uvm_config_db/svs_env.svh b/lesson0019_uvm_config_db/svs_env.svh
index 85a0c96..43e2333 100644
--- a/lesson0019_uvm_config_db/svs_env.svh
+++ b/lesson0019_uvm_config_db/svs_env.svh
@@ -12,7 +12,7 @@ class svs_env extends uvm_env;
 
 
    function void build_phase(uvm_phase phase);
-      
+
    endfunction : build_phase
 
-endclass : svs_env
\ No newline at end of file
+endclass : svs_env
diff --git a/lesson0019_uvm_config_db/svs_if.sv b/lesson0019_uvm_config_db/svs_if.sv
index 7cd29d2..34a2384 100644
--- a/lesson0019_uvm_config_db/svs_if.sv
+++ b/lesson0019_uvm_config_db/svs_if.sv
@@ -1,3 +1,3 @@
 interface svs_if (input clk, input resetn);
    logic [31:0] bus32;
-endinterface
\ No newline at end of file
+endinterface
diff --git a/lesson0019_uvm_config_db/svs_test.sv b/lesson0019_uvm_config_db/svs_test.sv
index 1cc88fd..8126675 100644
--- a/lesson0019_uvm_config_db/svs_test.sv
+++ b/lesson0019_uvm_config_db/svs_test.sv
@@ -4,9 +4,9 @@ import uvm_pkg::*;
 class svs_test extends uvm_test;
    string receiver;
    int albert;
-      
+
    `uvm_component_utils(svs_test)
-   
+
    function new(string name="svs_test", uvm_component parent=null);
       super.new(name,parent);
       uvm_config_db#(string)::set(uvm_root::get(),"*","my_string","linc_learns");
@@ -19,9 +19,9 @@ class svs_test extends uvm_test;
       void'(uvm_config_db#(string)::get(uvm_root::get(),"*","my_string",receiver));
       void'(uvm_config_db#(int)::get(null,null,"albert_variable",albert));
 
-      repeat(3) 
+      repeat(3)
 	`uvm_info("DBG",$psprintf("Got: >>%0s<<>>%0d<<",receiver,albert),UVM_NONE)
-      
+
       phase.drop_objection(this);
    endtask : run_phase
-endclass : svs_test
\ No newline at end of file
+endclass : svs_test
diff --git a/lesson0019_uvm_config_db/svs_top.sv b/lesson0019_uvm_config_db/svs_top.sv
index 0fab0b9..df8e9ca 100644
--- a/lesson0019_uvm_config_db/svs_top.sv
+++ b/lesson0019_uvm_config_db/svs_top.sv
@@ -8,8 +8,8 @@ module svs_top ();
    initial               //w/ initial works!
      svs_test_u = new();
 // * /
-   
+
    initial begin
-      run_test("");//svs_test");      
+      run_test("");//svs_test");
    end
 endmodule // svs_top
diff --git a/lesson0020_package_import_include/classA.sv b/lesson0020_package_import_include/classA.sv
index 86b683b..c854c7b 100644
--- a/lesson0020_package_import_include/classA.sv
+++ b/lesson0020_package_import_include/classA.sv
@@ -7,4 +7,4 @@ class classA;
       $display("\n\n ***************** priviet ***************\n\n");
    endfunction
 
-endclass : classA
\ No newline at end of file
+endclass : classA
diff --git a/lesson0020_package_import_include/my_package1.sv b/lesson0020_package_import_include/my_package1.sv
index 4eb0e3d..6d59b13 100644
--- a/lesson0020_package_import_include/my_package1.sv
+++ b/lesson0020_package_import_include/my_package1.sv
@@ -1,7 +1,7 @@
 package my_package1;
 
    import my_package2::*;
-   
+
    int valueA;
 
    function void tellmex();
diff --git a/lesson0021_X_and_unary_operators/top.sv b/lesson0021_X_and_unary_operators/top.sv
index 1f67dac..17ff387 100644
--- a/lesson0021_X_and_unary_operators/top.sv
+++ b/lesson0021_X_and_unary_operators/top.sv
@@ -1,21 +1,21 @@
 module top;
 
    //check for unknown on bus when valid=1
-   
+
    initial begin
       test(1, 8'h80);
       test(1, 8'b1010101X);
    end
-  
+
 
    function test(input logic valid, input  logic [7:0] bus, input string note="-");
       $display("\n\n             ****%0s****",note);
       $display("valid=%1b  bus=%2h   ",valid,bus);
-      $display("|%2h=%1b   ",bus,(|bus)); 
-      $display("&%2h=%1b   ",bus,(&bus)); 
-      $display("^%2h=%1b   ",bus,(^bus)); 
-      $display(" 1&(^bus)=%1b  ",(1&(^bus))); 
-      $display(" 1|(^bus)=%1b  ",(1|(^bus))); 
+      $display("|%2h=%1b   ",bus,(|bus));
+      $display("&%2h=%1b   ",bus,(&bus));
+      $display("^%2h=%1b   ",bus,(^bus));
+      $display(" 1&(^bus)=%1b  ",(1&(^bus)));
+      $display(" 1|(^bus)=%1b  ",(1|(^bus)));
 
 
       $display("\n");
diff --git a/lesson0022_package_chaining_export/branch_pkg.sv b/lesson0022_package_chaining_export/branch_pkg.sv
index aa50198..bba6dc0 100644
--- a/lesson0022_package_chaining_export/branch_pkg.sv
+++ b/lesson0022_package_chaining_export/branch_pkg.sv
@@ -1,11 +1,11 @@
 package branch_pkg;
    import twig_pkg::*;
   // export *::*;
-      
+
    function void branch_hi();
       $display("%m: I am branch");
       twig_hi();
       //leaf_hi();
    endfunction
 
-endpackage : branch_pkg
\ No newline at end of file
+endpackage : branch_pkg
diff --git a/lesson0022_package_chaining_export/leaf_pkg.sv b/lesson0022_package_chaining_export/leaf_pkg.sv
index d38c4a1..ed7edba 100644
--- a/lesson0022_package_chaining_export/leaf_pkg.sv
+++ b/lesson0022_package_chaining_export/leaf_pkg.sv
@@ -11,11 +11,11 @@ package leaf_pkg;
 endpackage : leaf_pkg
 
 /*module mod(input logic a_signal, clk);
-   q9876543210: assert property 
+   q9876543210: assert property
    (@(posedge clk) !$isunknown(a_signal));
 endmodule // mod
 */
 checker mod(input logic a_signal, clk);
-   q9876543210: assert property 
+   q9876543210: assert property
    (@(posedge clk) !$isunknown(a_signal));
 endchecker // mod
diff --git a/lesson0022_package_chaining_export/top.sv b/lesson0022_package_chaining_export/top.sv
index c46f6e6..45bb594 100644
--- a/lesson0022_package_chaining_export/top.sv
+++ b/lesson0022_package_chaining_export/top.sv
@@ -16,5 +16,5 @@ module top;
    always begin  clk = #2 ~clk;   end
 
    mod mod(.*);
-   
+
 endmodule // top
diff --git a/lesson0022_package_chaining_export/trunk.svh b/lesson0022_package_chaining_export/trunk.svh
index 09a2460..30e42fd 100644
--- a/lesson0022_package_chaining_export/trunk.svh
+++ b/lesson0022_package_chaining_export/trunk.svh
@@ -7,4 +7,4 @@ class trunk;
       //leaf_hi();
    endfunction : new
 
-endclass : trunk
\ No newline at end of file
+endclass : trunk
diff --git a/lesson0022_package_chaining_export/twig_pkg.sv b/lesson0022_package_chaining_export/twig_pkg.sv
index b8f3763..38433de 100644
--- a/lesson0022_package_chaining_export/twig_pkg.sv
+++ b/lesson0022_package_chaining_export/twig_pkg.sv
@@ -1,10 +1,10 @@
 package twig_pkg;
    import leaf_pkg::leaf_hi;
    //export leaf_pkg::*;
-   
+
    function void twig_hi();
       $display("%m: I am twig");
       leaf_hi();
    endfunction
 
-endpackage : twig_pkg
\ No newline at end of file
+endpackage : twig_pkg
-- 
1.8.1.5

